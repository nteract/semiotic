(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
	(factory((global.Semiotic = {}),global.React,global.ReactDOM));
}(this, (function (exports,React,reactDom) { 'use strict';

// from Evan Wang's https://github.com/tinker10/D3-Labeler
/*eslint-disable */
var labeler = function () {
  var lab = [],
      anc = [],
      w = 1,
      // box width
  h = 1,
      // box width
  labeler = {};

  var max_move = 5.0,
      max_angle = 0.5;

  // weights
  var w_len = 0.2,
      // leader line length
  w_inter = 1.0,
      // leader line intersection
  w_lab2 = 30.0,
      // label-label overlap
  w_lab_anc = 30.0,
      // label-anchor overlap
  w_orient = 3.0; // orientation bias

  // booleans for user defined functions
  var user_energy = false;

  var user_defined_energy = void 0;

  var energy = function energy(index) {
    // energy function, tailored for label placement

    var m = lab.length,
        ener = 0,
        dx = lab[index].x - anc[index].x,
        dy = anc[index].y - lab[index].y,
        dist = Math.sqrt(dx * dx + dy * dy);

    // penalty for length of leader line
    if (dist > 0) ener += dist * w_len;

    // label orientation bias
    dx /= dist;
    dy /= dist;
    if (dx > 0 && dy > 0) {
      ener += 0 * w_orient;
    } else if (dx < 0 && dy > 0) {
      ener += 1 * w_orient;
    } else if (dx < 0 && dy < 0) {
      ener += 2 * w_orient;
    } else {
      ener += 3 * w_orient;
    }

    var x21 = lab[index].x,
        y21 = lab[index].y - lab[index].height + 2.0,
        x22 = lab[index].x + lab[index].width,
        y22 = lab[index].y + 2.0;
    var x11 = void 0,
        x12 = void 0,
        y11 = void 0,
        y12 = void 0,
        x_overlap = void 0,
        y_overlap = void 0,
        overlap_area = void 0;

    for (var i = 0; i < m; i++) {
      if (i !== index) {
        // penalty for intersection of leader lines
        var _overlap = intersect(anc[index].x, lab[index].x, anc[i].x, lab[i].x, anc[index].y, lab[index].y, anc[i].y, lab[i].y);
        if (_overlap) ener += w_inter;

        // penalty for label-label overlap
        x11 = lab[i].x;
        y11 = lab[i].y - lab[i].height + 2.0;
        x12 = lab[i].x + lab[i].width;
        y12 = lab[i].y + 2.0;
        x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
        y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
        overlap_area = x_overlap * y_overlap;
        ener += overlap_area * w_lab2;
      }

      // penalty for label-anchor overlap
      x11 = anc[i].x - anc[i].r;
      y11 = anc[i].y - anc[i].r;
      x12 = anc[i].x + anc[i].r;
      y12 = anc[i].y + anc[i].r;
      x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
      y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));
      overlap_area = x_overlap * y_overlap;
      ener += overlap_area * w_lab_anc;
    }
    return ener;
  };

  var mcmove = function mcmove(currT) {
    // Monte Carlo translation move

    // select a random label
    var i = Math.floor(Math.random() * lab.length);

    // save old coordinates
    var x_old = lab[i].x;
    var y_old = lab[i].y;

    // old energy
    var old_energy = void 0;
    if (user_energy) {
      old_energy = user_defined_energy(i, lab, anc);
    } else {
      old_energy = energy(i);
    }

    // random translation
    lab[i].x += (Math.random() - 0.5) * max_move;
    lab[i].y += (Math.random() - 0.5) * max_move;

    // hard wall boundaries
    if (lab[i].x > w) lab[i].x = x_old;
    if (lab[i].x < 0) lab[i].x = x_old;
    if (lab[i].y > h) lab[i].y = y_old;
    if (lab[i].y < 0) lab[i].y = y_old;

    // new energy
    var new_energy = void 0;
    if (user_energy) {
      new_energy = user_defined_energy(i, lab, anc);
    } else {
      new_energy = energy(i);
    }

    // delta E
    var delta_energy = new_energy - old_energy;

    if (Math.random() < Math.exp(-delta_energy / currT)) {
      
    } else {
      // move back to old coordinates
      lab[i].x = x_old;
      lab[i].y = y_old;
      
    }
  };

  var mcrotate = function mcrotate(currT) {
    // Monte Carlo rotation move

    // select a random label
    var i = Math.floor(Math.random() * lab.length);

    // save old coordinates
    var x_old = lab[i].x;
    var y_old = lab[i].y;

    // old energy
    var old_energy = void 0;
    if (user_energy) {
      old_energy = user_defined_energy(i, lab, anc);
    } else {
      old_energy = energy(i);
    }

    // random angle
    var angle = (Math.random() - 0.5) * max_angle;

    var s = Math.sin(angle);
    var c = Math.cos(angle);

    // translate label (relative to anchor at origin):
    lab[i].x -= anc[i].x;
    lab[i].y -= anc[i].y;

    // rotate label
    var x_new = lab[i].x * c - lab[i].y * s,
        y_new = lab[i].x * s + lab[i].y * c;

    // translate label back
    lab[i].x = x_new + anc[i].x;
    lab[i].y = y_new + anc[i].y;

    // hard wall boundaries
    if (lab[i].x > w) lab[i].x = x_old;
    if (lab[i].x < 0) lab[i].x = x_old;
    if (lab[i].y > h) lab[i].y = y_old;
    if (lab[i].y < 0) lab[i].y = y_old;

    // new energy
    var new_energy = void 0;
    if (user_energy) {
      new_energy = user_defined_energy(i, lab, anc);
    } else {
      new_energy = energy(i);
    }

    // delta E
    var delta_energy = new_energy - old_energy;

    if (Math.random() < Math.exp(-delta_energy / currT)) {
      
    } else {
      // move back to old coordinates
      lab[i].x = x_old;
      lab[i].y = y_old;
      
    }
  };

  var intersect = function intersect(x1, x2, x3, x4, y1, y2, y3, y4) {
    // returns true if two lines intersect, else false
    // from http://paulbourke.net/geometry/lineline2d/

    var mua = void 0,
        mub = void 0;
    var denom = void 0,
        numera = void 0,
        numerb = void 0;

    denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    numera = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    numerb = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

    /* Is the intersection along the the segments */
    mua = numera / denom;
    mub = numerb / denom;
    if (!(mua < 0 || mua > 1 || mub < 0 || mub > 1)) {
      return true;
    }
    return false;
  };

  var cooling_schedule = function cooling_schedule(currT, initialT, nsweeps) {
    // linear cooling
    return currT - initialT / nsweeps;
  };

  labeler.start = function (nsweeps) {
    // main simulated annealing function
    var m = lab.length,
        currT = 1.0,
        initialT = 1.0;

    for (var i = 0; i < nsweeps; i++) {
      for (var j = 0; j < m; j++) {
        if (Math.random() < 0.5) {
          mcmove(currT);
        } else {
          mcrotate(currT);
        }
      }
      currT = cooling_schedule(currT, initialT, nsweeps);
    }
  };

  labeler.width = function (x) {
    // users insert graph width
    if (!arguments.length) return w;
    w = x;
    return labeler;
  };

  labeler.height = function (x) {
    // users insert graph height
    if (!arguments.length) return h;
    h = x;
    return labeler;
  };

  labeler.label = function (x) {
    // users insert label positions
    if (!arguments.length) return lab;
    lab = x;
    return labeler;
  };

  labeler.anchor = function (x) {
    // users insert anchor positions
    if (!arguments.length) return anc;
    anc = x;
    return labeler;
  };

  labeler.alt_energy = function (x) {
    // user defined energy
    if (!arguments.length) return energy;
    user_defined_energy = x;
    user_energy = true;
    return labeler;
  };

  labeler.alt_schedule = function (x) {
    // user defined cooling_schedule
    if (!arguments.length) return cooling_schedule;
    return labeler;
  };

  return labeler;
};
/*eslint-enable */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var basicPointSizeFunction = function basicPointSizeFunction() {
  return 5;
};
var basicLabelSizeFunction = function basicLabelSizeFunction(noteData, characterWidth, lineHeight, padding) {
  var text = noteData.note.label || noteData.note.title;

  var textLength = text.length;
  var wrap = noteData.note.wrap || 120;
  var width = Math.min(wrap, textLength * characterWidth) + padding * 2;
  var height = Math.ceil(textLength * characterWidth / 120) * lineHeight + padding * 2;
  return [width, height];
};

function bumpAnnotations(adjustableNotes, props, processor) {
  var size = props.size,
      propsPointSizeFunction = props.pointSizeFunction,
      propsLabelSizeFunction = props.labelSizeFunction;
  var _processor$padding = processor.padding,
      padding = _processor$padding === undefined ? 1 : _processor$padding,
      _processor$characterW = processor.characterWidth,
      characterWidth = _processor$characterW === undefined ? 8 : _processor$characterW,
      _processor$lineHeight = processor.lineHeight,
      lineHeight = _processor$lineHeight === undefined ? 20 : _processor$lineHeight,
      _processor$iterations = processor.iterations,
      iterations = _processor$iterations === undefined ? 500 : _processor$iterations,
      _processor$pointSizeF = processor.pointSizeFunction,
      pointSizeFunction = _processor$pointSizeF === undefined ? propsPointSizeFunction || basicPointSizeFunction : _processor$pointSizeF,
      _processor$labelSizeF = processor.labelSizeFunction,
      labelSizeFunction = _processor$labelSizeF === undefined ? propsLabelSizeFunction || basicLabelSizeFunction : _processor$labelSizeF;


  var labels = adjustableNotes.map(function (d, i) {
    var anchorX = d.props.noteData.x + (d.props.noteData.dx !== undefined ? d.props.noteData.dx : (i % 3 - 1) * -10);
    var anchorY = d.props.noteData.y + (d.props.noteData.dy !== undefined ? d.props.noteData.dy : (i % 3 - 1) * 10);

    var _labelSizeFunction = labelSizeFunction(d.props.noteData, characterWidth, lineHeight, padding),
        _labelSizeFunction2 = slicedToArray(_labelSizeFunction, 2),
        labelWidth = _labelSizeFunction2[0],
        labelHeight = _labelSizeFunction2[1];

    return {
      x: anchorX,
      y: anchorY,
      above: anchorY < d.props.noteData.y,
      left: anchorX < d.props.noteData.x,
      width: labelWidth,
      height: labelHeight,
      type: "label",
      name: "",
      originalNote: d
    };
  });

  var points = adjustableNotes.map(function (d) {
    return {
      x: d.props.noteData.x,
      y: d.props.noteData.y,
      fx: d.props.noteData.x,
      fy: d.props.noteData.y,
      r: pointSizeFunction(d.props.noteData),
      type: "point",
      originalNote: d
    };
  });

  labeler().label(labels).anchor(points).width(size[0]).height(size[1]).start(iterations);

  labels.forEach(function (d) {
    if (d.type === "label") {
      var adjusted = adjustedXY(d.originalNote.props.noteData, d, padding);
      d.originalNote.props.noteData.nx = adjusted[0];
      d.originalNote.props.noteData.ny = adjusted[1];
    }
  });

  return adjustableNotes;
}

function adjustedXY(note, calculated /*, padding*/) {
  if (note.y > calculated.y) {
    //below
    return [calculated.x + calculated.width / 2, calculated.y - calculated.height];
  }
  return [calculated.x + calculated.width / 2, calculated.y];
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

var emptyFunction_1 = emptyFunction;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

var invariant_1 = invariant;

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

var factoryWithThrowingShims = function factoryWithThrowingShims() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }
    invariant_1(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction_1;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    module.exports = factoryWithThrowingShims();
  }
});

var typeHash = {
  fill: function fill(style) {
    return React.createElement("rect", { style: style, width: 20, height: 20 });
  },
  line: function line(style) {
    return React.createElement("line", { style: style, x1: 0, y1: 0, x2: 20, y2: 20 });
  }
};

var Legend = function (_React$Component) {
  inherits(Legend, _React$Component);

  function Legend() {
    classCallCheck(this, Legend);
    return possibleConstructorReturn(this, (Legend.__proto__ || Object.getPrototypeOf(Legend)).apply(this, arguments));
  }

  createClass(Legend, [{
    key: "renderLegendGroup",
    value: function renderLegendGroup(legendGroup) {
      var _legendGroup$type = legendGroup.type,
          type = _legendGroup$type === undefined ? "fill" : _legendGroup$type,
          styleFn = legendGroup.styleFn,
          items = legendGroup.items;

      var renderedItems = [];
      var itemOffset = 0;
      items.forEach(function (item, i) {
        var Type = typeHash[type];
        var renderedType = void 0;
        if (Type) {
          var style = styleFn(item, i);
          renderedType = Type(style);
        } else {
          renderedType = type(item);
        }
        renderedItems.push(React.createElement(
          "g",
          { key: "legend-item-" + i, transform: "translate(0," + itemOffset + ")" },
          renderedType,
          React.createElement(
            "text",
            { y: 15, x: 30 },
            item.label
          )
        ));
        itemOffset += 25;
      });
      return renderedItems;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          legendGroups = _props.legendGroups,
          _props$title = _props.title,
          title = _props$title === undefined ? "Legend" : _props$title,
          _props$width = _props.width,
          width = _props$width === undefined ? 100 : _props$width;

      var offset = 30;
      var renderedGroups = [];
      legendGroups.forEach(function (l, i) {
        offset += 5;
        renderedGroups.push(React.createElement("line", {
          key: "legend-top-line legend-symbol-" + i,
          stroke: "gray",
          x1: 0,
          y1: offset,
          x2: width,
          y2: offset
        }));
        offset += 10;
        if (l.label) {
          offset += 20;
          renderedGroups.push(React.createElement(
            "text",
            {
              key: "legend-text-" + i,
              y: offset,
              className: "legend-group-label"
            },
            l.label
          ));
          offset += 10;
        }

        renderedGroups.push(React.createElement(
          "g",
          {
            key: "legend-group-" + i,
            className: "legend-item",
            transform: "translate(0," + offset + ")"
          },
          _this2.renderLegendGroup(l)
        ));
        offset += l.items.length * 25 + 10;
      });

      return React.createElement(
        "g",
        null,
        React.createElement(
          "text",
          { className: "legend-title", y: 20, x: width / 2, textAnchor: "middle" },
          title
        ),
        renderedGroups
      );
    }
  }]);
  return Legend;
}(React.Component);

Legend.propTypes = {
  title: propTypes.string,
  width: propTypes.number,
  legendGroups: propTypes.array
};

var Connector_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Connector = function (_React$Component) {
    _inherits(Connector, _React$Component);

    function Connector() {
      _classCallCheck(this, Connector);

      return _possibleConstructorReturn(this, (Connector.__proto__ || Object.getPrototypeOf(Connector)).apply(this, arguments));
    }

    _createClass(Connector, [{
      key: "getComponents",
      value: function getComponents() {}
    }, {
      key: "render",
      value: function render() {
        var _props = this.props,
            color = _props.color,
            dx = _props.dx,
            dy = _props.dy,
            customID = _props.customID;

        if (dx === 0 && dy === 0) {
          return _react2.default.createElement("g", { className: "annotation-connector" });
        }

        var d = this.getComponents(this.props) || [];
        var cleanedProps = Object.assign({}, this.props);
        delete cleanedProps.children;

        var childrenWithProps = _react2.default.Children.map(this.props.children, function (child) {
          return _react2.default.cloneElement(child, _extends$$1({}, cleanedProps, child.props, {
            scale: cleanedProps.endScale || child.props.endScale,
            lineData: d.components[0].data
          }));
        });

        return _react2.default.createElement("g", _extends$$1({ className: "annotation-connector" }, this.props.gAttrs), d.components && d.components.map(function (c, i) {
          var attrs = {};
          if (!c) return null;
          Object.keys(c.attrs).forEach(function (k) {
            if (c.attrs[k] && k !== "text") {
              attrs[k.replace(/-([a-z])/g, function (g) {
                return g[1].toUpperCase();
              })] = c.attrs[k];
            }
          });
          return _react2.default.createElement(c.type, _extends$$1({
            mask: customID ? "url(#" + customID + ")" : undefined,
            key: i,
            className: c.className,
            fill: "none",
            stroke: color
          }, attrs), c.attrs.text);
        }), childrenWithProps);
      }
    }]);

    return Connector;
  }(_react2.default.Component);

  exports.default = Connector;
});

unwrapExports(Connector_1);

var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path();
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function moveTo(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function lineTo(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {}

      // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21;

            // If the start tangent is not coincident with (x0,y0), line to.
            if (Math.abs(t01 - 1) > epsilon) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }

            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
  },
  arc: function arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
  },
  rect: function rect(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function toString() {
    return this._;
  }
};

var constant = function (x) {
  return function constant() {
    return x;
  };
};

var epsilon$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi = pi$1 / 2;
var tau$1 = 2 * pi$1;

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc = function () {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$1)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$1 - epsilon$1) {
        context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$1) {
          context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
              rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$1) {
            var p0 = asin(rp / r0 * Math.sin(ap)),
                p1 = asin(rp / r1 * Math.sin(ap));
            if ((da0 -= p0 * 2) > epsilon$1) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$1) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * Math.cos(a01),
              y01 = r1 * Math.sin(a01),
              x10 = r0 * Math.cos(a10),
              y10 = r0 * Math.sin(a10);

          // Apply rounded corners?
          if (rc > epsilon$1) {
            var x11 = r1 * Math.cos(a11),
                y11 = r1 * Math.sin(a11),
                x00 = r0 * Math.cos(a00),
                y00 = r0 * Math.sin(a00);

            // Restrict the corner radius according to the sector angle.
            if (da < pi$1) {
              var oc = da0 > epsilon$1 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                  ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                  lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
              rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$1)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$1) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$1) || !(da0 > epsilon$1)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$1) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
};

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        this._context.lineTo(x, y);break;
    }
  }
};

var curveLinear = function (context) {
  return new Linear(context);
};

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

var line = function () {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function (_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area = function () {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending = function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity = function (d) {
  return d;
};

var pie = function () {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau$1),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function areaStart() {
    this._curve.areaStart();
  },
  areaEnd: function areaEnd() {
    this._curve.areaEnd();
  },
  lineStart: function lineStart() {
    this._curve.lineStart();
  },
  lineEnd: function lineEnd() {
    this._curve.lineEnd();
  },
  point: function point(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

var radialLine$1 = function () {
  return radialLine(line().curve(curveRadialLinear));
};

var radialArea = function () {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return radialLine(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return radialLine(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return radialLine(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return radialLine(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
};

var circle = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / pi$1);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$1);
  }
};

var cross = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

var diamond = {
  draw: function draw(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810;
var kr = Math.sin(pi$1 / 10) / Math.sin(7 * pi$1 / 10);
var kx = Math.sin(tau$1 / 10) * kr;
var ky = -Math.cos(tau$1 / 10) * kr;

var star = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
            var a = tau$1 * i / 5,
                c = Math.cos(a),
                s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
    }
};

var square = {
  draw: function draw(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5;
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

var wye = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
    }
};

var symbols = [circle, cross, diamond, square, star, triangle, wye];

var symbol = function () {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop = function () {};

function _point(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 3:
        _point(this, this._x1, this._y1); // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default:
        _point(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis = function (context) {
  return new Basis(context);
};

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x2 = x, this._y2 = y;break;
      case 1:
        this._point = 2;this._x3 = x, this._y3 = y;break;
      case 2:
        this._point = 3;this._x4 = x, this._y4 = y;this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);break;
      default:
        _point(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed = function (context) {
  return new BasisClosed(context);
};

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen = function (context) {
  return new BasisOpen(context);
};

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function _point$1(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        _point$1(this, this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;this._x1 = x, this._y1 = y;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$1(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$1(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal$$1.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$1(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal$$1(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal$$1.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal$$1;
})(0);

function _point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$1) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        this.point(this._x2, this._y2);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$2(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$2(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$2(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._point) this._context.closePath();
  },
  point: function point(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

var curveLinearClosed = function (context) {
  return new LinearClosed(context);
};

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function _point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
      case 3:
        _point$3(this, this._t0, slope2(this, this._t0));break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;_point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);break;
      default:
        _point$3(this, this._t0, t1 = slope3(this, x, y));break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) {
    a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  }a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) {
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  }a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) {
    a[i] = (r[i] - a[i + 1]) / b[i];
  }b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) {
    b[i] = 2 * x[i + 1] - a[i + 1];
  }return [a, b];
}

var natural = function (context) {
  return new Natural(context);
};

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
    }
    this._x = x, this._y = y;
  }
};

var step = function (context) {
  return new Step(context, 0.5);
};

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

var slice = Array.prototype.slice;

var none = function (series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$1 = function (series) {
  var n = series.length,
      o = new Array(n);
  while (--n >= 0) {
    o[n] = n;
  }return o;
};

function stackValue(d, key) {
  return d[key];
}

var stack = function () {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
};

var expand = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }if (y) for (i = 0; i < n; ++i) {
      series[i][j][1] /= y;
    }
  }
  none(series, order);
};

var silhouette = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
};

var wiggle = function (series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
};

var ascending = function (series) {
  var sums = series.map(sum);
  return none$1(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
};

function sum(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;
  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }return s;
}

var descending$1 = function (series) {
  return ascending(series).reverse();
};

var insideOut = function (series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = none$1(series).sort(function (a, b) {
    return sums[b] - sums[a];
  }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse = function (series) {
  return none$1(series).reverse();
};



var d3Shape = Object.freeze({
	arc: arc,
	area: area,
	line: line,
	pie: pie,
	radialArea: radialArea,
	radialLine: radialLine$1,
	symbol: symbol,
	symbols: symbols,
	symbolCircle: circle,
	symbolCross: cross,
	symbolDiamond: diamond,
	symbolSquare: square,
	symbolStar: star,
	symbolTriangle: triangle,
	symbolWye: wye,
	curveBasisClosed: basisClosed,
	curveBasisOpen: basisOpen,
	curveBasis: basis,
	curveBundle: bundle,
	curveCardinalClosed: cardinalClosed,
	curveCardinalOpen: cardinalOpen,
	curveCardinal: cardinal,
	curveCatmullRomClosed: catmullRomClosed,
	curveCatmullRomOpen: catmullRomOpen,
	curveCatmullRom: curveCatmullRom,
	curveLinearClosed: curveLinearClosed,
	curveLinear: curveLinear,
	curveMonotoneX: monotoneX,
	curveMonotoneY: monotoneY,
	curveNatural: natural,
	curveStep: step,
	curveStepAfter: stepAfter,
	curveStepBefore: stepBefore,
	stack: stack,
	stackOffsetExpand: expand,
	stackOffsetNone: none,
	stackOffsetSilhouette: silhouette,
	stackOffsetWiggle: wiggle,
	stackOrderAscending: ascending,
	stackOrderDescending: descending$1,
	stackOrderInsideOut: insideOut,
	stackOrderNone: none$1,
	stackOrderReverse: reverse
});

var Builder = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.arcBuilder = exports.pathBuilder = exports.lineBuilder = undefined;

  var lineBuilder = exports.lineBuilder = function lineBuilder(_ref) {
    var data = _ref.data,
        _ref$curve = _ref.curve,
        curve = _ref$curve === undefined ? d3Shape.curveLinear : _ref$curve,
        canvasContext = _ref.canvasContext,
        className = _ref.className,
        classID = _ref.classID;

    var lineGen = (0, d3Shape.line)().curve(curve);

    var builder = {
      type: "path",
      className: className,
      classID: classID,
      data: data
    };

    if (canvasContext) {
      lineGen.context(canvasContext);
      builder.pathMethods = lineGen;
    } else {
      builder.attrs = {
        d: lineGen(data)
      };
    }

    return builder;
  };

  var pathBuilder = exports.pathBuilder = function pathBuilder(_ref2) {
    var d = _ref2.d,
        _ref2$curve = _ref2.curve,
        curve = _ref2$curve === undefined ? d3Shape.curveLinear : _ref2$curve,
        canvasContext = _ref2.canvasContext,
        className = _ref2.className,
        classID = _ref2.classID;

    var lineGen = (0, d3Shape.line)().curve(curve);

    var builder = {
      type: "path",
      className: className,
      classID: classID
    };

    if (canvasContext) {
      lineGen.context(canvasContext);
    } else {
      builder.attrs = {
        d: d
      };
    }

    return builder;
  };

  var arcBuilder = exports.arcBuilder = function arcBuilder(_ref3) {
    var data = _ref3.data,
        canvasContext = _ref3.canvasContext,
        className = _ref3.className,
        classID = _ref3.classID;

    var builder = {
      type: "path",
      className: className,
      classID: classID,
      data: data
    };

    var arcShape = (0, d3Shape.arc)().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);

    if (canvasContext) {
      arcShape.context(canvasContext);
    } else {
      builder.attrs = {
        d: arcShape()
      };
    }

    return builder;
  };
});

unwrapExports(Builder);
var Builder_1 = Builder.arcBuilder;
var Builder_2 = Builder.pathBuilder;
var Builder_3 = Builder.lineBuilder;

var typeLine = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.lineSetup = undefined;

  var lineSetup = exports.lineSetup = function lineSetup(_ref) {
    var dx = _ref.dx,
        dy = _ref.dy,
        radius = _ref.radius,
        outerRadius = _ref.outerRadius,
        radiusPadding = _ref.radiusPadding,
        width = _ref.width,
        height = _ref.height;

    var x1 = 0,
        x2 = dx,
        y1 = 0,
        y2 = dy;

    if (outerRadius || radius) {
      var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
      var angle = Math.asin(-y2 / h);
      var r = (outerRadius || radius) + (radiusPadding || 0);

      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
      y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
    }

    if (width && height) {
      if (width > 0 && dx > 0 || width < 0 && dx < 0) {
        if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
      }
      if (height > 0 && dy > 0 || height < 0 && dy < 0) {
        if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
      }
      if (x1 === width / 2 && y1 === height / 2) {
        x1 = x2;
        y1 = y2;
      }
    }

    return [[x1, y1], [x2, y2]];
  };

  exports.default = function (connectorData) {
    var data = lineSetup(connectorData);
    return { components: [(0, Builder.lineBuilder)({ data: data, className: "connector" })] };
  };
});

unwrapExports(typeLine);
var typeLine_1 = typeLine.lineSetup;

var typeCurve = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  var createPoints = function createPoints(offset) {
    var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

    var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
    var p = [];

    var i = 1;
    for (; i <= anchors; i++) {
      p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
    }
    return p;
  };

  exports.default = function (_ref) {
    var curve = _ref.curve,
        points = _ref.points,
        x = _ref.x,
        y = _ref.y,
        dx = _ref.dx,
        dy = _ref.dy,
        radius = _ref.radius,
        outerRadius = _ref.outerRadius,
        width = _ref.width,
        height = _ref.height;

    if (!points || typeof points === "number") {
      points = createPoints({ x: dx, y: dy }, points);
    }
    if (!curve) {
      curve = d3Shape.curveCatmullRom;
    }

    var handles = [];

    // if (type.editMode) {
    //   const cHandles = connectorData.points.map((c, i) => ({
    //     ...pointHandle({ cx: c[0], cy: c[1] }),
    //     index: i
    //   }))

    //   const updatePoint = index => {
    //     connectorData.points[index][0] += event.dx
    //     connectorData.points[index][1] += event.dy
    //     type.redrawConnector()
    //   }

    //   handles = type.mapHandles(
    //     cHandles.map(h => ({ ...h.move, drag: updatePoint.bind(type, h.index) }))
    //   )
    // }

    // let data = lineSetup({ type, subjectType })
    var data = (0, typeLine.lineSetup)({ x: x, y: y, dx: dx, dy: dy, radius: radius, outerRadius: outerRadius, width: width, height: height });
    data = [data[0]].concat(_toConsumableArray(points), [data[1]]);
    var components = [(0, Builder.lineBuilder)({ data: data, curve: curve, className: "connector" })];

    return { components: components, handles: handles };
  };
});

unwrapExports(typeCurve);

var ConnectorCurve_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _typeCurve2 = _interopRequireDefault(typeCurve);

  var _Connector3 = _interopRequireDefault(Connector_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var ConnectorCurve = function (_Connector) {
    _inherits(ConnectorCurve, _Connector);

    function ConnectorCurve() {
      _classCallCheck(this, ConnectorCurve);

      return _possibleConstructorReturn(this, (ConnectorCurve.__proto__ || Object.getPrototypeOf(ConnectorCurve)).apply(this, arguments));
    }

    _createClass(ConnectorCurve, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var curve = _ref.curve,
            points = _ref.points,
            x = _ref.x,
            y = _ref.y,
            dx = _ref.dx,
            dy = _ref.dy,
            radius = _ref.radius,
            outerRadius = _ref.outerRadius,
            width = _ref.width,
            height = _ref.height;

        return (0, _typeCurve2.default)({
          curve: curve,
          points: points,
          x: x,
          y: y,
          dx: dx,
          dy: dy,
          radius: radius,
          outerRadius: outerRadius,
          width: width,
          height: height
        });
      }
    }]);

    return ConnectorCurve;
  }(_Connector3.default);

  exports.default = ConnectorCurve;
});

unwrapExports(ConnectorCurve_1);

var typeElbow = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var dx = _ref.dx,
        dy = _ref.dy,
        radius = _ref.radius,
        outerRadius = _ref.outerRadius,
        radiusPadding = _ref.radiusPadding,
        width = _ref.width,
        height = _ref.height;

    var x1 = 0,
        x2 = dx,
        y1 = 0,
        y2 = dy;

    if (width && height) {
      if (width > 0 && dx > 0 || width < 0 && dx < 0) {
        if (Math.abs(width) > Math.abs(dx)) x1 = width / 2;else x1 = width;
      }
      if (height > 0 && dy > 0 || height < 0 && dy < 0) {
        if (Math.abs(height) > Math.abs(dy)) y1 = height / 2;else y1 = height;
      }
      if (x1 === width / 2 && y1 === height / 2) {
        x1 = x2;
        y1 = y2;
      }
    }

    var data = [[x1, y1], [x2, y2]];

    var diffY = y2 - y1;
    var diffX = x2 - x1;
    var xe = x2;
    var ye = y2;
    var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;

    if (Math.abs(diffX) < Math.abs(diffY)) {
      xe = x2;
      ye = y1 + diffX * opposite;
    } else {
      ye = y2;
      xe = x1 + diffY * opposite;
    }

    if (outerRadius || radius) {
      var r = (outerRadius || radius) + (radiusPadding || 0);
      var length = r / Math.sqrt(2);

      if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
        x1 = length * (x2 < 0 ? -1 : 1);
        y1 = length * (y2 < 0 ? -1 : 1);
        data = [[x1, y1], [xe, ye], [x2, y2]];
      } else if (Math.abs(diffX) > Math.abs(diffY)) {
        var angle = Math.asin(-y2 / r);
        x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
        data = [[x1, y2], [x2, y2]];
      } else {
        var _angle = Math.acos(x2 / r);
        y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
        data = [[x2, y1], [x2, y2]];
      }
    } else {
      data = [[x1, y1], [xe, ye], [x2, y2]];
    }

    return { components: [(0, Builder.lineBuilder)({ data: data, className: "connector" })] };
  };
});

unwrapExports(typeElbow);

var ConnectorElbow_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _typeElbow2 = _interopRequireDefault(typeElbow);

  var _Connector3 = _interopRequireDefault(Connector_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var ConnectorElbow = function (_Connector) {
    _inherits(ConnectorElbow, _Connector);

    function ConnectorElbow() {
      _classCallCheck(this, ConnectorElbow);

      return _possibleConstructorReturn(this, (ConnectorElbow.__proto__ || Object.getPrototypeOf(ConnectorElbow)).apply(this, arguments));
    }

    _createClass(ConnectorElbow, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var x = _ref.x,
            y = _ref.y,
            dy = _ref.dy,
            dx = _ref.dx,
            radius = _ref.radius,
            radiusPadding = _ref.radiusPadding,
            outerRadius = _ref.outerRadius,
            width = _ref.width,
            height = _ref.height;

        return (0, _typeElbow2.default)({
          x: x,
          y: y,
          dx: dx,
          dy: dy,
          radius: radius,
          radiusPadding: radiusPadding,
          outerRadius: outerRadius,
          width: width,
          height: height
        });
      }
    }]);

    return ConnectorElbow;
  }(_Connector3.default);

  exports.default = ConnectorElbow;
});

unwrapExports(ConnectorElbow_1);

var ConnectorLine_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _typeLine2 = _interopRequireDefault(typeLine);

  var _Connector3 = _interopRequireDefault(Connector_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var ConnectorLine = function (_Connector) {
    _inherits(ConnectorLine, _Connector);

    function ConnectorLine() {
      _classCallCheck(this, ConnectorLine);

      return _possibleConstructorReturn(this, (ConnectorLine.__proto__ || Object.getPrototypeOf(ConnectorLine)).apply(this, arguments));
    }

    _createClass(ConnectorLine, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var x = _ref.x,
            y = _ref.y,
            dy = _ref.dy,
            dx = _ref.dx,
            radius = _ref.radius,
            outerRadius = _ref.outerRadius,
            width = _ref.width,
            height = _ref.height;

        return (0, _typeLine2.default)({ x: x, y: y, dx: dx, dy: dy, radius: radius, outerRadius: outerRadius, width: width, height: height });
      }
    }]);

    return ConnectorLine;
  }(_Connector3.default);

  exports.default = ConnectorLine;
});

unwrapExports(ConnectorLine_1);

var endDot = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var lineData = _ref.lineData,
        _ref$scale = _ref.scale,
        scale = _ref$scale === undefined ? 1 : _ref$scale;

    var dot = (0, Builder.arcBuilder)({
      className: "connector-end connector-dot",
      classID: "connector-end",
      data: { radius: 3 * Math.sqrt(scale) }
    });
    dot.attrs.transform = "translate(" + lineData[0][0] + ", " + lineData[0][1] + ")";

    return { components: [dot] };
  };
});

unwrapExports(endDot);

var ConnectorEnd_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var ConnectorEnd = function (_React$Component) {
    _inherits(ConnectorEnd, _React$Component);

    function ConnectorEnd() {
      _classCallCheck(this, ConnectorEnd);

      return _possibleConstructorReturn(this, (ConnectorEnd.__proto__ || Object.getPrototypeOf(ConnectorEnd)).apply(this, arguments));
    }

    _createClass(ConnectorEnd, [{
      key: "getComponents",
      value: function getComponents() {}
    }, {
      key: "render",
      value: function render() {
        var color = this.props.color;

        var d = this.getComponents(this.props) || [];
        var c = d.components[0];

        return _react2.default.createElement(c.type, _extends$$1({ className: c.className }, c.attrs, { fill: color }));
      }
    }]);

    return ConnectorEnd;
  }(_react2.default.Component);

  exports.default = ConnectorEnd;
});

unwrapExports(ConnectorEnd_1);

var ConnectorEndDot_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _endDot2 = _interopRequireDefault(endDot);

  var _ConnectorEnd3 = _interopRequireDefault(ConnectorEnd_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var ConnectorEndDot = function (_ConnectorEnd) {
    _inherits(ConnectorEndDot, _ConnectorEnd);

    function ConnectorEndDot() {
      _classCallCheck(this, ConnectorEndDot);

      return _possibleConstructorReturn(this, (ConnectorEndDot.__proto__ || Object.getPrototypeOf(ConnectorEndDot)).apply(this, arguments));
    }

    _createClass(ConnectorEndDot, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var x = _ref.x,
            y = _ref.y,
            dy = _ref.dy,
            dx = _ref.dx,
            lineData = _ref.lineData,
            scale = _ref.scale;

        return (0, _endDot2.default)({ x: x, y: y, dx: dx, dy: dy, lineData: lineData, scale: scale });
      }
    }]);

    return ConnectorEndDot;
  }(_ConnectorEnd3.default);

  exports.default = ConnectorEndDot;

  ConnectorEndDot.propTypes = {
    x: _propTypes2.default.number,
    y: _propTypes2.default.number,
    dx: _propTypes2.default.number,
    dy: _propTypes2.default.number,
    scale: _propTypes2.default.number,
    lineData: _propTypes2.default.array
    //array of arrays of x,y coordinates for the connector line
  };
});

unwrapExports(ConnectorEndDot_1);

var endArrow = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var dx = _ref.dx,
        dy = _ref.dy,
        start = _ref.start,
        end = _ref.end,
        _ref$scale = _ref.scale,
        scale = _ref$scale === undefined ? 1 : _ref$scale;

    if (!start) {
      start = [dx, dy];
    } else {
      start = [-end[0] + start[0], -end[1] + start[1]];
    }
    if (!end) {
      end = [0, 0];
    }

    var x1 = end[0],
        y1 = end[1];

    var size = 10 * scale;
    var angleOffset = 16 / 180 * Math.PI;
    var angle = Math.atan(start[1] / start[0]);

    if (start[0] < 0) {
      angle += Math.PI;
    }

    var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];

    //TODO add in reverse
    // if (canvasContext.arrowReverse){
    //   data = [[x1, y1],
    //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
    //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
    //   [x1, y1]
    //   ]
    // } else {
    //   data = [[x1, y1],
    //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
    //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
    //   [x1, y1]
    //   ]
    // }

    return {
      components: [(0, Builder.lineBuilder)({
        data: data,
        className: "connector-end connector-arrow",
        classID: "connector-end"
      })]
    };
  };
});

unwrapExports(endArrow);

var ConnectorEndArrow_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _endArrow2 = _interopRequireDefault(endArrow);

  var _ConnectorEnd3 = _interopRequireDefault(ConnectorEnd_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var ConnectorEndArrow = function (_ConnectorEnd) {
    _inherits(ConnectorEndArrow, _ConnectorEnd);

    function ConnectorEndArrow() {
      _classCallCheck(this, ConnectorEndArrow);

      return _possibleConstructorReturn(this, (ConnectorEndArrow.__proto__ || Object.getPrototypeOf(ConnectorEndArrow)).apply(this, arguments));
    }

    _createClass(ConnectorEndArrow, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var x = _ref.x,
            y = _ref.y,
            dy = _ref.dy,
            dx = _ref.dx,
            lineData = _ref.lineData,
            scale = _ref.scale;

        var start = lineData[1];
        var end = lineData[0];
        var distance = Math.sqrt(Math.pow(start[0] - end[0], 2) + Math.pow(start[1] - end[1], 2));
        if (distance < 5 && lineData[2]) {
          start = lineData[2];
        }

        return (0, _endArrow2.default)({ x: x, y: y, dx: dx, dy: dy, start: start, end: end, scale: scale });
      }
    }]);

    return ConnectorEndArrow;
  }(_ConnectorEnd3.default);

  exports.default = ConnectorEndArrow;

  ConnectorEndArrow.propTypes = {
    x: _propTypes2.default.number,
    y: _propTypes2.default.number,
    dx: _propTypes2.default.number,
    dy: _propTypes2.default.number,
    scale: _propTypes2.default.number,
    lineData: _propTypes2.default.array
  };
});

unwrapExports(ConnectorEndArrow_1);

var reactDraggable = createCommonjsModule(function (module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(reactDom, React);
  })(commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_6__) {
    return (/******/function (modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/var installedModules = {};
        /******/
        /******/ // The require function
        /******/function __webpack_require__(moduleId) {
          /******/
          /******/ // Check if module is in cache
          /******/if (installedModules[moduleId]) {
            /******/return installedModules[moduleId].exports;
            /******/
          }
          /******/ // Create a new module (and put it into the cache)
          /******/var module = installedModules[moduleId] = {
            /******/i: moduleId,
            /******/l: false,
            /******/exports: {}
            /******/ };
          /******/
          /******/ // Execute the module function
          /******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          /******/
          /******/ // Flag the module as loaded
          /******/module.l = true;
          /******/
          /******/ // Return the exports of the module
          /******/return module.exports;
          /******/
        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/__webpack_require__.m = modules;
        /******/
        /******/ // expose the module cache
        /******/__webpack_require__.c = installedModules;
        /******/
        /******/ // define getter function for harmony exports
        /******/__webpack_require__.d = function (exports, name, getter) {
          /******/if (!__webpack_require__.o(exports, name)) {
            /******/Object.defineProperty(exports, name, {
              /******/configurable: false,
              /******/enumerable: true,
              /******/get: getter
              /******/ });
            /******/
          }
          /******/
        };
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/__webpack_require__.n = function (module) {
          /******/var getter = module && module.__esModule ?
          /******/function getDefault() {
            return module['default'];
          } :
          /******/function getModuleExports() {
            return module;
          };
          /******/__webpack_require__.d(getter, 'a', getter);
          /******/return getter;
          /******/
        };
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/__webpack_require__.o = function (object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/
        /******/ // __webpack_public_path__
        /******/__webpack_require__.p = "";
        /******/
        /******/ // Load entry module and return exports
        /******/return __webpack_require__(__webpack_require__.s = 12);
        /******/
      }(
      /************************************************************************/
      /******/[
      /* 0 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.findInArray = findInArray;
        exports.isFunction = isFunction;
        exports.isNum = isNum;
        exports.int = int;
        exports.dontSetMe = dontSetMe;

        // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
        function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/{
          for (var i = 0, length = array.length; i < length; i++) {
            if (callback.apply(callback, [array[i], i, array])) return array[i];
          }
        }

        function isFunction(func /*: any*/) /*: boolean*/{
          return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
        }

        function isNum(num /*: any*/) /*: boolean*/{
          return typeof num === 'number' && !isNaN(num);
        }

        function int(a /*: string*/) /*: number*/{
          return parseInt(a, 10);
        }

        function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
          if (props[propName]) {
            return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
          }
        }

        /***/
      },
      /* 1 */
      /***/function (module, exports, __webpack_require__) {

        function makeEmptyFunction(arg) {
          return function () {
            return arg;
          };
        }

        /**
         * This function accepts and discards inputs; it has no side effects. This is
         * primarily useful idiomatically for overridable function endpoints which
         * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
         */
        var emptyFunction = function emptyFunction() {};

        emptyFunction.thatReturns = makeEmptyFunction;
        emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
        emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
        emptyFunction.thatReturnsNull = makeEmptyFunction(null);
        emptyFunction.thatReturnsThis = function () {
          return this;
        };
        emptyFunction.thatReturnsArgument = function (arg) {
          return arg;
        };

        module.exports = emptyFunction;

        /***/
      },
      /* 2 */
      /***/function (module, exports, __webpack_require__) {

        var validateFormat = function validateFormat(format) {};

        if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
          validateFormat = function validateFormat(format) {
            if (format === undefined) {
              throw new Error('invariant requires an error message argument');
            }
          };
        }

        function invariant(condition, format, a, b, c, d, e, f) {
          validateFormat(format);

          if (!condition) {
            var error;
            if (format === undefined) {
              error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
            } else {
              var args = [a, b, c, d, e, f];
              var argIndex = 0;
              error = new Error(format.replace(/%s/g, function () {
                return args[argIndex++];
              }));
              error.name = 'Invariant Violation';
            }

            error.framesToPop = 1; // we don't care about invariant's own frame
            throw error;
          }
        }

        module.exports = invariant;

        /***/
      },
      /* 3 */
      /***/function (module, exports, __webpack_require__) {

        var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

        module.exports = ReactPropTypesSecret;

        /***/
      },
      /* 4 */
      /***/function (module, exports) {

        module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

        /***/
      },
      /* 5 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends$$1 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }return target;
        };

        exports.matchesSelector = matchesSelector;
        exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
        exports.addEvent = addEvent;
        exports.removeEvent = removeEvent;
        exports.outerHeight = outerHeight;
        exports.outerWidth = outerWidth;
        exports.innerHeight = innerHeight;
        exports.innerWidth = innerWidth;
        exports.offsetXYFromParent = offsetXYFromParent;
        exports.createCSSTransform = createCSSTransform;
        exports.createSVGTransform = createSVGTransform;
        exports.getTouch = getTouch;
        exports.getTouchIdentifier = getTouchIdentifier;
        exports.addUserSelectStyles = addUserSelectStyles;
        exports.removeUserSelectStyles = removeUserSelectStyles;
        exports.styleHacks = styleHacks;
        exports.addClassName = addClassName;
        exports.removeClassName = removeClassName;

        var _shims = __webpack_require__(0);

        var _getPrefix = __webpack_require__(18);

        var _getPrefix2 = _interopRequireDefault(_getPrefix);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }return obj;
        }

        /*:: import type {ControlPosition, MouseTouchEvent} from './types';*/

        var matchesSelectorFunc = '';
        function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/{
          if (!matchesSelectorFunc) {
            matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
              // $FlowIgnore: Doesn't think elements are indexable
              return (0, _shims.isFunction)(el[method]);
            });
          }

          // $FlowIgnore: Doesn't think elements are indexable
          return el[matchesSelectorFunc].call(el, selector);
        }

        // Works up the tree to the draggable itself attempting to match selector.
        function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/{
          var node = el;
          do {
            if (matchesSelector(node, selector)) return true;
            if (node === baseNode) return false;
            node = node.parentNode;
          } while (node);

          return false;
        }

        function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/{
          if (!el) {
            return;
          }
          if (el.attachEvent) {
            el.attachEvent('on' + event, handler);
          } else if (el.addEventListener) {
            el.addEventListener(event, handler, true);
          } else {
            // $FlowIgnore: Doesn't think elements are indexable
            el['on' + event] = handler;
          }
        }

        function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/{
          if (!el) {
            return;
          }
          if (el.detachEvent) {
            el.detachEvent('on' + event, handler);
          } else if (el.removeEventListener) {
            el.removeEventListener(event, handler, true);
          } else {
            // $FlowIgnore: Doesn't think elements are indexable
            el['on' + event] = null;
          }
        }

        function outerHeight(node /*: HTMLElement*/) /*: number*/{
          // This is deliberately excluding margin for our calculations, since we are using
          // offsetTop which is including margin. See getBoundPosition
          var height = node.clientHeight;
          var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
          height += (0, _shims.int)(computedStyle.borderTopWidth);
          height += (0, _shims.int)(computedStyle.borderBottomWidth);
          return height;
        }

        function outerWidth(node /*: HTMLElement*/) /*: number*/{
          // This is deliberately excluding margin for our calculations, since we are using
          // offsetLeft which is including margin. See getBoundPosition
          var width = node.clientWidth;
          var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
          width += (0, _shims.int)(computedStyle.borderLeftWidth);
          width += (0, _shims.int)(computedStyle.borderRightWidth);
          return width;
        }
        function innerHeight(node /*: HTMLElement*/) /*: number*/{
          var height = node.clientHeight;
          var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
          height -= (0, _shims.int)(computedStyle.paddingTop);
          height -= (0, _shims.int)(computedStyle.paddingBottom);
          return height;
        }

        function innerWidth(node /*: HTMLElement*/) /*: number*/{
          var width = node.clientWidth;
          var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
          width -= (0, _shims.int)(computedStyle.paddingLeft);
          width -= (0, _shims.int)(computedStyle.paddingRight);
          return width;
        }

        // Get from offsetParent
        function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/{
          var isBody = offsetParent === offsetParent.ownerDocument.body;
          var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();

          var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
          var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;

          return { x: x, y: y };
        }

        function createCSSTransform(_ref) /*: Object*/{
          var x = _ref.x,
              y = _ref.y;

          // Replace unitless items with px
          return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');
        }

        function createSVGTransform(_ref3) /*: string*/{
          var x = _ref3.x,
              y = _ref3.y;

          return 'translate(' + x + ',' + y + ')';
        }

        function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/{
          return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
            return identifier === t.identifier;
          }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
            return identifier === t.identifier;
          });
        }

        function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/{
          if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
          if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
        }

        // User-select Hacks:
        //
        // Useful for preventing blue highlights all over everything when dragging.

        // Note we're passing `document` b/c we could be iframed
        function addUserSelectStyles(doc /*: Document*/) {
          var styleEl = doc.getElementById('react-draggable-style-el');
          if (!styleEl) {
            styleEl = doc.createElement('style');
            styleEl.type = 'text/css';
            styleEl.id = 'react-draggable-style-el';
            styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {background: transparent;}\n';
            styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {background: transparent;}\n';
            doc.getElementsByTagName('head')[0].appendChild(styleEl);
          }
          if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
        }

        function removeUserSelectStyles(doc /*: Document*/) {
          if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');
          window.getSelection().removeAllRanges(); // remove selection caused by scroll
        }

        function styleHacks() /*: Object*/{
          var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          // Workaround IE pointer events; see #51
          // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
          return _extends$$1({
            touchAction: 'none'
          }, childStyle);
        }

        function addClassName(el /*: HTMLElement*/, className /*: string*/) {
          if (el.classList) {
            el.classList.add(className);
          } else {
            if (!el.className.match(new RegExp('(?:^|\\s)' + className + '(?!\\S)'))) {
              el.className += ' ' + className;
            }
          }
        }

        function removeClassName(el /*: HTMLElement*/, className /*: string*/) {
          if (el.classList) {
            el.classList.remove(className);
          } else {
            el.className = el.className.replace(new RegExp('(?:^|\\s)' + className + '(?!\\S)', 'g'), '');
          }
        }

        /***/
      },
      /* 6 */
      /***/function (module, exports) {

        module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

        /***/
      },
      /* 7 */
      /***/function (module, exports, __webpack_require__) {

        /**
         * Copyright 2013-present, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * LICENSE file in the root directory of this source tree. An additional grant
         * of patent rights can be found in the PATENTS file in the same directory.
         */

        if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
          var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

          var isValidElement = function isValidElement(object) {
            return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          };

          // By explicitly using `prop-types` you are opting into new development behavior.
          // http://fb.me/prop-types-in-prod
          var throwOnDirectAccess = true;
          module.exports = __webpack_require__(14)(isValidElement, throwOnDirectAccess);
        } else {
          // By explicitly using `prop-types` you are opting into new production behavior.
          // http://fb.me/prop-types-in-prod
          module.exports = __webpack_require__(16)();
        }

        /***/
      },
      /* 8 */
      /***/function (module, exports, __webpack_require__) {

        var emptyFunction = __webpack_require__(1);

        /**
         * Similar to invariant but only logs a warning if the condition is not met.
         * This can be used to log issues in development environments in critical
         * paths. Removing the logging code for production environments will keep the
         * same logic and follow the same code paths.
         */

        var warning = emptyFunction;

        if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
          var printWarning = function printWarning(format) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }

            var argIndex = 0;
            var message = 'Warning: ' + format.replace(/%s/g, function () {
              return args[argIndex++];
            });
            if (typeof console !== 'undefined') {
              console.error(message);
            }
            try {
              // --- Welcome to debugging React ---
              // This error was thrown as a convenience so that you can use this stack
              // to find the callsite that caused this warning to fire.
              throw new Error(message);
            } catch (x) {}
          };

          warning = function warning(condition, format) {
            if (format === undefined) {
              throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
            }

            if (format.indexOf('Failed Composite propType: ') === 0) {
              return; // Ignore CompositeComponent proptype check.
            }

            if (!condition) {
              for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                args[_key2 - 2] = arguments[_key2];
              }

              printWarning.apply(undefined, [format].concat(args));
            }
          };
        }

        module.exports = warning;

        /***/
      },
      /* 9 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getBoundPosition = getBoundPosition;
        exports.snapToGrid = snapToGrid;
        exports.canDragX = canDragX;
        exports.canDragY = canDragY;
        exports.getControlPosition = getControlPosition;
        exports.createCoreData = createCoreData;
        exports.createDraggableData = createDraggableData;

        var _shims = __webpack_require__(0);

        var _reactDom = __webpack_require__(4);

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _domFns = __webpack_require__(5);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        /*:: import type Draggable from '../Draggable';*/
        /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/
        /*:: import type DraggableCore from '../DraggableCore';*/
        function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{
          // If no bounds, short-circuit and move on
          if (!draggable.props.bounds) return [x, y];

          // Clone new bounds
          var bounds = draggable.props.bounds;

          bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
          var node = findDOMNode(draggable);

          if (typeof bounds === 'string') {
            var ownerDocument = node.ownerDocument;

            var ownerWindow = ownerDocument.defaultView;
            var boundNode = void 0;
            if (bounds === 'parent') {
              boundNode = node.parentNode;
            } else {
              boundNode = ownerDocument.querySelector(bounds);
            }
            if (!(boundNode instanceof HTMLElement)) {
              throw new Error('Bounds selector "' + bounds + '" could not find an element.');
            }
            var nodeStyle = ownerWindow.getComputedStyle(node);
            var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
            // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
            bounds = {
              left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
              top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
              right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
              bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
            };
          }

          // Keep x and y below right and bottom limits...
          if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
          if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);

          // But above left and top limits.
          if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
          if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);

          return [x, y];
        }

        function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{
          var x = Math.round(pendingX / grid[0]) * grid[0];
          var y = Math.round(pendingY / grid[1]) * grid[1];
          return [x, y];
        }

        function canDragX(draggable /*: Draggable*/) /*: boolean*/{
          return draggable.props.axis === 'both' || draggable.props.axis === 'x';
        }

        function canDragY(draggable /*: Draggable*/) /*: boolean*/{
          return draggable.props.axis === 'both' || draggable.props.axis === 'y';
        }

        // Get {x, y} positions from event.
        function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{
          var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
          if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
          var node = findDOMNode(draggableCore);
          // User can provide an offsetParent if desired.
          var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
          return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
        }

        // Create an data object exposed by <DraggableCore>'s events
        function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{
          var state = draggable.state;
          var isStart = !(0, _shims.isNum)(state.lastX);
          var node = findDOMNode(draggable);

          if (isStart) {
            // If this is our first move, use the x and y as last coords.
            return {
              node: node,
              deltaX: 0, deltaY: 0,
              lastX: x, lastY: y,
              x: x, y: y
            };
          } else {
            // Otherwise calculate proper values.
            return {
              node: node,
              deltaX: x - state.lastX, deltaY: y - state.lastY,
              lastX: state.lastX, lastY: state.lastY,
              x: x, y: y
            };
          }
        }

        // Create an data exposed by <Draggable>'s events
        function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{
          return {
            node: coreData.node,
            x: draggable.state.x + coreData.deltaX,
            y: draggable.state.y + coreData.deltaY,
            deltaX: coreData.deltaX,
            deltaY: coreData.deltaY,
            lastX: draggable.state.x,
            lastY: draggable.state.y
          };
        }

        // A lot faster than stringify/parse
        function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{
          return {
            left: bounds.left,
            top: bounds.top,
            right: bounds.right,
            bottom: bounds.bottom
          };
        }

        function findDOMNode(draggable /*: Draggable | DraggableCore*/) /*: HTMLElement*/{
          var node = _reactDom2.default.findDOMNode(draggable);
          if (!node) {
            throw new Error('<DraggableCore>: Unmounted during event!');
          }
          // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME
          return node;
        }

        /***/
      },
      /* 10 */
      /***/function (module, exports, __webpack_require__) {

        (function (process) {

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;_e = err;
              } finally {
                try {
                  if (!_n && _i["return"]) _i["return"]();
                } finally {
                  if (_d) throw _e;
                }
              }return _arr;
            }return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }
            };
          }();

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
              }
            }return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
            };
          }();

          var _react = __webpack_require__(6);

          var _react2 = _interopRequireDefault(_react);

          var _propTypes = __webpack_require__(7);

          var _propTypes2 = _interopRequireDefault(_propTypes);

          var _reactDom = __webpack_require__(4);

          var _reactDom2 = _interopRequireDefault(_reactDom);

          var _domFns = __webpack_require__(5);

          var _positionFns = __webpack_require__(9);

          var _shims = __webpack_require__(0);

          var _log = __webpack_require__(11);

          var _log2 = _interopRequireDefault(_log);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
            }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }

          /*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/

          // Simple abstraction for dragging events names.
          /*:: import type {Element as ReactElement} from 'react';*/
          var eventsFor = {
            touch: {
              start: 'touchstart',
              move: 'touchmove',
              stop: 'touchend'
            },
            mouse: {
              start: 'mousedown',
              move: 'mousemove',
              stop: 'mouseup'
            }
          };

          // Default to mouse events.
          var dragEventFor = eventsFor.mouse;

          /*:: type DraggableCoreState = {
            dragging: boolean,
            lastX: number,
            lastY: number,
            touchIdentifier: ?number
          };*/
          /*:: export type DraggableBounds = {
            left: number,
            right: number,
            top: number,
            bottom: number,
          };*/
          /*:: export type DraggableData = {
            node: HTMLElement,
            x: number, y: number,
            deltaX: number, deltaY: number,
            lastX: number, lastY: number,
          };*/
          /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void;*/
          /*:: export type ControlPosition = {x: number, y: number};*/

          //
          // Define <DraggableCore>.
          //
          // <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
          // work well with libraries that require more control over the element.
          //

          /*:: export type DraggableCoreProps = {
            allowAnyClick: boolean,
            cancel: string,
            children: ReactElement<any>,
            disabled: boolean,
            enableUserSelectHack: boolean,
            offsetParent: HTMLElement,
            grid: [number, number],
            handle: string,
            onStart: DraggableEventHandler,
            onDrag: DraggableEventHandler,
            onStop: DraggableEventHandler,
            onMouseDown: (e: MouseEvent) => void,
          };*/

          var DraggableCore = function (_React$Component) {
            _inherits(DraggableCore, _React$Component);

            function DraggableCore() {
              var _ref;

              var _temp, _this, _ret;

              _classCallCheck(this, DraggableCore);

              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
                dragging: false,
                // Used while dragging to determine deltas.
                lastX: NaN, lastY: NaN,
                touchIdentifier: null
              }, _this.handleDragStart = function (e) {
                // Make it possible to attach event handlers on top of this one.
                _this.props.onMouseDown(e);

                // Only accept left-clicks.
                if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;

                // Get nodes. Be sure to grab relative document (could be iframed)
                var thisNode = _reactDom2.default.findDOMNode(_this);
                if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
                  throw new Error('<DraggableCore> not mounted on DragStart!');
                }
                var ownerDocument = thisNode.ownerDocument;

                // Short circuit if handle or cancel prop was provided and selector doesn't match.

                if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, thisNode)) {
                  return;
                }

                // Set touch identifier in component state if this is a touch event. This allows us to
                // distinguish between individual touches on multitouch screens by identifying which
                // touchpoint was set to this element.
                var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
                _this.setState({ touchIdentifier: touchIdentifier });

                // Get the current drag point from the event. This is used as the offset.
                var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
                if (position == null) return; // not possible but satisfies flow
                var x = position.x,
                    y = position.y;

                // Create an event object with all the data parents need to make a decision here.

                var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent);

                // Call event handler. If it returns explicit false, cancel.
                (0, _log2.default)('calling', _this.props.onStart);
                var shouldUpdate = _this.props.onStart(e, coreEvent);
                if (shouldUpdate === false) return;

                // Add a style to the body to disable user-select. This prevents text from
                // being selected all over the page.
                if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);

                // Initiate dragging. Set the current x and y as offsets
                // so we know how much we've moved during the drag. This allows us
                // to drag elements around even if they have been moved, without issue.
                _this.setState({
                  dragging: true,

                  lastX: x,
                  lastY: y
                });

                // Add events to the document directly so we catch when the user's mouse/touch moves outside of
                // this element. We use different events depending on whether or not we have detected that this
                // is a touch-capable device.
                (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
                (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
              }, _this.handleDrag = function (e) {

                // Prevent scrolling on mobile devices, like ipad/iphone.
                if (e.type === 'touchmove') e.preventDefault();

                // Get the current drag point from the event. This is used as the offset.
                var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
                if (position == null) return;
                var x = position.x,
                    y = position.y;

                // Snap to grid if prop has been provided

                if (Array.isArray(_this.props.grid)) {
                  var _deltaX = x - _this.state.lastX,
                      _deltaY = y - _this.state.lastY;

                  var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, _deltaX, _deltaY);

                  var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);

                  _deltaX = _snapToGrid2[0];
                  _deltaY = _snapToGrid2[1];

                  if (!_deltaX && !_deltaY) return; // skip useless drag
                  x = _this.state.lastX + _deltaX, y = _this.state.lastY + _deltaY;
                }

                var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent);

                // Call event handler. If it returns explicit false, trigger end.
                var shouldUpdate = _this.props.onDrag(e, coreEvent);
                if (shouldUpdate === false) {
                  try {
                    // $FlowIgnore
                    _this.handleDragStop(new MouseEvent('mouseup'));
                  } catch (err) {
                    // Old browsers
                    var event = document.createEvent('MouseEvents');
                    // I see why this insanity was deprecated
                    // $FlowIgnore
                    event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    _this.handleDragStop(event);
                  }
                  return;
                }

                _this.setState({
                  lastX: x,
                  lastY: y
                });
              }, _this.handleDragStop = function (e) {
                if (!_this.state.dragging) return;

                var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
                if (position == null) return;
                var x = position.x,
                    y = position.y;

                var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);

                var thisNode = _reactDom2.default.findDOMNode(_this);
                if (thisNode) {
                  // Remove user-select hack
                  if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
                }

                (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent);

                // Reset the el.
                _this.setState({
                  dragging: false,
                  lastX: NaN,
                  lastY: NaN
                });

                // Call event handler
                _this.props.onStop(e, coreEvent);

                if (thisNode) {
                  // Remove event handlers
                  (0, _log2.default)('DraggableCore: Removing handlers');
                  (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
                  (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
                }
              }, _this.onMouseDown = function (e) {
                dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

                return _this.handleDragStart(e);
              }, _this.onMouseUp = function (e) {
                dragEventFor = eventsFor.mouse;

                return _this.handleDragStop(e);
              }, _this.onTouchStart = function (e) {
                // We're on a touch device now, so change the event handlers
                dragEventFor = eventsFor.touch;

                return _this.handleDragStart(e);
              }, _this.onTouchEnd = function (e) {
                // We're on a touch device now, so change the event handlers
                dragEventFor = eventsFor.touch;

                return _this.handleDragStop(e);
              }, _temp), _possibleConstructorReturn(_this, _ret);
            }

            _createClass(DraggableCore, [{
              key: 'componentWillUnmount',
              value: function componentWillUnmount() {
                // Remove any leftover event handlers. Remove both touch and mouse handlers in case
                // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
                var thisNode = _reactDom2.default.findDOMNode(this);
                if (thisNode) {
                  var ownerDocument = thisNode.ownerDocument;

                  (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
                  (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
                  (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
                  (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
                  if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument);
                }
              }

              // Same as onMouseDown (start drag), but now consider this a touch device.

            }, {
              key: 'render',
              value: function render() {
                // Reuse the child provided
                // This makes it flexible to use whatever element is wanted (div, ul, etc)
                return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
                  style: (0, _domFns.styleHacks)(this.props.children.props.style),

                  // Note: mouseMove handler is attached to document so it will still function
                  // when the user drags quickly and leaves the bounds of the element.
                  onMouseDown: this.onMouseDown,
                  onTouchStart: this.onTouchStart,
                  onMouseUp: this.onMouseUp,
                  onTouchEnd: this.onTouchEnd
                });
              }
            }]);

            return DraggableCore;
          }(_react2.default.Component);

          DraggableCore.displayName = 'DraggableCore';
          DraggableCore.propTypes = {
            /**
             * `allowAnyClick` allows dragging using any mouse button.
             * By default, we only accept the left button.
             *
             * Defaults to `false`.
             */
            allowAnyClick: _propTypes2.default.bool,

            /**
             * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
             * with the exception of `onMouseDown`, will not fire.
             */
            disabled: _propTypes2.default.bool,

            /**
             * By default, we add 'user-select:none' attributes to the document body
             * to prevent ugly text selection during drag. If this is causing problems
             * for your app, set this to `false`.
             */
            enableUserSelectHack: _propTypes2.default.bool,

            /**
             * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
             * instead of using the parent node.
             */
            offsetParent: function offsetParent(props, propName) {
              if (process.browser && props[propName] && props[propName].nodeType !== 1) {
                throw new Error('Draggable\'s offsetParent must be a DOM Node.');
              }
            },

            /**
             * `grid` specifies the x and y that dragging should snap to.
             */
            grid: _propTypes2.default.arrayOf(_propTypes2.default.number),

            /**
             * `handle` specifies a selector to be used as the handle that initiates drag.
             *
             * Example:
             *
             * ```jsx
             *   let App = React.createClass({
             *       render: function () {
             *         return (
             *            <Draggable handle=".handle">
             *              <div>
             *                  <div className="handle">Click me to drag</div>
             *                  <div>This is some other content</div>
             *              </div>
             *           </Draggable>
             *         );
             *       }
             *   });
             * ```
             */
            handle: _propTypes2.default.string,

            /**
             * `cancel` specifies a selector to be used to prevent drag initialization.
             *
             * Example:
             *
             * ```jsx
             *   let App = React.createClass({
             *       render: function () {
             *           return(
             *               <Draggable cancel=".cancel">
             *                   <div>
             *                     <div className="cancel">You can't drag from here</div>
             *                     <div>Dragging here works fine</div>
             *                   </div>
             *               </Draggable>
             *           );
             *       }
             *   });
             * ```
             */
            cancel: _propTypes2.default.string,

            /**
             * Called when dragging starts.
             * If this function returns the boolean false, dragging will be canceled.
             */
            onStart: _propTypes2.default.func,

            /**
             * Called while dragging.
             * If this function returns the boolean false, dragging will be canceled.
             */
            onDrag: _propTypes2.default.func,

            /**
             * Called when dragging stops.
             * If this function returns the boolean false, the drag will remain active.
             */
            onStop: _propTypes2.default.func,

            /**
             * A workaround option which can be passed if onMouseDown needs to be accessed,
             * since it'll always be blocked (as there is internal use of onMouseDown)
             */
            onMouseDown: _propTypes2.default.func,

            /**
             * These properties should be defined on the child, not here.
             */
            className: _shims.dontSetMe,
            style: _shims.dontSetMe,
            transform: _shims.dontSetMe
          };
          DraggableCore.defaultProps = {
            allowAnyClick: false, // by default only accept left click
            cancel: null,
            disabled: false,
            enableUserSelectHack: true,
            offsetParent: null,
            handle: null,
            grid: null,
            transform: null,
            onStart: function onStart() {},
            onDrag: function onDrag() {},
            onStop: function onStop() {},
            onMouseDown: function onMouseDown() {}
          };
          exports.default = DraggableCore;
          /* WEBPACK VAR INJECTION */
        }).call(exports, __webpack_require__(19));

        /***/
      },
      /* 11 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.default = log;

        /*eslint no-console:0*/
        function log() {
          var _console;

          if (undefined) (_console = console).log.apply(_console, arguments);
        }

        /***/
      },
      /* 12 */
      /***/function (module, exports, __webpack_require__) {

        var Draggable = __webpack_require__(13).default;

        // Previous versions of this lib exported <Draggable> as the root export. As to not break
        // them, or TypeScript, we export *both* as the root and as 'default'.
        // See https://github.com/mzabriskie/react-draggable/pull/254
        // and https://github.com/mzabriskie/react-draggable/issues/266
        module.exports = Draggable;
        module.exports.default = Draggable;
        module.exports.DraggableCore = __webpack_require__(10).default;

        /***/
      },
      /* 13 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _extends$$1 = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }return target;
        };

        var _slicedToArray = function () {
          function sliceIterator(arr, i) {
            var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
              for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);if (i && _arr.length === i) break;
              }
            } catch (err) {
              _d = true;_e = err;
            } finally {
              try {
                if (!_n && _i["return"]) _i["return"]();
              } finally {
                if (_d) throw _e;
              }
            }return _arr;
          }return function (arr, i) {
            if (Array.isArray(arr)) {
              return arr;
            } else if (Symbol.iterator in Object(arr)) {
              return sliceIterator(arr, i);
            } else {
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            }
          };
        }();

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
          }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
          };
        }();

        var _react = __webpack_require__(6);

        var _react2 = _interopRequireDefault(_react);

        var _propTypes = __webpack_require__(7);

        var _propTypes2 = _interopRequireDefault(_propTypes);

        var _reactDom = __webpack_require__(4);

        var _reactDom2 = _interopRequireDefault(_reactDom);

        var _classnames = __webpack_require__(17);

        var _classnames2 = _interopRequireDefault(_classnames);

        var _domFns = __webpack_require__(5);

        var _positionFns = __webpack_require__(9);

        var _shims = __webpack_require__(0);

        var _DraggableCore = __webpack_require__(10);

        var _DraggableCore2 = _interopRequireDefault(_DraggableCore);

        var _log = __webpack_require__(11);

        var _log2 = _interopRequireDefault(_log);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : { default: obj };
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }return obj;
        }

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _possibleConstructorReturn(self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
          }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        /*:: import type {ControlPosition, DraggableBounds, DraggableCoreProps} from './DraggableCore';*/
        /*:: import type {DraggableEventHandler} from './utils/types';*/
        /*:: import type {Element as ReactElement} from 'react';*/
        /*:: type DraggableState = {
          dragging: boolean,
          dragged: boolean,
          x: number, y: number,
          slackX: number, slackY: number,
          isElementSVG: boolean
        };*/

        //
        // Define <Draggable>
        //

        /*:: export type DraggableProps = {
          ...$Exact<DraggableCoreProps>,
          axis: 'both' | 'x' | 'y' | 'none',
          bounds: DraggableBounds | string | false,
          defaultClassName: string,
          defaultClassNameDragging: string,
          defaultClassNameDragged: string,
          defaultPosition: ControlPosition,
          position: ControlPosition,
        };*/

        var Draggable = function (_React$Component) {
          _inherits(Draggable, _React$Component);

          function Draggable(props /*: DraggableProps*/) {
            _classCallCheck(this, Draggable);

            var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));

            _this.onDragStart = function (e, coreData) {
              (0, _log2.default)('Draggable: onDragStart: %j', coreData);

              // Short-circuit if user's callback killed it.
              var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
              // Kills start event on core as well, so move handlers are never bound.
              if (shouldStart === false) return false;

              _this.setState({ dragging: true, dragged: true });
            };

            _this.onDrag = function (e, coreData) {
              if (!_this.state.dragging) return false;
              (0, _log2.default)('Draggable: onDrag: %j', coreData);

              var uiData = (0, _positionFns.createDraggableData)(_this, coreData);

              var newState /*: $Shape<DraggableState>*/ = {
                x: uiData.x,
                y: uiData.y
              };

              // Keep within bounds.
              if (_this.props.bounds) {
                // Save original x and y.
                var _x = newState.x,
                    _y = newState.y;

                // Add slack to the values used to calculate bound position. This will ensure that if
                // we start removing slack, the element won't react to it right away until it's been
                // completely removed.

                newState.x += _this.state.slackX;
                newState.y += _this.state.slackY;

                // Get bound position. This will ceil/floor the x and y within the boundaries.
                // $FlowBug

                // Recalculate slack by noting how much was shaved by the boundPosition handler.
                var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);

                var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);

                newState.x = _getBoundPosition2[0];
                newState.y = _getBoundPosition2[1];
                newState.slackX = _this.state.slackX + (_x - newState.x);
                newState.slackY = _this.state.slackY + (_y - newState.y);

                // Update the event we fire to reflect what really happened after bounds took effect.
                uiData.x = newState.x;
                uiData.y = newState.y;
                uiData.deltaX = newState.x - _this.state.x;
                uiData.deltaY = newState.y - _this.state.y;
              }

              // Short-circuit if user's callback killed it.
              var shouldUpdate = _this.props.onDrag(e, uiData);
              if (shouldUpdate === false) return false;

              _this.setState(newState);
            };

            _this.onDragStop = function (e, coreData) {
              if (!_this.state.dragging) return false;

              // Short-circuit if user's callback killed it.
              var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
              if (shouldStop === false) return false;

              (0, _log2.default)('Draggable: onDragStop: %j', coreData);

              var newState /*: $Shape<DraggableState>*/ = {
                dragging: false,
                slackX: 0,
                slackY: 0
              };

              // If this is a controlled component, the result of this operation will be to
              // revert back to the old position. We expect a handler on `onDragStop`, at the least.
              var controlled = Boolean(_this.props.position);
              if (controlled) {
                var _this$props$position = _this.props.position,
                    _x2 = _this$props$position.x,
                    _y2 = _this$props$position.y;

                newState.x = _x2;
                newState.y = _y2;
              }

              _this.setState(newState);
            };

            _this.state = {
              // Whether or not we are currently dragging.
              dragging: false,

              // Whether or not we have been dragged before.
              dragged: false,

              // Current transform x and y.
              x: props.position ? props.position.x : props.defaultPosition.x,
              y: props.position ? props.position.y : props.defaultPosition.y,

              // Used for compensating for out-of-bounds drags
              slackX: 0, slackY: 0,

              // Can only determine if SVG after mounting
              isElementSVG: false
            };
            return _this;
          }

          _createClass(Draggable, [{
            key: 'componentWillMount',
            value: function componentWillMount() {
              if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
                // eslint-disable-next-line
                console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
              }
            }
          }, {
            key: 'componentDidMount',
            value: function componentDidMount() {
              // Check to see if the element passed is an instanceof SVGElement
              if (typeof window.SVGElement !== 'undefined' && _reactDom2.default.findDOMNode(this) instanceof window.SVGElement) {
                this.setState({ isElementSVG: true });
              }
            }
          }, {
            key: 'componentWillReceiveProps',
            value: function componentWillReceiveProps(nextProps /*: Object*/) {
              // Set x/y if position has changed
              if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
                this.setState({ x: nextProps.position.x, y: nextProps.position.y });
              }
            }
          }, {
            key: 'componentWillUnmount',
            value: function componentWillUnmount() {
              this.setState({ dragging: false }); // prevents invariant if unmounted while dragging
            }
          }, {
            key: 'render',
            value: function render() /*: ReactElement<any>*/{
              var _classNames;

              var style = {},
                  svgTransform = null;

              // If this is controlled, we don't want to move it - unless it's dragging.
              var controlled = Boolean(this.props.position);
              var draggable = !controlled || this.state.dragging;

              var position = this.props.position || this.props.defaultPosition;
              var transformOpts = {
                // Set left if horizontal drag is enabled
                x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,

                // Set top if vertical drag is enabled
                y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
              };

              // If this element was SVG, we use the `transform` attribute.
              if (this.state.isElementSVG) {
                svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
              } else {
                // Add a CSS transform to move the element around. This allows us to move the element around
                // without worrying about whether or not it is relatively or absolutely positioned.
                // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
                // has a clean slate.
                style = (0, _domFns.createCSSTransform)(transformOpts);
              }

              var _props = this.props,
                  defaultClassName = _props.defaultClassName,
                  defaultClassNameDragging = _props.defaultClassNameDragging,
                  defaultClassNameDragged = _props.defaultClassNameDragged;

              // Mark with class while dragging

              var className = (0, _classnames2.default)(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));

              // Reuse the child provided
              // This makes it flexible to use whatever element is wanted (div, ul, etc)
              return _react2.default.createElement(_DraggableCore2.default, _extends$$1({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }), _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {
                className: className,
                style: _extends$$1({}, this.props.children.props.style, style),
                transform: svgTransform
              }));
            }
          }]);

          return Draggable;
        }(_react2.default.Component);

        Draggable.displayName = 'Draggable';
        Draggable.propTypes = _extends$$1({}, _DraggableCore2.default.propTypes, {

          /**
           * `axis` determines which axis the draggable can move.
           *
           *  Note that all callbacks will still return data as normal. This only
           *  controls flushing to the DOM.
           *
           * 'both' allows movement horizontally and vertically.
           * 'x' limits movement to horizontal axis.
           * 'y' limits movement to vertical axis.
           * 'none' limits all movement.
           *
           * Defaults to 'both'.
           */
          axis: _propTypes2.default.oneOf(['both', 'x', 'y', 'none']),

          /**
           * `bounds` determines the range of movement available to the element.
           * Available values are:
           *
           * 'parent' restricts movement within the Draggable's parent node.
           *
           * Alternatively, pass an object with the following properties, all of which are optional:
           *
           * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
           *
           * All values are in px.
           *
           * Example:
           *
           * ```jsx
           *   let App = React.createClass({
           *       render: function () {
           *         return (
           *            <Draggable bounds={{right: 300, bottom: 300}}>
           *              <div>Content</div>
           *           </Draggable>
           *         );
           *       }
           *   });
           * ```
           */
          bounds: _propTypes2.default.oneOfType([_propTypes2.default.shape({
            left: _propTypes2.default.number,
            right: _propTypes2.default.number,
            top: _propTypes2.default.number,
            bottom: _propTypes2.default.number
          }), _propTypes2.default.string, _propTypes2.default.oneOf([false])]),

          defaultClassName: _propTypes2.default.string,
          defaultClassNameDragging: _propTypes2.default.string,
          defaultClassNameDragged: _propTypes2.default.string,

          /**
           * `defaultPosition` specifies the x and y that the dragged item should start at
           *
           * Example:
           *
           * ```jsx
           *      let App = React.createClass({
           *          render: function () {
           *              return (
           *                  <Draggable defaultPosition={{x: 25, y: 25}}>
           *                      <div>I start with transformX: 25px and transformY: 25px;</div>
           *                  </Draggable>
           *              );
           *          }
           *      });
           * ```
           */
          defaultPosition: _propTypes2.default.shape({
            x: _propTypes2.default.number,
            y: _propTypes2.default.number
          }),

          /**
           * `position`, if present, defines the current position of the element.
           *
           *  This is similar to how form elements in React work - if no `position` is supplied, the component
           *  is uncontrolled.
           *
           * Example:
           *
           * ```jsx
           *      let App = React.createClass({
           *          render: function () {
           *              return (
           *                  <Draggable position={{x: 25, y: 25}}>
           *                      <div>I start with transformX: 25px and transformY: 25px;</div>
           *                  </Draggable>
           *              );
           *          }
           *      });
           * ```
           */
          position: _propTypes2.default.shape({
            x: _propTypes2.default.number,
            y: _propTypes2.default.number
          }),

          /**
           * These properties should be defined on the child, not here.
           */
          className: _shims.dontSetMe,
          style: _shims.dontSetMe,
          transform: _shims.dontSetMe
        });
        Draggable.defaultProps = _extends$$1({}, _DraggableCore2.default.defaultProps, {
          axis: 'both',
          bounds: false,
          defaultClassName: 'react-draggable',
          defaultClassNameDragging: 'react-draggable-dragging',
          defaultClassNameDragged: 'react-draggable-dragged',
          defaultPosition: { x: 0, y: 0 },
          position: null
        });
        exports.default = Draggable;

        /***/
      },
      /* 14 */
      /***/function (module, exports, __webpack_require__) {

        var emptyFunction = __webpack_require__(1);
        var invariant = __webpack_require__(2);
        var warning = __webpack_require__(8);

        var ReactPropTypesSecret = __webpack_require__(3);
        var checkPropTypes = __webpack_require__(15);

        module.exports = function (isValidElement, throwOnDirectAccess) {
          /* global Symbol */
          var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

          /**
           * Returns the iterator method function contained on the iterable object.
           *
           * Be sure to invoke the function with the iterable as context:
           *
           *     var iteratorFn = getIteratorFn(myIterable);
           *     if (iteratorFn) {
           *       var iterator = iteratorFn.call(myIterable);
           *       ...
           *     }
           *
           * @param {?object} maybeIterable
           * @return {?function}
           */
          function getIteratorFn(maybeIterable) {
            var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
            if (typeof iteratorFn === 'function') {
              return iteratorFn;
            }
          }

          /**
           * Collection of methods that allow declaration and validation of props that are
           * supplied to React components. Example usage:
           *
           *   var Props = require('ReactPropTypes');
           *   var MyArticle = React.createClass({
           *     propTypes: {
           *       // An optional string prop named "description".
           *       description: Props.string,
           *
           *       // A required enum prop named "category".
           *       category: Props.oneOf(['News','Photos']).isRequired,
           *
           *       // A prop named "dialog" that requires an instance of Dialog.
           *       dialog: Props.instanceOf(Dialog).isRequired
           *     },
           *     render: function() { ... }
           *   });
           *
           * A more formal specification of how these methods are used:
           *
           *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
           *   decl := ReactPropTypes.{type}(.isRequired)?
           *
           * Each and every declaration produces a function with the same signature. This
           * allows the creation of custom validation functions. For example:
           *
           *  var MyLink = React.createClass({
           *    propTypes: {
           *      // An optional string or URI prop named "href".
           *      href: function(props, propName, componentName) {
           *        var propValue = props[propName];
           *        if (propValue != null && typeof propValue !== 'string' &&
           *            !(propValue instanceof URI)) {
           *          return new Error(
           *            'Expected a string or an URI for ' + propName + ' in ' +
           *            componentName
           *          );
           *        }
           *      }
           *    },
           *    render: function() {...}
           *  });
           *
           * @internal
           */

          var ANONYMOUS = '<<anonymous>>';

          // Important!
          // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
          var ReactPropTypes = {
            array: createPrimitiveTypeChecker('array'),
            bool: createPrimitiveTypeChecker('boolean'),
            func: createPrimitiveTypeChecker('function'),
            number: createPrimitiveTypeChecker('number'),
            object: createPrimitiveTypeChecker('object'),
            string: createPrimitiveTypeChecker('string'),
            symbol: createPrimitiveTypeChecker('symbol'),

            any: createAnyTypeChecker(),
            arrayOf: createArrayOfTypeChecker,
            element: createElementTypeChecker(),
            instanceOf: createInstanceTypeChecker,
            node: createNodeChecker(),
            objectOf: createObjectOfTypeChecker,
            oneOf: createEnumTypeChecker,
            oneOfType: createUnionTypeChecker,
            shape: createShapeTypeChecker
          };

          /**
           * inlined Object.is polyfill to avoid requiring consumers ship their own
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
           */
          /*eslint-disable no-self-compare*/
          function is(x, y) {
            // SameValue algorithm
            if (x === y) {
              // Steps 1-5, 7-10
              // Steps 6.b-6.e: +0 != -0
              return x !== 0 || 1 / x === 1 / y;
            } else {
              // Step 6.a: NaN == NaN
              return x !== x && y !== y;
            }
          }
          /*eslint-enable no-self-compare*/

          /**
           * We use an Error-like object for backward compatibility as people may call
           * PropTypes directly and inspect their output. However, we don't use real
           * Errors anymore. We don't inspect their stack anyway, and creating them
           * is prohibitively expensive if they are created too often, such as what
           * happens in oneOfType() for any type before the one that matched.
           */
          function PropTypeError(message) {
            this.message = message;
            this.stack = '';
          }
          // Make `instanceof Error` still work for returned errors.
          PropTypeError.prototype = Error.prototype;

          function createChainableTypeChecker(validate) {
            if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
              var manualPropTypeCallCache = {};
              var manualPropTypeWarningCount = 0;
            }
            function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
              componentName = componentName || ANONYMOUS;
              propFullName = propFullName || propName;

              if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                  // New behavior only for users of `prop-types` package
                  invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                } else if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production' && typeof console !== 'undefined') {
                  // Old behavior for people using React.PropTypes
                  var cacheKey = componentName + ':' + propName;
                  if (!manualPropTypeCallCache[cacheKey] &&
                  // Avoid spamming the console because they are often not actionable except for lib authors
                  manualPropTypeWarningCount < 3) {
                    warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
                    manualPropTypeCallCache[cacheKey] = true;
                    manualPropTypeWarningCount++;
                  }
                }
              }
              if (props[propName] == null) {
                if (isRequired) {
                  if (props[propName] === null) {
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                  }
                  return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
              } else {
                return validate(props, propName, componentName, location, propFullName);
              }
            }

            var chainedCheckType = checkType.bind(null, false);
            chainedCheckType.isRequired = checkType.bind(null, true);

            return chainedCheckType;
          }

          function createPrimitiveTypeChecker(expectedType) {
            function validate(props, propName, componentName, location, propFullName, secret) {
              var propValue = props[propName];
              var propType = getPropType(propValue);
              if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);

                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createAnyTypeChecker() {
            return createChainableTypeChecker(emptyFunction.thatReturnsNull);
          }

          function createArrayOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location, propFullName) {
              if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
              }
              var propValue = props[propName];
              if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
              }
              for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createElementTypeChecker() {
            function validate(props, propName, componentName, location, propFullName) {
              var propValue = props[propName];
              if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createInstanceTypeChecker(expectedClass) {
            function validate(props, propName, componentName, location, propFullName) {
              if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createEnumTypeChecker(expectedValues) {
            if (!Array.isArray(expectedValues)) {
              Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
              return emptyFunction.thatReturnsNull;
            }

            function validate(props, propName, componentName, location, propFullName) {
              var propValue = props[propName];
              for (var i = 0; i < expectedValues.length; i++) {
                if (is(propValue, expectedValues[i])) {
                  return null;
                }
              }

              var valuesString = JSON.stringify(expectedValues);
              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
            }
            return createChainableTypeChecker(validate);
          }

          function createObjectOfTypeChecker(typeChecker) {
            function validate(props, propName, componentName, location, propFullName) {
              if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
              }
              var propValue = props[propName];
              var propType = getPropType(propValue);
              if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
              }
              for (var key in propValue) {
                if (propValue.hasOwnProperty(key)) {
                  var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                  if (error instanceof Error) {
                    return error;
                  }
                }
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createUnionTypeChecker(arrayOfTypeCheckers) {
            if (!Array.isArray(arrayOfTypeCheckers)) {
              Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
              return emptyFunction.thatReturnsNull;
            }

            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
              var checker = arrayOfTypeCheckers[i];
              if (typeof checker !== 'function') {
                warning(false, 'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
                return emptyFunction.thatReturnsNull;
              }
            }

            function validate(props, propName, componentName, location, propFullName) {
              for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];
                if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
                  return null;
                }
              }

              return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
            }
            return createChainableTypeChecker(validate);
          }

          function createNodeChecker() {
            function validate(props, propName, componentName, location, propFullName) {
              if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function createShapeTypeChecker(shapeTypes) {
            function validate(props, propName, componentName, location, propFullName) {
              var propValue = props[propName];
              var propType = getPropType(propValue);
              if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
              }
              for (var key in shapeTypes) {
                var checker = shapeTypes[key];
                if (!checker) {
                  continue;
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                  return error;
                }
              }
              return null;
            }
            return createChainableTypeChecker(validate);
          }

          function isNode(propValue) {
            switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
              case 'number':
              case 'string':
              case 'undefined':
                return true;
              case 'boolean':
                return !propValue;
              case 'object':
                if (Array.isArray(propValue)) {
                  return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                  return true;
                }

                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                  var iterator = iteratorFn.call(propValue);
                  var step;
                  if (iteratorFn !== propValue.entries) {
                    while (!(step = iterator.next()).done) {
                      if (!isNode(step.value)) {
                        return false;
                      }
                    }
                  } else {
                    // Iterator will provide entry [k,v] tuples rather than values.
                    while (!(step = iterator.next()).done) {
                      var entry = step.value;
                      if (entry) {
                        if (!isNode(entry[1])) {
                          return false;
                        }
                      }
                    }
                  }
                } else {
                  return false;
                }

                return true;
              default:
                return false;
            }
          }

          function isSymbol(propType, propValue) {
            // Native Symbol.
            if (propType === 'symbol') {
              return true;
            }

            // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
            if (propValue['@@toStringTag'] === 'Symbol') {
              return true;
            }

            // Fallback for non-spec compliant Symbols which are polyfilled.
            if (typeof Symbol === 'function' && propValue instanceof Symbol) {
              return true;
            }

            return false;
          }

          // Equivalent of `typeof` but with special handling for array and regexp.
          function getPropType(propValue) {
            var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
            if (Array.isArray(propValue)) {
              return 'array';
            }
            if (propValue instanceof RegExp) {
              // Old webkits (at least until Android 4.0) return 'function' rather than
              // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
              // passes PropTypes.object.
              return 'object';
            }
            if (isSymbol(propType, propValue)) {
              return 'symbol';
            }
            return propType;
          }

          // This handles more types than `getPropType`. Only used for error messages.
          // See `createPrimitiveTypeChecker`.
          function getPreciseType(propValue) {
            if (typeof propValue === 'undefined' || propValue === null) {
              return '' + propValue;
            }
            var propType = getPropType(propValue);
            if (propType === 'object') {
              if (propValue instanceof Date) {
                return 'date';
              } else if (propValue instanceof RegExp) {
                return 'regexp';
              }
            }
            return propType;
          }

          // Returns a string that is postfixed to a warning about an invalid type.
          // For example, "undefined" or "of type array"
          function getPostfixForTypeWarning(value) {
            var type = getPreciseType(value);
            switch (type) {
              case 'array':
              case 'object':
                return 'an ' + type;
              case 'boolean':
              case 'date':
              case 'regexp':
                return 'a ' + type;
              default:
                return type;
            }
          }

          // Returns class name of the object, if any.
          function getClassName(propValue) {
            if (!propValue.constructor || !propValue.constructor.name) {
              return ANONYMOUS;
            }
            return propValue.constructor.name;
          }

          ReactPropTypes.checkPropTypes = checkPropTypes;
          ReactPropTypes.PropTypes = ReactPropTypes;

          return ReactPropTypes;
        };

        /***/
      },
      /* 15 */
      /***/function (module, exports, __webpack_require__) {

        if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
          var invariant = __webpack_require__(2);
          var warning = __webpack_require__(8);
          var ReactPropTypesSecret = __webpack_require__(3);
          var loggedTypeFailures = {};
        }

        /**
         * Assert that the values match with the type specs.
         * Error messages are memorized and will only be shown once.
         *
         * @param {object} typeSpecs Map of name to a ReactPropType
         * @param {object} values Runtime values that need to be type-checked
         * @param {string} location e.g. "prop", "context", "child context"
         * @param {string} componentName Name of the component for error messages.
         * @param {?Function} getStack Returns the component stack.
         * @private
         */
        function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
          if (Object({ "DRAGGABLE_DEBUG": undefined }).NODE_ENV !== 'production') {
            for (var typeSpecName in typeSpecs) {
              if (typeSpecs.hasOwnProperty(typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                  // This is intentionally an invariant that gets caught. It's the same
                  // behavior as without this statement except with a better message.
                  invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
                  error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                  error = ex;
                }
                warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                  // Only monitor this failure once because there tends to be a lot of the
                  // same error.
                  loggedTypeFailures[error.message] = true;

                  var stack = getStack ? getStack() : '';

                  warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
                }
              }
            }
          }
        }

        module.exports = checkPropTypes;

        /***/
      },
      /* 16 */
      /***/function (module, exports, __webpack_require__) {

        var emptyFunction = __webpack_require__(1);
        var invariant = __webpack_require__(2);
        var ReactPropTypesSecret = __webpack_require__(3);

        module.exports = function () {
          function shim(props, propName, componentName, location, propFullName, secret) {
            if (secret === ReactPropTypesSecret) {
              // It is still safe when called from React.
              return;
            }
            invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
          }
          shim.isRequired = shim;
          function getShim() {
            return shim;
          }
          // Important!
          // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
          var ReactPropTypes = {
            array: shim,
            bool: shim,
            func: shim,
            number: shim,
            object: shim,
            string: shim,
            symbol: shim,

            any: shim,
            arrayOf: getShim,
            element: shim,
            instanceOf: getShim,
            node: shim,
            objectOf: getShim,
            oneOf: getShim,
            oneOfType: getShim,
            shape: getShim
          };

          ReactPropTypes.checkPropTypes = emptyFunction;
          ReactPropTypes.PropTypes = ReactPropTypes;

          return ReactPropTypes;
        };

        /***/
      },
      /* 17 */
      /***/function (module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /*!
                                                                         Copyright (c) 2016 Jed Watson.
                                                                         Licensed under the MIT License (MIT), see
                                                                         http://jedwatson.github.io/classnames
                                                                         */
        /* global define */

        (function () {
          var hasOwn = {}.hasOwnProperty;

          function classNames() {
            var classes = [];

            for (var i = 0; i < arguments.length; i++) {
              var arg = arguments[i];
              if (!arg) continue;

              var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);

              if (argType === 'string' || argType === 'number') {
                classes.push(arg);
              } else if (Array.isArray(arg)) {
                classes.push(classNames.apply(null, arg));
              } else if (argType === 'object') {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              }
            }

            return classes.join(' ');
          }

          if (typeof module !== 'undefined' && module.exports) {
            module.exports = classNames;
          } else {
            // register as 'classnames', consistent with npm package name
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
              return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          }
        })();

        /***/
      },
      /* 18 */
      /***/function (module, exports, __webpack_require__) {

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getPrefix = getPrefix;
        exports.browserPrefixToKey = browserPrefixToKey;
        exports.browserPrefixToStyle = browserPrefixToStyle;
        var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
        function getPrefix() /*: string*/{
          var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';

          // Checking specifically for 'window.document' is for pseudo-browser server-side
          // environments that define 'window' as the global context.
          // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
          if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';

          var style = window.document.documentElement.style;

          if (prop in style) return '';

          for (var i = 0; i < prefixes.length; i++) {
            if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
          }

          return '';
        }

        function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/{
          return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
        }

        function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/{
          return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
        }

        function kebabToTitleCase(str /*: string*/) /*: string*/{
          var out = '';
          var shouldCapitalize = true;
          for (var i = 0; i < str.length; i++) {
            if (shouldCapitalize) {
              out += str[i].toUpperCase();
              shouldCapitalize = false;
            } else if (str[i] === '-') {
              shouldCapitalize = true;
            } else {
              out += str[i];
            }
          }
          return out;
        }

        // Default export is the prefix itself, like 'Moz', 'Webkit', etc
        // Note that you may have to re-test for certain things; for instance, Chrome 50
        // can handle unprefixed `transform`, but not unprefixed `user-select`
        exports.default = getPrefix();

        /***/
      },
      /* 19 */
      /***/function (module, exports) {

        // shim for using process in browser
        var process = module.exports = {};

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error('setTimeout has not been defined');
        }
        function defaultClearTimeout() {
          throw new Error('clearTimeout has not been defined');
        }
        (function () {
          try {
            if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function (fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function () {
          this.fun.apply(null, this.array);
        };
        process.title = 'browser';
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ''; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function (name) {
          return [];
        };

        process.binding = function (name) {
          throw new Error('process.binding is not supported');
        };

        process.cwd = function () {
          return '/';
        };
        process.chdir = function (dir) {
          throw new Error('process.chdir is not supported');
        };
        process.umask = function () {
          return 0;
        };

        /***/
      }]
      /******/)
    );
  });
  
});

unwrapExports(reactDraggable);

var Handle_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Handle = function (_React$Component) {
    _inherits(Handle, _React$Component);

    function Handle() {
      _classCallCheck(this, Handle);

      return _possibleConstructorReturn(this, (Handle.__proto__ || Object.getPrototypeOf(Handle)).apply(this, arguments));
    }

    _createClass(Handle, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            _props$x = _props.x,
            x = _props$x === undefined ? 0 : _props$x,
            _props$y = _props.y,
            y = _props$y === undefined ? 0 : _props$y,
            _props$r = _props.r,
            r = _props$r === undefined ? 10 : _props$r,
            handleStart = _props.handleStart,
            handleDrag = _props.handleDrag,
            handleStop = _props.handleStop,
            offsetParent = _props.offsetParent;

        return _react2.default.createElement(reactDraggable.DraggableCore, {
          handle: ".handle",
          defaultPosition: { x: 0, y: 0 },
          position: null,
          onStart: handleStart,
          onDrag: handleDrag,
          onStop: handleStop,
          offsetParent: offsetParent,
          defaultClassNameDragging: "dragging"
        }, _react2.default.createElement("circle", {
          className: "handle",
          cx: x,
          cy: y,
          r: r,
          strokeDasharray: "5",
          stroke: "grey",
          fill: "white",
          fillOpacity: 0
        }));
      }
    }]);

    return Handle;
  }(_react2.default.Component);

  exports.default = Handle;

  Handle.propTypes = {
    x: _propTypes2.default.number,
    y: _propTypes2.default.number,
    r: _propTypes2.default.number,
    handleStart: _propTypes2.default.func,
    handleStop: _propTypes2.default.func,
    handleDrag: _propTypes2.default.func
  };
});

unwrapExports(Handle_1);

var Subject_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _Handle2 = _interopRequireDefault(Handle_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Subject = function (_React$Component) {
    _inherits(Subject, _React$Component);

    function Subject() {
      _classCallCheck(this, Subject);

      return _possibleConstructorReturn(this, (Subject.__proto__ || Object.getPrototypeOf(Subject)).apply(this, arguments));
    }

    _createClass(Subject, [{
      key: "getComponents",
      value: function getComponents() {}
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            editMode = _props.editMode,
            color = _props.color;

        var d = this.getComponents(this.props) || {};

        var handles = void 0;
        if (editMode) {
          handles = [_react2.default.createElement(_Handle2.default, {
            key: "subject-handle",
            handleStart: this.props.dragStart,
            handleStop: this.props.dragEnd,
            handleDrag: this.props.dragSubject
          })];

          if (d.handles) {
            handles = handles.concat(d.handles.map(function (h, i) {
              return _react2.default.createElement(_Handle2.default, {
                key: "subjecthandle-" + i,
                handleStart: _this2.props.dragStart,
                handleStop: _this2.props.dragEnd,
                x: h.x,
                y: h.y,
                offsetParent: h.offsetParent && _this2.subject,
                handleDrag: function handleDrag(e, data) {
                  _this2.props.dragSubjectSettings(e, d.handleFunction(h, data));
                }
              });
            }));
          }
        }

        return _react2.default.createElement("g", _extends$$1({
          className: "annotation-subject"
        }, this.props.gAttrs, {
          ref: function ref(subject) {
            _this2.subject = subject;
          }
        }), d.components && d.components.map(function (c, i) {
          var attrs = {};
          if (!c) return null;
          Object.keys(c.attrs).forEach(function (k) {
            if (c.attrs[k] && k !== "text") {
              attrs[k.replace(/-([a-z])/g, function (g) {
                return g[1].toUpperCase();
              })] = c.attrs[k];
            }
          });
          return _react2.default.createElement(c.type, _extends$$1({
            key: i,
            className: c.className,
            fill: "none",
            stroke: color
          }, attrs), c.attrs.text);
        }), handles);
      }
    }]);

    return Subject;
  }(_react2.default.Component);

  exports.default = Subject;
});

unwrapExports(Subject_1);

var badge = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var _ref$radius = _ref.radius,
        radius = _ref$radius === undefined ? 14 : _ref$radius,
        leftRight = _ref.leftRight,
        topBottom = _ref.topBottom,
        text = _ref.text,
        color = _ref.color,
        editMode = _ref.editMode;

    var handles = [];
    var components = [];

    var innerRadius = radius * 0.7;
    var x = 0;
    var y = 0;

    var notCornerOffset = Math.sqrt(2) * radius;
    var placement = {
      xleftcorner: -radius,
      xrightcorner: radius,
      ytopcorner: -radius,
      ybottomcorner: radius,
      xleft: -notCornerOffset,
      xright: notCornerOffset,
      ytop: -notCornerOffset,
      ybottom: notCornerOffset
    };

    if (leftRight && !topBottom) {
      x = placement["x" + leftRight];
    } else if (topBottom && !leftRight) {
      y = placement["y" + topBottom];
    } else if (leftRight && topBottom) {
      x = placement["x" + leftRight + "corner"];
      y = placement["y" + topBottom + "corner"];
    }

    var transform = "translate(" + x + ", " + y + ")";
    var circlebg = (0, Builder.arcBuilder)({ className: "subject", data: { radius: radius } });
    circlebg.attrs.transform = transform;
    circlebg.attrs.fill = color;
    circlebg.attrs["stroke-linecap"] = "round";
    circlebg.attrs["stroke-width"] = "3px";

    var circle = (0, Builder.arcBuilder)({
      className: "subject-ring",
      data: { outerRadius: radius, innerRadius: innerRadius }
    });

    circle.attrs.transform = transform;
    circle.attrs["stroke-width"] = "3px";
    circle.attrs.fill = "white";

    var pointer = void 0;
    if (x && y || !x && !y) {
      pointer = (0, Builder.lineBuilder)({
        className: "subject-pointer",
        data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
      });
    } else if (x || y) {
      var notCornerPointerXY = function notCornerPointerXY(v) {
        var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
      };

      pointer = (0, Builder.lineBuilder)({
        className: "subject-pointer",
        data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
      });
    }

    if (pointer) {
      pointer.attrs.fill = color;
      pointer.attrs["stroke-linecap"] = "round";
      pointer.attrs["stroke-width"] = "3px";
      components.push(pointer);
    }

    if (editMode) {
      var bHandles = {
        x: x * 2,
        y: y * 2,
        offsetParent: true
      };
      if (!bHandles.x && !bHandles.y) {
        bHandles.y = -radius;
      }

      handles = [bHandles];
    }

    var textNode = void 0;
    if (text) {
      textNode = {
        type: "text",
        className: "badge-text",
        attrs: {
          fill: "white",
          stroke: "none",
          "font-size": ".7em",
          text: text,
          "text-anchor": "middle",
          dy: ".25em",
          x: x,
          y: y
        }
      };
    }

    components.push(circlebg);
    components.push(circle);
    components.push(textNode);

    return { components: components, handles: handles };
  };
});

unwrapExports(badge);

var SubjectBadge_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _badge2 = _interopRequireDefault(badge);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var SubjectBadge = function (_Subject$$1) {
    _inherits(SubjectBadge, _Subject$$1);

    function SubjectBadge() {
      _classCallCheck(this, SubjectBadge);

      return _possibleConstructorReturn(this, (SubjectBadge.__proto__ || Object.getPrototypeOf(SubjectBadge)).apply(this, arguments));
    }

    _createClass(SubjectBadge, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var leftRight = _ref.leftRight,
            topBottom = _ref.topBottom,
            text = _ref.text,
            editMode = _ref.editMode,
            color = _ref.color,
            radius = _ref.radius;

        var components = (0, _badge2.default)({
          leftRight: leftRight,
          topBottom: topBottom,
          text: text,
          editMode: editMode,
          color: color,
          radius: radius
        });

        components.handleKeys = { leftRight: leftRight, topBottom: topBottom };
        components.handleFunction = function (h, data) {
          var lr = data.x < -radius * 2 ? "left" : data.x > radius * 2 ? "right" : undefined;
          var tb = data.y < -radius * 2 ? "top" : data.y > radius * 2 ? "bottom" : undefined;

          return {
            leftRight: lr,
            topBottom: tb
          };
        };

        return components;
      }
    }]);

    return SubjectBadge;
  }(_Subject3.default);

  exports.default = SubjectBadge;

  SubjectBadge.propTypes = {
    leftRight: _propTypes2.default.oneOf(["left", "right"]),
    topBottom: _propTypes2.default.oneOf(["top", "bottom"]),
    text: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    color: _propTypes2.default.string,
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectBadge_1);

var circle$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.circleHandles = undefined;

  var circleHandles = exports.circleHandles = function circleHandles(_ref) {
    var _ref$cx = _ref.cx,
        cx = _ref$cx === undefined ? 0 : _ref$cx,
        _ref$cy = _ref.cy,
        cy = _ref$cy === undefined ? 0 : _ref$cy,
        r1 = _ref.r1,
        r2 = _ref.r2,
        padding = _ref.padding;

    var h = { move: { x: cx, y: cy } };

    if (r1 !== undefined) {
      h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
    }

    if (r2 !== undefined) {
      h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
    }

    if (padding !== undefined) {
      h.padding = { x: cx + r1 + padding, y: cy };
    }

    return h;
  };

  exports.default = function (_ref2) {
    var radius = _ref2.radius,
        radiusPadding = _ref2.radiusPadding,
        outerRadius = _ref2.outerRadius,
        innerRadius = _ref2.innerRadius,
        editMode = _ref2.editMode;

    var handles = [];
    var c = (0, Builder.arcBuilder)({
      data: { radius: radius, outerRadius: outerRadius, innerRadius: innerRadius },
      className: "subject"
    });

    if (editMode) {
      var h = circleHandles({
        r1: c.data.outerRadius || c.data.radius,
        r2: c.data.innerRadius,
        padding: radiusPadding
      });

      var cHandles = [{
        x: h.r1.x,
        y: h.r1.y,
        key: c.data.outerRadius ? "outerRadius" : "radius"
      }];

      if (innerRadius) {
        cHandles.push({ x: h.r2.x, y: h.r2.y, key: "innerRadius" });
      }
      handles = cHandles;
    }

    c.attrs["fill-opacity"] = 0;

    return { components: [c], handles: handles };
  };
});

unwrapExports(circle$1);
var circle_1 = circle$1.circleHandles;

var SubjectCircle_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _circle2 = _interopRequireDefault(circle$1);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var SubjectCircle = function (_Subject) {
    _inherits(SubjectCircle, _Subject);

    function SubjectCircle() {
      _classCallCheck(this, SubjectCircle);

      return _possibleConstructorReturn(this, (SubjectCircle.__proto__ || Object.getPrototypeOf(SubjectCircle)).apply(this, arguments));
    }

    _createClass(SubjectCircle, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var _ref$radius = _ref.radius,
            radius = _ref$radius === undefined ? 20 : _ref$radius,
            innerRadius = _ref.innerRadius,
            outerRadius = _ref.outerRadius,
            radiusPadding = _ref.radiusPadding,
            editMode = _ref.editMode;

        var components = (0, _circle2.default)({
          radius: radius,
          radiusPadding: radiusPadding,
          innerRadius: innerRadius,
          outerRadius: outerRadius,
          editMode: editMode
        });

        components.handleKeys = { radius: radius, innerRadius: innerRadius, outerRadius: outerRadius };
        components.handleFunction = function (h, data) {
          return _defineProperty({}, h.key, components.handleKeys[h.key] + data.deltaX * Math.sqrt(2));
        };
        return components;
      }
    }]);

    return SubjectCircle;
  }(_Subject3.default);

  exports.default = SubjectCircle;

  SubjectCircle.propTypes = {
    radius: _propTypes2.default.number,
    innerRadius: _propTypes2.default.number,
    outerRadius: _propTypes2.default.number,
    radiusPadding: _propTypes2.default.number,
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectCircle_1);

var rect = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var _ref$width = _ref.width,
        width = _ref$width === undefined ? 100 : _ref$width,
        _ref$height = _ref.height,
        height = _ref$height === undefined ? 100 : _ref$height,
        editMode = _ref.editMode;

    var handles = [];

    var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
    var rect = (0, Builder.lineBuilder)({ data: data, className: "subject" });

    if (editMode) {
      handles = [{ x: width, y: height / 2, key: "width" }, { x: width / 2, y: height, key: "height" }];
    }
    rect.attrs["fill-opacity"] = 0.1;
    return { components: [rect], handles: handles };
  };
});

unwrapExports(rect);

var SubjectRect_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _rect2 = _interopRequireDefault(rect);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var SubjectRect = function (_Subject) {
    _inherits(SubjectRect, _Subject);

    function SubjectRect() {
      _classCallCheck(this, SubjectRect);

      return _possibleConstructorReturn(this, (SubjectRect.__proto__ || Object.getPrototypeOf(SubjectRect)).apply(this, arguments));
    }

    _createClass(SubjectRect, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var _ref$width = _ref.width,
            width = _ref$width === undefined ? 100 : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === undefined ? 100 : _ref$height,
            editMode = _ref.editMode;

        var components = (0, _rect2.default)({ width: width, height: height, editMode: editMode });
        components.handleKeys = { width: width, height: height };

        components.handleFunction = function (h, data) {
          return _defineProperty({}, h.key, h.key === "width" ? width + data.deltaX : height + data.deltaY);
        };

        return components;
      }
    }]);

    return SubjectRect;
  }(_Subject3.default);

  exports.default = SubjectRect;

  SubjectRect.propTypes = {
    width: _propTypes2.default.number,
    height: _propTypes2.default.number,
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectRect_1);

var threshold = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var x1 = _ref.x1,
        x2 = _ref.x2,
        y1 = _ref.y1,
        y2 = _ref.y2,
        x = _ref.x,
        y = _ref.y;

    x1 = (x1 !== undefined ? x1 : x) - x;
    x2 = (x2 !== undefined ? x2 : x) - x;
    y1 = (y1 !== undefined ? y1 : y) - y;
    y2 = (y2 !== undefined ? y2 : y) - y;

    var data = [[x1, y1], [x2, y2]];
    return { components: [(0, Builder.lineBuilder)({ data: data, className: "subject" })] };
  };
});

unwrapExports(threshold);

var SubjectThreshold_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _threshold2 = _interopRequireDefault(threshold);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var SubjectThreshold = function (_Subject) {
    _inherits(SubjectThreshold, _Subject);

    function SubjectThreshold() {
      _classCallCheck(this, SubjectThreshold);

      return _possibleConstructorReturn(this, (SubjectThreshold.__proto__ || Object.getPrototypeOf(SubjectThreshold)).apply(this, arguments));
    }

    _createClass(SubjectThreshold, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var x1 = _ref.x1,
            x2 = _ref.x2,
            y1 = _ref.y1,
            y2 = _ref.y2,
            x = _ref.x,
            y = _ref.y,
            editMode = _ref.editMode;

        return (0, _threshold2.default)({ x1: x1, x2: x2, y1: y1, y2: y2, x: x, y: y, editMode: editMode });
      }
    }]);

    return SubjectThreshold;
  }(_Subject3.default);

  exports.default = SubjectThreshold;

  SubjectThreshold.propTypes = {
    x: _propTypes2.default.number,
    x1: _propTypes2.default.number,
    x2: _propTypes2.default.number,
    y: _propTypes2.default.number,
    y1: _propTypes2.default.number,
    y2: _propTypes2.default.number,
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectThreshold_1);

var bracket = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  //This curly brace function was
  //made by Alex Hornbake
  //http://bl.ocks.org/alexhornbake/6005176
  function makeCurlyBrace(x1, y1, x2, y2, w, q) {
    //Calculate unit vector
    var dx = x1 - x2;
    var dy = y1 - y2;
    var len = Math.sqrt(dx * dx + dy * dy);
    dx = dx / len;
    dy = dy / len;

    //Calculate Control Points of path,
    var qx1 = x1 + q * w * dy;
    var qy1 = y1 - q * w * dx;
    var qx2 = x1 - 0.25 * len * dx + (1 - q) * w * dy;
    var qy2 = y1 - 0.25 * len * dy - (1 - q) * w * dx;
    var tx1 = x1 - 0.5 * len * dx + w * dy;
    var ty1 = y1 - 0.5 * len * dy - w * dx;
    var qx3 = x2 + q * w * dy;
    var qy3 = y2 - q * w * dx;
    var qx4 = x1 - 0.75 * len * dx + (1 - q) * w * dy;
    var qy4 = y1 - 0.75 * len * dy - (1 - q) * w * dx;

    return "M " + x1 + " " + y1 + " Q " + qx1 + " " + qy1 + " " + qx2 + " " + qy2 + " T " + tx1 + " " + ty1 + " M " + x2 + " " + y2 + " Q " + qx3 + " " + qy3 + " " + qx4 + " " + qy4 + " T " + tx1 + " " + ty1;
  }

  exports.default = function (_ref) {
    var height = _ref.height,
        width = _ref.width,
        depth = _ref.depth,
        type = _ref.type,
        editMode = _ref.editMode;

    var handles = [];
    var data = void 0;
    var bracket = void 0;
    if (type === "square") {
      if (height) {
        data = [[0, 0], [depth, 0], [depth, height], [0, height]];
      } else if (width) {
        data = [[0, 0], [0, depth], [width, depth], [width, 0]];
      }
      bracket = (0, Builder.lineBuilder)({ data: data, className: "subject" });
    } else if (type === "curly") {
      bracket = (0, Builder.pathBuilder)({
        d: makeCurlyBrace(0, 0, width || 0, height || 0, height && height > 0 || width && width < 0 ? -depth : depth, 0.55),
        className: "subject"
      });
    }

    if (editMode) {
      handles = [{
        x: height ? depth : width / 2,
        y: height ? height / 2 : depth,
        key: "depth",
        type: height ? "X" : "Y"
      }, {
        x: width || 0,
        y: height || 0,
        key: height ? "height" : "width"
      }];
    }

    bracket.attrs["fill-opacity"] = 0.1;
    return { components: [bracket], handles: handles };
  };
});

unwrapExports(bracket);

var SubjectBracket_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _bracket2 = _interopRequireDefault(bracket);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  var SubjectBracket = function (_Subject) {
    _inherits(SubjectBracket, _Subject);

    function SubjectBracket() {
      _classCallCheck(this, SubjectBracket);

      return _possibleConstructorReturn(this, (SubjectBracket.__proto__ || Object.getPrototypeOf(SubjectBracket)).apply(this, arguments));
    }

    _createClass(SubjectBracket, [{
      key: "getComponents",
      value: function getComponents(_ref) {
        var height = _ref.height,
            width = _ref.width,
            _ref$depth = _ref.depth,
            depth = _ref$depth === undefined ? 20 : _ref$depth,
            _ref$type = _ref.type,
            type = _ref$type === undefined ? "square" : _ref$type,
            editMode = _ref.editMode;

        var components = (0, _bracket2.default)({ height: height, width: width, depth: depth, type: type, editMode: editMode });

        var handleKeys = { height: height, width: width, depth: depth };
        components.handleFunction = function (h, data) {
          if (h.key === "depth") {
            return {
              depth: depth + data["delta" + h.type]
            };
          } else {
            return _defineProperty({}, h.key, handleKeys[h.key] + data[h.key === "width" ? "deltaX" : "deltaY"]);
          }
        };

        return components;
      }
    }]);

    return SubjectBracket;
  }(_Subject3.default);

  exports.default = SubjectBracket;

  SubjectBracket.propTypes = {
    width: _propTypes2.default.number,
    height: _propTypes2.default.number,
    depth: _propTypes2.default.number,
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectBracket_1);

var SubjectCustom_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _Subject3 = _interopRequireDefault(Subject_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  var _Handle2 = _interopRequireDefault(Handle_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */
  // import Bracket from "./bracket"


  var SubjectCustom = function (_Subject) {
    _inherits(SubjectCustom, _Subject);

    function SubjectCustom() {
      _classCallCheck(this, SubjectCustom);

      return _possibleConstructorReturn(this, (SubjectCustom.__proto__ || Object.getPrototypeOf(SubjectCustom)).apply(this, arguments));
    }

    _createClass(SubjectCustom, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            _props$custom = _props.custom,
            custom = _props$custom === undefined ? "M0,0" : _props$custom,
            customID = _props.customID,
            editMode = _props.editMode,
            transform = _props.transform;

        var handles = void 0;
        if (editMode) {
          handles = _react2.default.createElement(_Handle2.default, {
            handleStart: this.props.onDragStart,
            handleStop: this.props.onDragEnd,
            handleDrag: this.props.dragSubject
          });
        }

        return _react2.default.createElement("g", { className: "annotation-subject" }, _react2.default.createElement("g", { transform: transform }, typeof custom === "string" ? _react2.default.createElement("path", { d: custom, pointerEvents: "none" }) : _react2.default.createElement("g", { pointerEvents: "none" }, custom), _react2.default.createElement("mask", { id: customID, pointerEvents: "none" }, _react2.default.createElement("g", { transform: transform }, _react2.default.createElement("rect", {
          x: "-100%",
          y: "-100%",
          height: "200%",
          width: "200%",
          fill: "white",
          pointerEvents: "none"
        }), typeof custom === "string" ? _react2.default.createElement("path", { d: custom, fill: "black", pointerEvents: "none" }) : _react2.default.createElement("g", { fill: "black", pointerEvents: "none" }, custom.map(function (c, i) {
          return _react2.default.cloneElement(c, Object.assign({}, c.props, {
            fill: "black",
            opacity: 1,
            key: "customSubject-" + i
          }));
        })), "}"))), handles);
      }
    }]);

    return SubjectCustom;
  }(_Subject3.default);

  exports.default = SubjectCustom;

  SubjectCustom.propTypes = {
    editMode: _propTypes2.default.bool
  };
});

unwrapExports(SubjectCustom_1);

var alignment = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var leftRightDynamic = exports.leftRightDynamic = function leftRightDynamic(align, y) {
    if (!align || align === "dynamic" || align === "left" || align === "right") {
      if (y < 0) {
        align = "top";
      } else {
        align = "bottom";
      }
    }
    return align;
  };

  var topBottomDynamic = exports.topBottomDynamic = function topBottomDynamic(align, x) {
    if (!align || align === "dynamic" || align === "top" || align === "bottom") {
      if (x < 0) {
        align = "right";
      } else {
        align = "left";
      }
    }
    return align;
  };

  var orientationTopBottom = ["topBottom", "top", "bottom"];
  var orientationLeftRight = ["leftRight", "left", "right"];

  exports.default = function (_ref) {
    var _ref$padding = _ref.padding,
        padding = _ref$padding === undefined ? 0 : _ref$padding,
        _ref$bbox = _ref.bbox,
        bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox,
        align = _ref.align,
        orientation = _ref.orientation,
        _ref$offset = _ref.offset,
        offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;

    var x = -bbox.x;
    var y = -bbox.y;
    if (orientationTopBottom.indexOf(orientation) !== -1) {
      align = topBottomDynamic(align, offset.x);
      if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
        y -= bbox.height + padding;
      } else {
        y += padding;
      }

      if (align === "middle") {
        x -= bbox.width / 2;
      } else if (align === "right") {
        x -= bbox.width;
      }
    } else if (orientationLeftRight.indexOf(orientation) !== -1) {
      align = leftRightDynamic(align, offset.y);
      if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
        x -= bbox.width + padding;
      } else {
        x += padding;
      }

      if (align === "middle") {
        y -= bbox.height / 2;
      } else if (align === "top") {
        y -= bbox.height;
      }
    }

    return { x: x, y: y };
  };
});

unwrapExports(alignment);
var alignment_1 = alignment.leftRightDynamic;
var alignment_2 = alignment.topBottomDynamic;

var lineTypeVertical = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var align = _ref.align,
        _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        bbox = _ref.bbox,
        offset = _ref.offset;

    align = (0, alignment.leftRightDynamic)(align, offset.y);

    if (align === "top") {
      y -= bbox.height;
    } else if (align === "middle") {
      y -= bbox.height / 2;
    }

    var data = [[x, y], [x, y + bbox.height]];
    return { components: [(0, Builder.lineBuilder)({ data: data, className: "note-line" })] };
  };
});

unwrapExports(lineTypeVertical);

var lineTypeHorizontal = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (_ref) {
    var align = _ref.align,
        _ref$x = _ref.x,
        x = _ref$x === undefined ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === undefined ? 0 : _ref$y,
        offset = _ref.offset,
        bbox = _ref.bbox;

    align = (0, alignment.topBottomDynamic)(align, offset.x);

    if (align === "right") {
      x -= bbox.width;
    } else if (align === "middle") {
      x -= bbox.width / 2;
    }

    var data = [[x, y], [x + bbox.width, y]];
    return { components: [(0, Builder.lineBuilder)({ data: data, className: "note-line" })] };
  };
});

unwrapExports(lineTypeHorizontal);

var Note_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _alignment5 = _interopRequireDefault(alignment);

  var _Handle2 = _interopRequireDefault(Handle_1);

  var _lineTypeVertical2 = _interopRequireDefault(lineTypeVertical);

  var _lineTypeHorizontal2 = _interopRequireDefault(lineTypeHorizontal);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var getOuterBBox = function getOuterBBox() {
    for (var _len = arguments.length, domNodes = Array(_len), _key = 0; _key < _len; _key++) {
      domNodes[_key] = arguments[_key];
    }

    return [].concat(domNodes).reduce(function (p, c) {
      if (c) {
        var bbox = c.getBBox();
        p.x = Math.min(p.x, bbox.x);
        p.y = Math.min(p.y, bbox.y);
        p.width = Math.max(p.width, bbox.width);

        var yOffset = c && c.attributes && c.attributes.y;
        p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
      }
      return p;
    }, { x: 0, y: 0, width: 0, height: 0 });
  };

  var Note = function (_React$Component) {
    _inherits(Note, _React$Component);

    function Note(props) {
      _classCallCheck(this, Note);

      var _this = _possibleConstructorReturn(this, (Note.__proto__ || Object.getPrototypeOf(Note)).call(this, props));

      _this.state = {
        translateX: 0,
        translateY: 0,
        labelOffset: 0,
        changed: 0,
        bbox: { width: 0, height: 0, x: 0, y: 0 }
      };

      _this.updateText = _this.updateText.bind(_this);
      return _this;
    }

    _createClass(Note, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateText(this.props);
      }
    }, {
      key: "componentWillReceiveProps",
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.title !== this.props.title || nextProps.label !== this.props.label || nextProps.wrap !== this.props.wrap) {
          this.updateText(nextProps);
        }
        if (nextProps.editMode && (nextProps.align === "dynamic" || !nextProps.align)) {
          this.updateText(nextProps);
        }
      }
    }, {
      key: "updateText",
      value: function updateText(_ref) {
        var _this2 = this;

        var orientation = _ref.orientation,
            padding = _ref.padding,
            align = _ref.align,
            lineType = _ref.lineType,
            label = _ref.label,
            title = _ref.title,
            wrap = _ref.wrap,
            wrapSplitter = _ref.wrapSplitter,
            dx = _ref.dx,
            dy = _ref.dy;

        var newState = {
          titleWrapped: null,
          labelWrapped: null
        };
        newState.changed = this.state.changed + 1;

        if (title) {
          newState.titleWrapped = this.refs.title && this.wrapText(this.refs.title, newState.changed, title, wrap, wrapSplitter);
        }
        if (label) newState.labelWrapped = this.refs.label && this.wrapText(this.refs.label, newState.changed, label, wrap, wrapSplitter);

        this.setState(newState, function () {
          var setLabel = function setLabel() {
            var bbox = getOuterBBox(_this2.refs.title, _this2.refs.label);
            var noteParams = {
              padding: padding,
              bbox: bbox,
              offset: { x: dx, y: dy },
              orientation: orientation,
              align: align
            };
            if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

            var _alignment$$1 = (0, _alignment5.default)(noteParams),
                x = _alignment$$1.x,
                y = _alignment$$1.y;

            _this2.setState({
              translateX: x,
              translateY: y,
              bbox: bbox
            });
          };

          _this2.setState({
            labelOffset: title && _this2.refs.title.getBBox().height || 0
          }, setLabel);
        });
      }
    }, {
      key: "wrapText",
      value: function wrapText(textRef, key, text, width, wrapSplitter) {
        var initialAttrs = {
          x: 0,
          dy: "1.2em"
        };

        var words = text.split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
          return w !== "";
        });

        var word = void 0,
            line = [];

        var tspans = [];

        while (word = words.pop()) {
          line.push(word);
          textRef.lastChild.textContent = line.join(" ");

          var length = textRef.lastChild.getComputedTextLength();

          textRef.lastChild.textContent = "";

          if (length > width && line.length > 1) {
            line.pop();
            tspans.push(_react2.default.createElement("tspan", _extends$$1({ key: tspans.length + text }, initialAttrs), line.join(" ")));
            line = [word];
          }
        }

        if (line.length !== 0) {
          tspans.push(_react2.default.createElement("tspan", _extends$$1({ key: tspans.length + text }, initialAttrs), line.join(" ")));
        }

        return _react2.default.createElement("tspan", _extends$$1({}, initialAttrs, { key: key + text }), tspans);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _props = this.props,
            orientation = _props.orientation,
            padding = _props.padding,
            align = _props.align,
            dx = _props.dx,
            dy = _props.dy,
            lineType = _props.lineType;

        if (this.state.bbox.width && (prevProps.dx !== this.props.dx || prevProps.dy !== this.props.dy) && (this.refs.title || this.refs.label)) {
          var bbox = getOuterBBox(this.refs.title, this.refs.label);
          var noteParams = {
            padding: padding,
            bbox: bbox,
            offset: { x: dx, y: dy },
            orientation: orientation,
            align: align
          };

          if (lineType === "vertical") noteParams.orientation = "leftRight";else if (lineType === "horizontal") noteParams.orientation = "topBottom";

          var _alignment2 = (0, _alignment5.default)(noteParams),
              x = _alignment2.x,
              y = _alignment2.y;

          var updates = { bbox: bbox };
          if (this.state.translateX !== x) updates.translateX = x;
          if (this.state.translateY !== y) updates.translateY = y;
          if (updates.translateX !== undefined || updates.translateY !== undefined) {
            this.setState(updates);
          }
        } else if (this.state.align !== prevProps.align || this.props.orientation !== prevProps.orientation || this.props.padding !== prevProps.padding) {
          var _noteParams = {
            padding: padding,
            bbox: this.state.bbox,
            offset: { x: dx, y: dy },
            orientation: orientation,
            align: align
          };

          if (lineType === "vertical") _noteParams.orientation = "leftRight";else if (lineType === "horizontal") _noteParams.orientation = "topBottom";

          var _alignment3 = (0, _alignment5.default)(_noteParams),
              _x = _alignment3.x,
              _y = _alignment3.y;

          var _updates = {};
          if (this.state.translateX !== _x) _updates.translateX = _x;
          if (this.state.translateY !== _y) _updates.translateY = _y;
          if (_updates.translateX !== undefined || _updates.translateY !== undefined) {
            this.setState(_updates);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _props2 = this.props,
            dx = _props2.dx,
            dy = _props2.dy,
            title = _props2.title,
            label = _props2.label,
            align = _props2.align,
            editMode = _props2.editMode,
            lineType = _props2.lineType,
            color = _props2.color,
            titleColor = _props2.titleColor,
            labelColor = _props2.labelColor;

        var noteTitle = void 0,
            noteText = void 0,
            noteLineType = void 0;
        if (title) {
          noteTitle = _react2.default.createElement("text", {
            ref: "title",
            className: "annotation-note-title",
            fontWeight: "bold",
            key: "title",
            fill: titleColor || color
          }, this.state.titleWrapped || _react2.default.createElement("tspan", { x: 0, dy: ".8em" }, title));
        }

        if (label) {
          noteText = _react2.default.createElement("text", {
            ref: "label",
            className: "annotation-note-label",
            y: this.state.labelOffset * 1.1,
            key: "label",
            fill: labelColor || color
          }, this.state.labelWrapped || _react2.default.createElement("tspan", { x: 0, dy: ".8em" }, label));
        }

        if (lineType && this.state.bbox.width) {
          var noteParams = {
            bbox: this.state.bbox,
            align: align,
            offset: { x: dx, y: dy }
          };

          var noteComponent = (lineType === "vertical" && (0, _lineTypeVertical2.default)(noteParams) || lineType === "horizontal" && (0, _lineTypeHorizontal2.default)(noteParams)).components[0];

          noteLineType = _react2.default.createElement(noteComponent.type, _extends$$1({
            className: noteComponent.className
          }, noteComponent.attrs, {
            stroke: color
          }));
        }

        var handle = void 0;

        if (editMode) {
          handle = _react2.default.createElement(_Handle2.default, {
            handleStart: this.props.dragStart,
            handleStop: this.props.dragEnd,
            handleDrag: this.props.dragNote
          });
        }

        return _react2.default.createElement("g", _extends$$1({
          transform: "translate(" + dx + ", " + dy + ")",
          className: "annotation-note"
        }, this.props.gProps), _react2.default.createElement("g", {
          className: "annotation-note-content",
          transform: "translate(" + this.state.translateX + ",\n          " + this.state.translateY + ")",
          ref: "note"
        }, _react2.default.createElement("rect", {
          className: "annotation-note-bg",
          width: this.state.bbox.width,
          height: this.state.bbox.height,
          stroke: "none",
          fill: "white",
          fillOpacity: "0"
        }), noteTitle, noteText), noteLineType, handle);
      }
    }]);

    return Note;
  }(_react2.default.Component);

  exports.default = Note;

  Note.defaultProps = {
    wrap: 120,
    align: "dynamic",
    orientation: "topBottom",
    padding: 3
  };

  Note.propTypes = {
    dx: _propTypes2.default.number,
    dy: _propTypes2.default.number,
    title: _propTypes2.default.string,
    label: _propTypes2.default.string,
    orientation: _propTypes2.default.oneOf(["leftRight", "topBottom"]),
    padding: _propTypes2.default.number,
    align: _propTypes2.default.oneOf(["left", "right", "middle", "top", "bottom", "dynamic"]),
    editMode: _propTypes2.default.bool,
    lineType: _propTypes2.default.oneOf(["vertical", "horizontal"]),
    color: _propTypes2.default.string,
    titleColor: _propTypes2.default.string,
    labelColor: _propTypes2.default.string
  };
});

unwrapExports(Note_1);

var BracketNote_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.default = BracketNote;

  var _react2 = _interopRequireDefault(React);

  var _Note2 = _interopRequireDefault(Note_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _objectWithoutProperties(obj, keys) {
    var target = {};for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
    }return target;
  } /* eslint-disable no-unused-vars */

  /* eslint-enable no-unused-vars */

  function BracketNote(_ref) {
    var width = _ref.width,
        height = _ref.height,
        depth = _ref.depth,
        rest = _objectWithoutProperties(_ref, ["width", "height", "depth"]);

    var dx = rest.dx,
        orientation = void 0,
        align = "middle",
        dy = rest.dy;

    if (height) {
      if (!dy) dy = height / 2;
      if (!dx) dx = depth;
      orientation = "leftRight";
    } else if (width) {
      if (!dx) dx = width / 2;
      if (!dy) dy = depth;
      orientation = "topBottom";
    }

    return _react2.default.createElement(_Note2.default, _extends({
      align: align,
      orientation: orientation,
      padding: 10
    }, rest, {
      editMode: false,
      dx: dx,
      dy: dy
    }));
  }
});

unwrapExports(BracketNote_1);

var classnames = createCommonjsModule(function (module) {
	/*!
   Copyright (c) 2016 Jed Watson.
   Licensed under the MIT License (MIT), see
   http://jedwatson.github.io/classnames
 */
	/* global define */

	(function () {
		var hasOwn = {}.hasOwnProperty;

		function classNames() {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if ('object' !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (typeof undefined === 'function' && _typeof(undefined.amd) === 'object' && undefined.amd) {
			// register as 'classnames', consistent with npm package name
			undefined('classnames', [], function () {
				return classNames;
			});
		} else {
			window.classNames = classNames;
		}
	})();
});

var Annotation_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _classnames2 = _interopRequireDefault(classnames);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Annotation = function (_React$Component) {
    _inherits(Annotation, _React$Component);

    function Annotation() {
      _classCallCheck(this, Annotation);

      return _possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).apply(this, arguments));
    }

    _createClass(Annotation, [{
      key: "render",
      value: function render() {
        var _props = this.props,
            x = _props.x,
            y = _props.y,
            nx = _props.nx,
            ny = _props.ny,
            events = _props.events;

        var cleanedProps = Object.assign({}, this.props);
        delete cleanedProps.children;

        if (nx !== undefined) cleanedProps.dx = nx - x;
        if (ny !== undefined) cleanedProps.dy = ny - y;

        var childrenWithProps = _react2.default.Children.toArray(this.props.children).map(function (child) {
          return _react2.default.cloneElement(child, _extends$$1({}, cleanedProps, child.props));
        });
        return _react2.default.createElement("g", _extends$$1({
          className: (0, _classnames2.default)("annotation", this.props.className),
          transform: "translate(" + x + ", " + y + ")"
        }, events), childrenWithProps);
      }
    }]);

    return Annotation;
  }(_react2.default.Component);

  exports.default = Annotation;

  Annotation.defaultProps = {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    color: "grey"
  };

  Annotation.propTypes = {
    x: _propTypes2.default.number,
    y: _propTypes2.default.number,
    dx: _propTypes2.default.number,
    dy: _propTypes2.default.number,
    color: _propTypes2.default.string,
    editMode: _propTypes2.default.bool,
    events: _propTypes2.default.object
  };
});

unwrapExports(Annotation_1);

var EditableAnnotation_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _Annotation2 = _interopRequireDefault(Annotation_1);

  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var EditableAnnotation = function (_React$Component) {
    _inherits(EditableAnnotation, _React$Component);

    function EditableAnnotation() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, EditableAnnotation);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = EditableAnnotation.__proto__ || Object.getPrototypeOf(EditableAnnotation)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        x: 0,
        y: 0,
        dx: 0,
        dy: 0
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(EditableAnnotation, [{
      key: "componentWillMount",
      value: function componentWillMount() {
        this.setState({
          x: this.props.x,
          y: this.props.y,
          dx: this.props.dx,
          dy: this.props.dy
        });
      }
    }, {
      key: "getData",
      value: function getData() {
        return Object.assign({}, this.props, this.state);
      }
    }, {
      key: "dragEnd",
      value: function dragEnd() {
        if (this.props.onDragEnd) {
          this.props.onDragEnd(this.getData());
        }
      }
    }, {
      key: "dragStart",
      value: function dragStart() {
        if (this.props.onDragStart) {
          this.props.onDragStart(this.getData());
        }
      }
    }, {
      key: "dragSubject",
      value: function dragSubject(event, data) {
        var _this2 = this;

        this.setState({
          x: this.state.x + data.deltaX,
          y: this.state.y + data.deltaY
        }, function () {
          if (_this2.props.onDrag) _this2.props.onDrag(_this2.getData());
        });
      }
    }, {
      key: "dragSubjectSettings",
      value: function dragSubjectSettings(event, data) {
        var _this3 = this;

        this.setState(data, function () {
          if (_this3.props.onDrag) _this3.props.onDrag(_this3.getData());
        });
      }
    }, {
      key: "dragNote",
      value: function dragNote(event, data) {
        var _this4 = this;

        this.setState({
          dx: this.state.dx + data.deltaX,
          dy: this.state.dy + data.deltaY
        }, function () {
          if (_this4.props.onDrag) _this4.props.onDrag(_this4.getData());
        });
      }
    }, {
      key: "render",
      value: function render() {
        var cleanedProps = Object.assign({}, this.props, _extends$$1({}, this.state, {
          dragSubject: this.dragSubject.bind(this),
          dragNote: this.dragNote.bind(this),
          dragSubjectSettings: this.dragSubjectSettings.bind(this),
          dragEnd: this.dragEnd.bind(this),
          dragStart: this.dragStart.bind(this),
          editMode: true,
          className: (0, _classnames2.default)(this.props.className, "editable")
        }));

        return _react2.default.createElement(_Annotation2.default, cleanedProps);
      }
    }]);

    return EditableAnnotation;
  }(_react2.default.Component);

  exports.default = EditableAnnotation;
});

unwrapExports(EditableAnnotation_1);

var Types = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.AnnotationLabel = AnnotationLabel;
  exports.AnnotationCallout = AnnotationCallout;
  exports.AnnotationCalloutElbow = AnnotationCalloutElbow;
  exports.AnnotationCalloutCurve = AnnotationCalloutCurve;
  exports.AnnotationCalloutCircle = AnnotationCalloutCircle;
  exports.AnnotationCalloutRect = AnnotationCalloutRect;
  exports.AnnotationXYThreshold = AnnotationXYThreshold;
  exports.AnnotationBadge = AnnotationBadge;
  exports.AnnotationBracket = AnnotationBracket;
  exports.AnnotationCalloutCustom = AnnotationCalloutCustom;

  var _react2 = _interopRequireDefault(React);

  var _Annotation2 = _interopRequireDefault(Annotation_1);

  var _EditableAnnotation2 = _interopRequireDefault(EditableAnnotation_1);

  var _ConnectorLine2 = _interopRequireDefault(ConnectorLine_1);

  var _ConnectorElbow2 = _interopRequireDefault(ConnectorElbow_1);

  var _ConnectorCurve2 = _interopRequireDefault(ConnectorCurve_1);

  var _ConnectorEndDot2 = _interopRequireDefault(ConnectorEndDot_1);

  var _ConnectorEndArrow2 = _interopRequireDefault(ConnectorEndArrow_1);

  var _Subject2 = _interopRequireDefault(Subject_1);

  var _SubjectCircle2 = _interopRequireDefault(SubjectCircle_1);

  var _SubjectBadge2 = _interopRequireDefault(SubjectBadge_1);

  var _SubjectBracket2 = _interopRequireDefault(SubjectBracket_1);

  var _BracketNote2 = _interopRequireDefault(BracketNote_1);

  var _SubjectRect2 = _interopRequireDefault(SubjectRect_1);

  var _SubjectThreshold2 = _interopRequireDefault(SubjectThreshold_1);

  var _SubjectCustom2 = _interopRequireDefault(SubjectCustom_1);

  var _Note2 = _interopRequireDefault(Note_1);

  var _classnames2 = _interopRequireDefault(classnames);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  var getAnnotationType = function getAnnotationType(editMode) {
    return editMode ? _EditableAnnotation2.default : _Annotation2.default;
  };

  var annotationMapper = function annotationMapper(props, Connector) {
    var NoteDefaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var Subject = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _Subject2.default;
    var SubjectDefaultProps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    var NoteType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _Note2.default;
    var _props$disable = props.disable,
        disable = _props$disable === undefined ? [] : _props$disable,
        connector = props.connector,
        note = props.note,
        subject = props.subject,
        x = props.x,
        y = props.y,
        dx = props.dx,
        dy = props.dy,
        nx = props.nx,
        ny = props.ny,
        color = props.color,
        className = props.className,
        onDrag = props.onDrag,
        onDragStart = props.onDragStart,
        onDragEnd = props.onDragEnd,
        editMode = props.editMode,
        events = props.events;

    var CONNECTORS = {
      type: {
        curve: _ConnectorCurve2.default,
        line: _ConnectorLine2.default,
        elbow: _ConnectorElbow2.default
      },
      end: {
        dot: _ConnectorEndDot2.default,
        arrow: _ConnectorEndArrow2.default
      }
    };

    var ConnectorType = void 0,
        ConnectorEndType = void 0;
    if (disable.indexOf("connector") === -1) {
      ConnectorType = connector && CONNECTORS.type[connector.type] || Connector;
      ConnectorEndType = connector && CONNECTORS.end[connector.end];
    }

    var AnnotationType = getAnnotationType(props.editMode);
    return _react2.default.createElement(AnnotationType, _extends({
      x: x,
      y: y,
      dx: dx,
      dy: dy,
      nx: nx,
      ny: ny,
      color: color,
      className: className,
      onDrag: onDrag,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd,
      editMode: editMode
    }, SubjectDefaultProps, subject, {
      events: events
    }), ConnectorType && _react2.default.createElement(ConnectorType, connector, ConnectorEndType && _react2.default.createElement(ConnectorEndType, null)), Subject && disable.indexOf("subject") === -1 && _react2.default.createElement(Subject, null), note && disable.indexOf("note") === -1 && _react2.default.createElement(NoteType, _extends({}, NoteDefaultProps, note)));
  };

  function AnnotationLabel(props) {
    var className = (0, _classnames2.default)("label", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorLine2.default, {
      align: "middle"
    });
  }

  function AnnotationCallout(props) {
    var className = (0, _classnames2.default)("callout", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorLine2.default, {
      lineType: "horizontal"
    });
  }

  function AnnotationCalloutElbow(props) {
    var className = (0, _classnames2.default)("callout elbow", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorElbow2.default, {
      lineType: "horizontal"
    });
  }

  function AnnotationCalloutCurve(props) {
    var className = (0, _classnames2.default)("callout curve", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorCurve2.default, {
      lineType: "horizontal"
    });
  }

  function AnnotationCalloutCircle(props) {
    var className = (0, _classnames2.default)("callout circle", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorElbow2.default, { lineType: "horizontal" }, _SubjectCircle2.default, { radius: 20 });
  }

  function AnnotationCalloutRect(props) {
    var className = (0, _classnames2.default)("callout rect", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorElbow2.default, { lineType: "horizontal" }, _SubjectRect2.default, { width: 100, height: 100 });
  }

  function AnnotationXYThreshold(props) {
    var className = (0, _classnames2.default)("callout xythreshold", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorElbow2.default, { lineType: "horizontal" }, _SubjectThreshold2.default);
  }

  function AnnotationBadge(props) {
    var className = (0, _classnames2.default)("badge", props.className);
    return annotationMapper(_extends({ disable: ["connector", "note"] }, props, { className: className }), null, null, _SubjectBadge2.default);
  }

  function AnnotationBracket(props) {
    var className = (0, _classnames2.default)("bracket", props.className);
    return annotationMapper(_extends({ disable: ["connector"] }, props, { className: className }), null, null, _SubjectBracket2.default, { depth: 20 }, _BracketNote2.default);
  }

  function AnnotationCalloutCustom(props) {
    var className = (0, _classnames2.default)("callout custom", props.className);
    return annotationMapper(_extends({}, props, { className: className }), _ConnectorElbow2.default, { lineType: "horizontal" }, _SubjectCustom2.default);
  }
});

unwrapExports(Types);
var Types_1 = Types.AnnotationLabel;
var Types_2 = Types.AnnotationCallout;
var Types_3 = Types.AnnotationCalloutElbow;
var Types_4 = Types.AnnotationCalloutCurve;
var Types_5 = Types.AnnotationCalloutCircle;
var Types_6 = Types.AnnotationCalloutRect;
var Types_7 = Types.AnnotationXYThreshold;
var Types_8 = Types.AnnotationBadge;
var Types_9 = Types.AnnotationBracket;
var Types_10 = Types.AnnotationCalloutCustom;

var lib = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnnotationCalloutCustom = exports.AnnotationBracket = exports.AnnotationBadge = exports.AnnotationXYThreshold = exports.AnnotationCalloutRect = exports.AnnotationCalloutElbow = exports.AnnotationCalloutCurve = exports.AnnotationCalloutCircle = exports.AnnotationCallout = exports.AnnotationLabel = exports.EditableAnnotation = exports.Annotation = exports.BracketNote = exports.Note = exports.SubjectCustom = exports.SubjectBracket = exports.SubjectThreshold = exports.SubjectRect = exports.SubjectCircle = exports.SubjectBadge = exports.Subject = exports.ConnectorEndArrow = exports.ConnectorEndDot = exports.ConnectorLine = exports.ConnectorElbow = exports.ConnectorCurve = exports.Connector = undefined;

  var _Connector2$$1 = _interopRequireDefault(Connector_1);

  var _ConnectorCurve2 = _interopRequireDefault(ConnectorCurve_1);

  var _ConnectorElbow2 = _interopRequireDefault(ConnectorElbow_1);

  var _ConnectorLine2 = _interopRequireDefault(ConnectorLine_1);

  var _ConnectorEndDot2 = _interopRequireDefault(ConnectorEndDot_1);

  var _ConnectorEndArrow2 = _interopRequireDefault(ConnectorEndArrow_1);

  var _Subject2 = _interopRequireDefault(Subject_1);

  var _SubjectBadge2 = _interopRequireDefault(SubjectBadge_1);

  var _SubjectCircle2 = _interopRequireDefault(SubjectCircle_1);

  var _SubjectRect2 = _interopRequireDefault(SubjectRect_1);

  var _SubjectThreshold2 = _interopRequireDefault(SubjectThreshold_1);

  var _SubjectBracket2 = _interopRequireDefault(SubjectBracket_1);

  var _SubjectCustom2 = _interopRequireDefault(SubjectCustom_1);

  var _Note2 = _interopRequireDefault(Note_1);

  var _BracketNote2 = _interopRequireDefault(BracketNote_1);

  var _Annotation2 = _interopRequireDefault(Annotation_1);

  var _EditableAnnotation2 = _interopRequireDefault(EditableAnnotation_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  // export individual components
  exports.Connector = _Connector2$$1.default;
  exports.ConnectorCurve = _ConnectorCurve2.default;
  exports.ConnectorElbow = _ConnectorElbow2.default;
  exports.ConnectorLine = _ConnectorLine2.default;
  exports.ConnectorEndDot = _ConnectorEndDot2.default;
  exports.ConnectorEndArrow = _ConnectorEndArrow2.default;
  exports.Subject = _Subject2.default;
  exports.SubjectBadge = _SubjectBadge2.default;
  exports.SubjectCircle = _SubjectCircle2.default;
  exports.SubjectRect = _SubjectRect2.default;
  exports.SubjectThreshold = _SubjectThreshold2.default;
  exports.SubjectBracket = _SubjectBracket2.default;
  exports.SubjectCustom = _SubjectCustom2.default;
  exports.Note = _Note2.default;
  exports.BracketNote = _BracketNote2.default;
  exports.Annotation = _Annotation2.default;
  exports.EditableAnnotation = _EditableAnnotation2.default;
  exports.AnnotationLabel = Types.AnnotationLabel;
  exports.AnnotationCallout = Types.AnnotationCallout;
  exports.AnnotationCalloutCircle = Types.AnnotationCalloutCircle;
  exports.AnnotationCalloutCurve = Types.AnnotationCalloutCurve;
  exports.AnnotationCalloutElbow = Types.AnnotationCalloutElbow;
  exports.AnnotationCalloutRect = Types.AnnotationCalloutRect;
  exports.AnnotationXYThreshold = Types.AnnotationXYThreshold;
  exports.AnnotationBadge = Types.AnnotationBadge;
  exports.AnnotationBracket = Types.AnnotationBracket;
  exports.AnnotationCalloutCustom = Types.AnnotationCalloutCustom;
  exports.default = {
    Connector: _Connector2$$1.default,
    ConnectorCurve: _ConnectorCurve2.default,
    ConnectorElbow: _ConnectorElbow2.default,
    ConnectorLine: _ConnectorLine2.default,
    ConnectorEndDot: _ConnectorEndDot2.default,
    ConnectorEndArrow: _ConnectorEndArrow2.default,
    Subject: _Subject2.default,
    SubjectBadge: _SubjectBadge2.default,
    SubjectCircle: _SubjectCircle2.default,
    SubjectRect: _SubjectRect2.default,
    SubjectThreshold: _SubjectThreshold2.default,
    SubjectBracket: _SubjectBracket2.default,
    SubjectCustom: _SubjectCustom2.default,
    Note: _Note2.default,
    BracketNote: _BracketNote2.default,
    Annotation: _Annotation2.default,
    EditableAnnotation: _EditableAnnotation2.default,
    AnnotationLabel: Types.AnnotationLabel,
    AnnotationCallout: Types.AnnotationCallout,
    AnnotationCalloutCircle: Types.AnnotationCalloutCircle,
    AnnotationCalloutCurve: Types.AnnotationCalloutCurve,
    AnnotationCalloutElbow: Types.AnnotationCalloutElbow,
    AnnotationCalloutRect: Types.AnnotationCalloutRect,
    AnnotationXYThreshold: Types.AnnotationXYThreshold,
    AnnotationBadge: Types.AnnotationBadge,
    AnnotationBracket: Types.AnnotationBracket,
    AnnotationCalloutCustom: Types.AnnotationCalloutCustom
  };
});

unwrapExports(lib);
var lib_1 = lib.AnnotationCalloutCustom;
var lib_2 = lib.AnnotationBracket;
var lib_3 = lib.AnnotationBadge;
var lib_4 = lib.AnnotationXYThreshold;
var lib_5 = lib.AnnotationCalloutRect;
var lib_6 = lib.AnnotationCalloutElbow;
var lib_7 = lib.AnnotationCalloutCurve;
var lib_8 = lib.AnnotationCalloutCircle;
var lib_9 = lib.AnnotationCallout;
var lib_10 = lib.AnnotationLabel;
var lib_11 = lib.EditableAnnotation;
var lib_12 = lib.Annotation;
var lib_13 = lib.BracketNote;
var lib_14 = lib.Note;
var lib_15 = lib.SubjectCustom;
var lib_16 = lib.SubjectBracket;
var lib_17 = lib.SubjectThreshold;
var lib_18 = lib.SubjectRect;
var lib_19 = lib.SubjectCircle;
var lib_20 = lib.SubjectBadge;
var lib_21 = lib.Subject;
var lib_22 = lib.ConnectorEndArrow;
var lib_23 = lib.ConnectorEndDot;
var lib_24 = lib.ConnectorLine;
var lib_25 = lib.ConnectorElbow;
var lib_26 = lib.ConnectorCurve;
var lib_27 = lib.Connector;

var SemioticAnnotation = function (_React$Component) {
  inherits(SemioticAnnotation, _React$Component);

  function SemioticAnnotation() {
    classCallCheck(this, SemioticAnnotation);
    return possibleConstructorReturn(this, (SemioticAnnotation.__proto__ || Object.getPrototypeOf(SemioticAnnotation)).apply(this, arguments));
  }

  createClass(SemioticAnnotation, [{
    key: "render",
    value: function render() {
      var noteData = this.props.noteData;
      var screenCoordinates = noteData.screenCoordinates;


      noteData.type = typeof noteData.type === "function" ? noteData.type : lib_10;

      var eventListeners = noteData.eventListeners || {};

      if (noteData.coordinates && screenCoordinates) {
        //Multisubject annotation
        var setNX = noteData.nx || screenCoordinates[0][0] + noteData.dx;
        var setNY = noteData.ny || screenCoordinates[0][1] + noteData.dy;
        var notes = screenCoordinates.map(function (d, i) {
          var subjectNote = Object.assign({}, noteData, {
            note: i === 0 ? noteData.note : { label: "" },
            x: d[0],
            y: d[1],
            nx: setNX,
            ny: setNY
          });

          return React.createElement(noteData.type, _extends({ key: "multi-annotation-" + i }, subjectNote));
        });

        return React.createElement(
          "g",
          { events: eventListeners },
          notes
        );
      }

      return React.createElement(noteData.type, _extends({ events: eventListeners }, noteData));
    }
  }]);
  return SemioticAnnotation;
}(React.Component);

SemioticAnnotation.propTypes = {
  noteData: propTypes.object
};

var labella_min = createCommonjsModule(function (module, exports) {
  !function (t, e) {
    module.exports = e();
  }(commonjsGlobal, function () {
    return function (t) {
      function e(n) {
        if (r[n]) return r[n].exports;var i = r[n] = { exports: {}, id: n, loaded: !1 };return t[n].call(i.exports, i, i.exports, e), i.loaded = !0, i.exports;
      }var r = {};return e.m = t, e.c = r, e.p = "", e(0);
    }([function (t, e, r) {
      t.exports = { Node: r(1), Force: r(2), Distributor: r(3), Renderer: r(10) };
    }, function (t, e) {
      function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
      }var n = function () {
        function t(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);
          }
        }return function (e, r, n) {
          return r && t(e.prototype, r), n && t(e, n), e;
        };
      }(),
          i = function () {
        function t(e, n, i) {
          r(this, t), this.idealPos = e, this.currentPos = e, this.width = n, this.data = i, this.layerIndex = 0;
        }return n(t, [{ key: "distanceFrom", value: function value(t) {
            var e = this.width / 2,
                r = t.width / 2;return Math.max(this.currentPos - e, t.currentPos - r) - Math.min(this.currentPos + e, t.currentPos + r);
          } }, { key: "moveToIdealPosition", value: function value() {
            return this.currentPos = this.idealPos, this;
          } }, { key: "displacement", value: function value() {
            return this.idealPos - this.currentPos;
          } }, { key: "overlapWithNode", value: function value(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;return this.distanceFrom(t) - e < 0;
          } }, { key: "overlapWithPoint", value: function value(t) {
            var e = this.width / 2;return t >= this.currentPos - e && t <= this.currentPos + e;
          } }, { key: "positionBefore", value: function value(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;return t.currentLeft() - this.width / 2 - e;
          } }, { key: "positionAfter", value: function value(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;return t.currentRight() + this.width / 2 + e;
          } }, { key: "currentRight", value: function value() {
            return this.currentPos + this.width / 2;
          } }, { key: "currentLeft", value: function value() {
            return this.currentPos - this.width / 2;
          } }, { key: "idealRight", value: function value() {
            return this.idealPos + this.width / 2;
          } }, { key: "idealLeft", value: function value() {
            return this.idealPos - this.width / 2;
          } }, { key: "createStub", value: function value(e) {
            var r = new t(this.idealPos, e, this.data);return r.currentPos = this.currentPos, r.child = this, this.parent = r, r;
          } }, { key: "removeStub", value: function value() {
            return this.parent && (this.parent.child = null, this.parent = null), this;
          } }, { key: "isStub", value: function value() {
            return !!this.child;
          } }, { key: "getPathToRoot", value: function value() {
            for (var t = [], e = this; e;) {
              t.push(e), e = e.parent;
            }return t;
          } }, { key: "getPathFromRoot", value: function value() {
            return this.getPathToRoot().reverse();
          } }, { key: "getPathToRootLength", value: function value() {
            for (var t = 0, e = this; e;) {
              var r = e.parent ? e.parent.currentPos : e.idealPos;t += Math.abs(e.currentPos - r), e = e.parent;
            }return t;
          } }, { key: "getRoot", value: function value() {
            for (var t = this, e = this; e;) {
              t = e, e = e.parent;
            }return t;
          } }, { key: "getLayerIndex", value: function value() {
            return this.layerIndex;
          } }, { key: "clone", value: function value() {
            var e = new t(this.idealPos, this.width, this.data);return e.currentPos = this.currentPos, e.layerIndex = this.layerIndex, e;
          } }]), t;
      }();t.exports = i;
    }, function (t, e, r) {
      var n = r(3),
          i = r(4),
          o = r(8),
          s = { nodeSpacing: 3, minPos: 0, maxPos: null, algorithm: "overlap", removeOverlap: !0, density: .85, stubWidth: 1 },
          u = function u(t) {
        var e = {},
            r = i.extend({}, s),
            u = new n(),
            a = [],
            c = null;return e.nodes = function (t) {
          return arguments.length ? (a = t, c = [t.concat()], e) : a;
        }, e.getLayers = function () {
          return c;
        }, e.options = function (t) {
          if (!arguments.length) return r;r = i.extend(r, t);var o = i.pick(r, Object.keys(n.DEFAULT_OPTIONS));return i.isDefined(r.minPos) && i.isDefined(r.maxPos) ? o.layerWidth = r.maxPos - r.minPos : o.layerWidth = null, u.options(o), e;
        }, e.options(t), e.compute = function () {
          var t = i.pick(r, Object.keys(o.DEFAULT_OPTIONS));return a.forEach(function (t) {
            t.removeStub();
          }), c = u.distribute(a), c.map(function (e, n) {
            e.forEach(function (t) {
              t.layerIndex = n;
            }), r.removeOverlap && o(e, t);
          }), e;
        }, e.start = function () {
          console.log("[warning] force.start() is deprecated. Please use force.compute() instead.");
        }, e;
      };u.DEFAULT_OPTIONS = s, t.exports = u;
    }, function (t, e, r) {
      var n = r(4),
          i = r(6),
          o = { algorithm: "overlap", layerWidth: 1e3, density: .75, nodeSpacing: 3, stubWidth: 1 },
          s = function s(t) {
        var e = {};t = n.extend({}, o, t), e.options = function (r) {
          return arguments.length ? (t = n.extend(t, r), e) : t;
        }, e.computeRequiredWidth = function (e) {
          return n.sum(e, function (e) {
            return e.width + t.nodeSpacing;
          }) - t.nodeSpacing;
        }, e.maxWidthPerLayer = function () {
          return t.density * t.layerWidth;
        }, e.needToSplit = function (t) {
          return e.estimateRequiredLayers(t) > 1;
        }, e.estimateRequiredLayers = function (r) {
          return t.layerWidth ? Math.ceil(e.computeRequiredWidth(r) / e.maxWidthPerLayer()) : 1;
        };var r = { simple: function simple(r) {
            for (var n = e.estimateRequiredLayers(r), i = [], o = 0; o < n; o++) {
              i.push([]);
            }return r.forEach(function (e, r) {
              var o = r % n;i[o].push(e);for (var s = e, u = o - 1; u >= 0; u--) {
                s = s.createStub(t.stubWidth), i[u].push(s);
              }
            }), i;
          }, roundRobin: function roundRobin(t) {
            var e = [];return e;
          }, overlap: function overlap(r) {
            for (var n = [], i = e.maxWidthPerLayer(), o = r.concat(), s = e.computeRequiredWidth(o); s > i;) {
              e.countIdealOverlaps(o);var u = o.concat(),
                  a = s;for (o = []; u.length > 2 && a > i;) {
                u.sort(function (t, e) {
                  return e.overlapCount - t.overlapCount;
                });var c = u.shift();a -= c.width, a += t.stubWidth, c.overlaps.forEach(function (t) {
                  t.overlapCount--;
                }), o.push(c);
              }n.push(u), s = e.computeRequiredWidth(o);
            }o.length > 0 && n.push(o);for (var h = n.length - 1; h >= 1; h--) {
              for (var l = n[h], f = 0; f < l.length; f++) {
                var p = l[f];if (!p.isStub()) for (var d = p, v = h - 1; v >= 0; v--) {
                  d = d.createStub(t.stubWidth), n[v].push(d);
                }
              }
            }return n;
          } };return e.countIdealOverlaps = function (e) {
          var r = new i(t.layerWidth / 2);return e.forEach(function (t) {
            r.add([t.idealLeft(), t.idealRight(), t]);
          }), e.forEach(function (t) {
            var e = r.search(t.idealLeft(), t.idealRight());t.overlaps = e.map(function (t) {
              return t.data[2];
            }), t.overlapCount = e.length;
          }), e;
        }, e.distribute = function (i) {
          if (!i || 0 === i.length) return [];if ("none" == t.algorithm || !n.isDefined(t.algorithm)) return [i];if (!e.needToSplit(i)) return [i];var o = i.concat().sort(function (t, e) {
            return t.idealPos - e.idealPos;
          });if ("function" == typeof t.algorithm) return t.algorithm(o, t);if (r.hasOwnProperty(t.algorithm)) return r[t.algorithm](o);throw "Unknown algorithm: " + t.algorithm;
        }, e;
      };s.DEFAULT_OPTIONS = o, t.exports = s;
    }, function (t, e, r) {
      var n = { isDefined: function isDefined(t) {
          return null !== t && void 0 !== t;
        }, last: function last(t) {
          return t.length > 0 ? t[t.length - 1] : null;
        }, pick: function pick(t, e) {
          return e.reduce(function (e, r) {
            return e[r] = t[r], e;
          }, {});
        }, sum: function sum(t, e) {
          return t.map(e).reduce(function (t, e) {
            return t + e;
          }, 0);
        } };n.extend = r(5), t.exports = n;
    }, function (t, e) {
      var r = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
        return typeof t === 'undefined' ? 'undefined' : _typeof(t);
      } : function (t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t === 'undefined' ? 'undefined' : _typeof(t);
      },
          n = Object.prototype.hasOwnProperty,
          i = Object.prototype.toString,
          o = function o(t) {
        return "function" == typeof Array.isArray ? Array.isArray(t) : "[object Array]" === i.call(t);
      },
          s = function s(t) {
        if (!t || "[object Object]" !== i.call(t)) return !1;var e = n.call(t, "constructor"),
            r = t.constructor && t.constructor.prototype && n.call(t.constructor.prototype, "isPrototypeOf");if (t.constructor && !e && !r) return !1;var o;for (o in t) {}return void 0 === o || n.call(t, o);
      };t.exports = function u() {
        var t,
            e,
            n,
            i,
            a,
            c,
            h = arguments[0],
            l = 1,
            f = arguments.length,
            p = !1;for ("boolean" == typeof h ? (p = h, h = arguments[1] || {}, l = 2) : ("object" !== ("undefined" == typeof h ? "undefined" : r(h)) && "function" != typeof h || null == h) && (h = {}); l < f; ++l) {
          if (t = arguments[l], null != t) for (e in t) {
            n = h[e], i = t[e], h !== i && (p && i && (s(i) || (a = o(i))) ? (a ? (a = !1, c = n && o(n) ? n : []) : c = n && s(n) ? n : {}, h[e] = u(p, c, i)) : void 0 !== i && (h[e] = i));
          }
        }return h;
      };
    }, function (t, e, r) {
      function n(t, e) {
        if (e || (e = {}), this.startKey = e.startKey || 0, this.endKey = e.endKey || 1, this.intervalHash = {}, this.pointTree = new c({ compare: function compare(t, e) {
            if (null == t) return -1;if (null == e) return 1;var r = t[0] - e[0];return r > 0 ? 1 : 0 == r ? 0 : -1;
          } }), this._autoIncrement = 0, !t || "number" != typeof t) throw new Error("you must specify center index as the 2nd argument.");this.root = new u(t, this);
      }function i(t, e) {
        return e.end < t.idx ? (t.left || (t.left = new u(e.start + e.end >> 1, this)), i.call(this, t.left, e)) : t.idx < e.start ? (t.right || (t.right = new u(e.start + e.end >> 1, this)), i.call(this, t.right, e)) : t.insert(e);
      }function o(t, e, r) {
        if (t) return e < t.idx ? (t.starts.every(function (t) {
          var n = t.start <= e;return n && r.push(t.result()), n;
        }), o.call(this, t.left, e, r)) : e > t.idx ? (t.ends.every(function (t) {
          var n = t.end >= e;return n && r.push(t.result()), n;
        }), o.call(this, t.right, e, r)) : void t.starts.map(function (t) {
          r.push(t.result());
        });
      }function s(t, e, r) {
        if (e - t <= 0) throw new Error("end must be greater than start. start: " + t + ", end: " + e);var n = {},
            i = [];o.call(this, this.root, t + e >> 1, i, !0), i.forEach(function (t) {
          n[t.id] = !0;
        });for (var s = this.pointTree.bsearch([t, null]), u = this.pointTree; s >= 0 && u[s][0] == t;) {
          s--;
        }var a = this.pointTree.bsearch([e, null]);if (a >= 0) {
          for (var c = u.length - 1; a <= c && u[a][0] <= e;) {
            a++;
          }u.slice(s + 1, a).forEach(function (t) {
            var e = t[1];n[e] = !0;
          }, this), Object.keys(n).forEach(function (n) {
            var i = this.intervalHash[n];r.push(i.result(t, e));
          }, this);
        }
      }function u(t) {
        this.idx = t, this.starts = new c({ compare: function compare(t, e) {
            if (null == t) return -1;if (null == e) return 1;var r = t.start - e.start;return r > 0 ? 1 : 0 == r ? 0 : -1;
          } }), this.ends = new c({ compare: function compare(t, e) {
            if (null == t) return -1;if (null == e) return 1;var r = t.end - e.end;return r < 0 ? 1 : 0 == r ? 0 : -1;
          } });
      }function a(t, e, r, n) {
        if (this.id = e, this.start = t[r], this.end = t[n], this.data = t, "number" != typeof this.start || "number" != typeof this.end) throw new Error("start, end must be number. start: " + this.start + ", end: " + this.end);if (this.start >= this.end) throw new Error("start must be smaller than end. start: " + this.start + ", end: " + this.end);
      }var c = r(7);n.prototype.add = function (t, e) {
        if (this.intervalHash[e]) throw new Error("id " + e + " is already registered.");if (void 0 == e) {
          for (; this.intervalHash[this._autoIncrement];) {
            this._autoIncrement++;
          }e = this._autoIncrement;
        }var r = new a(t, e, this.startKey, this.endKey);this.pointTree.insert([r.start, e]), this.pointTree.insert([r.end, e]), this.intervalHash[e] = r, this._autoIncrement++, i.call(this, this.root, r);
      }, n.prototype.search = function (t, e) {
        var r = [];if ("number" != typeof t) throw new Error(t + ": invalid input");if (void 0 == e) o.call(this, this.root, t, r);else {
          if ("number" != typeof e) throw new Error(t + "," + e + ": invalid input");s.call(this, t, e, r);
        }return r;
      }, n.prototype.remove = function (t) {}, u.prototype.insert = function (t) {
        this.starts.insert(t), this.ends.insert(t);
      }, a.prototype.result = function (t, e) {
        var r = { id: this.id, data: this.data };if ("number" == typeof t && "number" == typeof e) {
          var n = Math.max(this.start, t),
              i = Math.min(this.end, e),
              o = i - n;r.rate1 = o / (e - t), r.rate2 = o / (this.end - this.start);
        }return r;
      }, t.exports = n;
    }, function (t, e) {
      var r = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (t) {
        return typeof t === 'undefined' ? 'undefined' : _typeof(t);
      } : function (t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t === 'undefined' ? 'undefined' : _typeof(t);
      },
          n = function i() {
        var t = null,
            e = {},
            n = arguments;["0", "1"].forEach(function (i) {
          var o = n[i];Array.isArray(o) ? t = o : o && "object" == ("undefined" == typeof o ? "undefined" : r(o)) && (e = o);
        }), "function" == typeof e.filter && (this._filter = e.filter), "function" == typeof e.compare ? this._compare = e.compare : "string" == typeof e.compare && i.compares[e.compare] && (this._compare = i.compares[e.compare]), this._unique = !!e.unique, e.resume && t ? t.forEach(function (t, e) {
          this.push(t);
        }, this) : t && this.insert.apply(this, t);
      };n.create = function (t, e) {
        return new n(t, e);
      }, n.prototype = new Array(), n.prototype.constructor = Array.prototype.constructor, n.prototype.insertOne = function (t) {
        var e = this.bsearch(t);return (!this._unique || null == this.key(t, e)) && !!this._filter(t, e) && (this.splice(e + 1, 0, t), e + 1);
      }, n.prototype.insert = function () {
        return Array.prototype.map.call(arguments, function (t) {
          return this.insertOne(t);
        }, this);
      }, n.prototype.remove = function (t) {
        return this.splice(t, 1), this;
      }, n.prototype.bsearch = function (t) {
        if (!this.length) return -1;for (var e, r = 0, n = this.length; n - r > 1;) {
          e = Math.floor((r + n) / 2);var i = this[e],
              o = this._compare(t, i);if (0 == o) return e;o > 0 ? r = e : n = e;
        }return 0 == r && this._compare(this[0], t) > 0 ? -1 : r;
      }, n.prototype.key = function (t, e) {
        null == e && (e = this.bsearch(t));var r = e;if (r == -1 || this._compare(this[r], t) < 0) return r + 1 < this.length && 0 == this._compare(this[r + 1], t) ? r + 1 : null;for (; r >= 1 && 0 == this._compare(this[r - 1], t);) {
          r--;
        }return r;
      }, n.prototype.keys = function (t, e) {
        var r = [];null == e && (e = this.bsearch(t));for (var n = e; n >= 0 && 0 == this._compare(this[n], t);) {
          r.push(n), n--;
        }var i = this.length;for (n = e + 1; n < i && 0 == this._compare(this[n], t);) {
          r.push(n), n++;
        }return r.length ? r : null;
      }, n.prototype.unique = function (t) {
        if (t) return this.filter(function (t, e) {
          return 0 == e || 0 != this._compare(this[e - 1], t);
        }, this);var e = 0;return this.map(function (t, r) {
          return 0 == r || 0 != this._compare(this[r - 1], t) ? null : r - e++;
        }, this).forEach(function (t) {
          null != t && this.remove(t);
        }, this), this;
      }, n.prototype.toArray = function () {
        return this.slice();
      }, n.prototype._filter = function (t, e) {
        return !0;
      }, n.compares = { number: function number(t, e) {
          var r = t - e;return r > 0 ? 1 : 0 == r ? 0 : -1;
        }, string: function string(t, e) {
          return t > e ? 1 : t == e ? 0 : -1;
        } }, n.prototype._compare = n.compares.string, t.exports = n;
    }, function (t, e, r) {
      function n(t) {
        var e = new s.Variable(t.targetPos);return e.node = t, e;
      }function i(t, e) {
        if (t.length > 0) {
          e = o.extend(u, e), t.forEach(function (t, e) {
            t.targetPos = t.parent ? t.parent.currentPos : t.idealPos, t.index = e;
          });for (var r = t.concat().sort(function (t, e) {
            var r = t.targetPos - e.targetPos;if (0 !== r) return r;var n = t.isStub() - e.isStub();return 0 !== n ? n : t.index - e.index;
          }).map(n), i = [], a = 1; a < r.length; a++) {
            var c = r[a - 1],
                h = r[a],
                l = void 0;l = c.node.isStub() && h.node.isStub() ? (c.node.width + h.node.width) / 2 + e.lineSpacing : (c.node.width + h.node.width) / 2 + e.nodeSpacing, i.push(new s.Constraint(c, h, l));
          }if (o.isDefined(e.minPos)) {
            var f = new s.Variable(e.minPos, 1e10),
                p = r[0];i.push(new s.Constraint(f, p, p.node.width / 2)), r.unshift(f);
          }if (o.isDefined(e.maxPos)) {
            var d = new s.Variable(e.maxPos, 1e10),
                v = o.last(r);i.push(new s.Constraint(v, d, v.node.width / 2)), r.push(d);
          }new s.Solver(r, i).solve(), r.filter(function (t) {
            return t.node;
          }).map(function (t) {
            return t.node.currentPos = Math.round(t.position()), t;
          });
        }return t;
      }var o = r(4),
          s = r(9),
          u = { lineSpacing: 2, nodeSpacing: 3, minPos: 0, maxPos: null };i.DEFAULT_OPTIONS = u, t.exports = i;
    }, function (t, e) {
      var r = {},
          n = function () {
        function t(t) {
          this.scale = t, this.AB = 0, this.AD = 0, this.A2 = 0;
        }return t.prototype.addVariable = function (t) {
          var e = this.scale / t.scale,
              r = t.offset / t.scale,
              n = t.weight;this.AB += n * e * r, this.AD += n * e * t.desiredPosition, this.A2 += n * e * e;
        }, t.prototype.getPosn = function () {
          return (this.AD - this.AB) / this.A2;
        }, t;
      }();r.PositionStats = n;var i = function () {
        function t(t, e, r, n) {
          void 0 === n && (n = !1), this.left = t, this.right = e, this.gap = r, this.equality = n, this.active = !1, this.unsatisfiable = !1, this.left = t, this.right = e, this.gap = r, this.equality = n;
        }return t.prototype.slack = function () {
          return this.unsatisfiable ? Number.MAX_VALUE : this.right.scale * this.right.position() - this.gap - this.left.scale * this.left.position();
        }, t;
      }();r.Constraint = i;var o = function () {
        function t(t, e, r) {
          void 0 === e && (e = 1), void 0 === r && (r = 1), this.desiredPosition = t, this.weight = e, this.scale = r, this.offset = 0;
        }return t.prototype.dfdv = function () {
          return 2 * this.weight * (this.position() - this.desiredPosition);
        }, t.prototype.position = function () {
          return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
        }, t.prototype.visitNeighbours = function (t, e) {
          var r = function r(_r, n) {
            return _r.active && t !== n && e(_r, n);
          };this.cOut.forEach(function (t) {
            return r(t, t.right);
          }), this.cIn.forEach(function (t) {
            return r(t, t.left);
          });
        }, t;
      }();r.Variable = o;var s = function () {
        function t(t) {
          this.vars = [], t.offset = 0, this.ps = new n(t.scale), this.addVariable(t);
        }return t.prototype.addVariable = function (t) {
          t.block = this, this.vars.push(t), this.ps.addVariable(t), this.posn = this.ps.getPosn();
        }, t.prototype.updateWeightedPosition = function () {
          this.ps.AB = this.ps.AD = this.ps.A2 = 0;for (var t = 0, e = this.vars.length; t < e; ++t) {
            this.ps.addVariable(this.vars[t]);
          }this.posn = this.ps.getPosn();
        }, t.prototype.compute_lm = function (t, e, r) {
          var n = this,
              i = t.dfdv();return t.visitNeighbours(e, function (e, o) {
            var s = n.compute_lm(o, t, r);o === e.right ? (i += s * e.left.scale, e.lm = s) : (i += s * e.right.scale, e.lm = -s), r(e);
          }), i / t.scale;
        }, t.prototype.populateSplitBlock = function (t, e) {
          var r = this;t.visitNeighbours(e, function (e, n) {
            n.offset = t.offset + (n === e.right ? e.gap : -e.gap), r.addVariable(n), r.populateSplitBlock(n, t);
          });
        }, t.prototype.traverse = function (t, e, r, n) {
          var i = this;void 0 === r && (r = this.vars[0]), void 0 === n && (n = null), r.visitNeighbours(n, function (n, o) {
            e.push(t(n)), i.traverse(t, e, o, r);
          });
        }, t.prototype.findMinLM = function () {
          var t = null;return this.compute_lm(this.vars[0], null, function (e) {
            !e.equality && (null === t || e.lm < t.lm) && (t = e);
          }), t;
        }, t.prototype.findMinLMBetween = function (t, e) {
          this.compute_lm(t, null, function () {});var r = null;return this.findPath(t, null, e, function (t, e) {
            !t.equality && t.right === e && (null === r || t.lm < r.lm) && (r = t);
          }), r;
        }, t.prototype.findPath = function (t, e, r, n) {
          var i = this,
              o = !1;return t.visitNeighbours(e, function (e, s) {
            o || s !== r && !i.findPath(s, t, r, n) || (o = !0, n(e, s));
          }), o;
        }, t.prototype.isActiveDirectedPathBetween = function (t, e) {
          if (t === e) return !0;for (var r = t.cOut.length; r--;) {
            var n = t.cOut[r];if (n.active && this.isActiveDirectedPathBetween(n.right, e)) return !0;
          }return !1;
        }, t.split = function (e) {
          return e.active = !1, [t.createSplitBlock(e.left), t.createSplitBlock(e.right)];
        }, t.createSplitBlock = function (e) {
          var r = new t(e);return r.populateSplitBlock(e, null), r;
        }, t.prototype.splitBetween = function (e, r) {
          var n = this.findMinLMBetween(e, r);if (null !== n) {
            var i = t.split(n);return { constraint: n, lb: i[0], rb: i[1] };
          }return null;
        }, t.prototype.mergeAcross = function (t, e, r) {
          e.active = !0;for (var n = 0, i = t.vars.length; n < i; ++n) {
            var o = t.vars[n];o.offset += r, this.addVariable(o);
          }this.posn = this.ps.getPosn();
        }, t.prototype.cost = function () {
          for (var t = 0, e = this.vars.length; e--;) {
            var r = this.vars[e],
                n = r.position() - r.desiredPosition;t += n * n * r.weight;
          }return t;
        }, t;
      }();r.Block = s;var u = function () {
        function t(t) {
          this.vs = t;var e = t.length;for (this.list = new Array(e); e--;) {
            var r = new s(t[e]);this.list[e] = r, r.blockInd = e;
          }
        }return t.prototype.cost = function () {
          for (var t = 0, e = this.list.length; e--;) {
            t += this.list[e].cost();
          }return t;
        }, t.prototype.insert = function (t) {
          t.blockInd = this.list.length, this.list.push(t);
        }, t.prototype.remove = function (t) {
          var e = this.list.length - 1,
              r = this.list[e];this.list.length = e, t !== r && (this.list[t.blockInd] = r, r.blockInd = t.blockInd);
        }, t.prototype.merge = function (t) {
          var e = t.left.block,
              r = t.right.block,
              n = t.right.offset - t.left.offset - t.gap;e.vars.length < r.vars.length ? (r.mergeAcross(e, t, n), this.remove(e)) : (e.mergeAcross(r, t, -n), this.remove(r));
        }, t.prototype.forEach = function (t) {
          this.list.forEach(t);
        }, t.prototype.updateBlockPositions = function () {
          this.list.forEach(function (t) {
            return t.updateWeightedPosition();
          });
        }, t.prototype.split = function (t) {
          var e = this;this.updateBlockPositions(), this.list.forEach(function (r) {
            var n = r.findMinLM();null !== n && n.lm < a.LAGRANGIAN_TOLERANCE && (r = n.left.block, s.split(n).forEach(function (t) {
              return e.insert(t);
            }), e.remove(r), t.push(n));
          });
        }, t;
      }();r.Blocks = u;var a = function () {
        function t(t, e) {
          this.vs = t, this.cs = e, this.vs = t, t.forEach(function (t) {
            t.cIn = [], t.cOut = [];
          }), this.cs = e, e.forEach(function (t) {
            t.left.cOut.push(t), t.right.cIn.push(t);
          }), this.inactive = e.map(function (t) {
            return t.active = !1, t;
          }), this.bs = null;
        }return t.prototype.cost = function () {
          return this.bs.cost();
        }, t.prototype.setStartingPositions = function (t) {
          this.inactive = this.cs.map(function (t) {
            return t.active = !1, t;
          }), this.bs = new u(this.vs), this.bs.forEach(function (e, r) {
            return e.posn = t[r];
          });
        }, t.prototype.setDesiredPositions = function (t) {
          this.vs.forEach(function (e, r) {
            return e.desiredPosition = t[r];
          });
        }, t.prototype.mostViolated = function () {
          for (var e = Number.MAX_VALUE, r = null, n = this.inactive, i = n.length, o = i, s = 0; s < i; ++s) {
            var u = n[s];if (!u.unsatisfiable) {
              var a = u.slack();if ((u.equality || a < e) && (e = a, r = u, o = s, u.equality)) break;
            }
          }return o !== i && (e < t.ZERO_UPPERBOUND && !r.active || r.equality) && (n[o] = n[i - 1], n.length = i - 1), r;
        }, t.prototype.satisfy = function () {
          null == this.bs && (this.bs = new u(this.vs)), this.bs.split(this.inactive);for (var e = null; (e = this.mostViolated()) && (e.equality || e.slack() < t.ZERO_UPPERBOUND && !e.active);) {
            var r = e.left.block,
                n = e.right.block;if (r !== n) this.bs.merge(e);else {
              if (r.isActiveDirectedPathBetween(e.right, e.left)) {
                e.unsatisfiable = !0;continue;
              }var i = r.splitBetween(e.left, e.right);if (null === i) {
                e.unsatisfiable = !0;continue;
              }this.bs.insert(i.lb), this.bs.insert(i.rb), this.bs.remove(r), this.inactive.push(i.constraint), e.slack() >= 0 ? this.inactive.push(e) : this.bs.merge(e);
            }
          }
        }, t.prototype.solve = function () {
          this.satisfy();for (var t = Number.MAX_VALUE, e = this.bs.cost(); Math.abs(t - e) > 1e-4;) {
            this.satisfy(), t = e, e = this.bs.cost();
          }return e;
        }, t.LAGRANGIAN_TOLERANCE = -1e-4, t.ZERO_UPPERBOUND = -1e-10, t;
      }();r.Solver = a, t.exports = r;
    }, function (t, e, r) {
      function n(t) {
        this.options = c.extend({ layerGap: 60, nodeHeight: 10, direction: "down" }, t);
      }function i(t) {
        return "L " + t.join(" ");
      }function o(t) {
        return "M " + t.join(" ");
      }function s(t, e, r) {
        return "C " + t.join(" ") + " " + e.join(" ") + " " + r.join(" ");
      }function u(t, e) {
        var r = (t[1] + e[1]) / 2;return s([t[0], r], [e[0], r], e);
      }function a(t, e) {
        var r = (t[0] + e[0]) / 2;return s([r, t[1]], [r, e[1]], e);
      }var c = r(4);n.lineTo = i, n.moveTo = o, n.curveTo = s, n.vCurveBetween = u, n.hCurveBetween = a, n.prototype.getWaypoints = function (t) {
        var e = this.options,
            r = e.direction,
            n = t.getPathFromRoot(),
            i = e.nodeHeight + e.layerGap;return "left" === r ? [[[0, n[0].idealPos]]].concat(n.map(function (t, r) {
          var n = i * (r + 1) * -1;return [[n + e.nodeHeight, t.currentPos], [n, t.currentPos]];
        })) : "right" === r ? [[[0, n[0].idealPos]]].concat(n.map(function (t, r) {
          var n = i * (r + 1);return [[n - e.nodeHeight, t.currentPos], [n, t.currentPos]];
        })) : "up" === r ? [[[n[0].idealPos, 0]]].concat(n.map(function (t, r) {
          var n = i * (r + 1) * -1;return [[t.currentPos, n + e.nodeHeight], [t.currentPos, n]];
        })) : [[[n[0].idealPos, 0]]].concat(n.map(function (t, r) {
          var n = i * (r + 1);return [[t.currentPos, n - e.nodeHeight], [t.currentPos, n]];
        }));
      }, n.prototype.layout = function (t) {
        var e = this.options,
            r = e.layerGap + e.nodeHeight;switch (e.direction) {case "left":
            t.forEach(function (t) {
              var n = t.getLayerIndex() * r + e.layerGap;t.x = -n - e.nodeHeight, t.y = t.currentPos, t.dx = e.nodeHeight, t.dy = t.width;
            });break;case "right":
            t.forEach(function (t) {
              var n = t.getLayerIndex() * r + e.layerGap;t.x = n, t.y = t.currentPos, t.dx = e.nodeHeight, t.dy = t.width;
            });break;case "up":
            t.forEach(function (t) {
              var n = t.getLayerIndex() * r + e.layerGap;t.x = t.currentPos, t.y = -n - e.nodeHeight, t.dx = t.width, t.dy = e.nodeHeight;
            });break;default:case "down":
            t.forEach(function (t) {
              var n = t.getLayerIndex() * r + e.layerGap;t.x = t.currentPos, t.y = n, t.dx = t.width, t.dy = e.nodeHeight;
            });}return t;
      }, n.prototype.generatePath = function (t) {
        var e = this.options,
            r = e.direction,
            n = this.getWaypoints(t, r),
            s = [o(n[0][0])];return "left" === r || "right" === r ? n.reduce(function (t, e, r) {
          return s.push(a(t[t.length - 1], e[0])), r < n.length - 1 && s.push(i(e[1])), e;
        }) : n.reduce(function (t, e, r) {
          return s.push(u(t[t.length - 1], e[0])), r < n.length - 1 && s.push(i(e[1])), e;
        }), s.join(" ");
      }, t.exports = n;
    }]);
  });
});

var labella_min_1 = labella_min.labella;

var SpanOrDiv = (function (props) {
  var style = props.style,
      className = props.className,
      children = props.children;

  if (props.span) return React.createElement(
    'span',
    { className: className, style: _extends({ display: 'block' }, style) },
    children
  );

  return React.createElement(
    'div',
    { className: className, style: style },
    children
  );
});

// modules
//import { load } from 'opentype.js'
function adjustedAnnotationKeyMapper(d) {
  return d.props.noteData.id || d.props.noteData.x + "-" + d.props.noteData.y;
}

function noteDataWidth(noteData) {
  var charWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;

  var wrap = noteData.note && noteData.note.wrap || 120;
  var noteText = noteData.note.label || noteData.note.label || "";
  return Math.min(wrap, noteText.length * charWidth);
}

function noteDataHeight(noteData) {
  var charWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var lineHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;

  var wrap = noteData.note && noteData.note.wrap || 120;
  var text = noteData.note.label || noteData.note.title || "";
  return Math.ceil(text.length * charWidth / wrap) * lineHeight + (noteData.note.label && noteData.note.title ? lineHeight : 0);
}

function objectStringKey(object) {
  var finalKey = "";
  Object.keys(object).forEach(function (key) {
    finalKey += !object[key] || !object[key].toString ? object[key] : object[key].toString();
  });

  return finalKey;
}

var AnnotationLayer = function (_React$Component) {
  inherits(AnnotationLayer, _React$Component);

  function AnnotationLayer(props) {
    classCallCheck(this, AnnotationLayer);

    var _this = possibleConstructorReturn(this, (AnnotationLayer.__proto__ || Object.getPrototypeOf(AnnotationLayer)).call(this, props));

    _this.generateSVGAnnotations = _this.generateSVGAnnotations.bind(_this);
    _this.generateHTMLAnnotations = _this.generateHTMLAnnotations.bind(_this);

    _this.state = {
      font: undefined,
      svgAnnotations: [],
      htmlAnnotations: [],
      adjustedAnnotations: 0,
      adjustedAnnotationsKey: "",
      adjustedAnnotationsDataVersion: ""
    };
    return _this;
  }

  /*    componentWillMount() {
      const fontLocation = this.props.fontLocation
       if (fontLocation) {
        load(fontLocation, function(err, font) {
            if (err) {
                return null
            } else {
                this.setState({ font });
            }
        });
      }
    } */

  createClass(AnnotationLayer, [{
    key: "generateSVGAnnotations",
    value: function generateSVGAnnotations(props, annotations) {
      var renderedAnnotations = annotations.map(function (d, i) {
        return props.svgAnnotationRule(d, i, props);
      }).filter(function (d) {
        return d !== null && d !== undefined;
      });

      return renderedAnnotations;
    }
  }, {
    key: "generateHTMLAnnotations",
    value: function generateHTMLAnnotations(props, annotations) {
      var renderedAnnotations = annotations.map(function (d, i) {
        return props.htmlAnnotationRule(d, i, props);
      }).filter(function (d) {
        return d !== null && d !== undefined;
      });

      return renderedAnnotations;
    }
  }, {
    key: "processAnnotations",
    value: function processAnnotations(adjustableAnnotations, annotationProcessor, props) {
      if (annotationProcessor.type === false) {
        return adjustableAnnotations;
      }

      var _props$margin = props.margin,
          margin = _props$margin === undefined ? { top: 0, bottom: 0, left: 0, right: 0 } : _props$margin;
      var size = props.size,
          _props$axes = props.axes,
          axes = _props$axes === undefined ? [] : _props$axes;


      margin = typeof margin === "number" ? { top: margin, left: margin, right: margin, bottom: margin } : margin;

      var _annotationProcessor$ = annotationProcessor.padding,
          padding = _annotationProcessor$ === undefined ? 2 : _annotationProcessor$;


      if (annotationProcessor.type === "bump") {
        var adjustedAnnotations = bumpAnnotations(adjustableAnnotations, props, annotationProcessor);
        return adjustedAnnotations;
      } else if (annotationProcessor.type === "marginalia") {
        var marginOffset = annotationProcessor.marginOffset;

        var finalOrientation = !annotationProcessor.orient || annotationProcessor.orient === "nearest" ? ["left", "right", "top", "bottom"] : Array.isArray(annotationProcessor.orient) ? annotationProcessor.orient : [annotationProcessor.orient];
        var marginOffsetFn = function marginOffsetFn(orient, axisSettings) {
          if (axisSettings && axisSettings.find(function (d) {
            return d.props.orient === orient;
          })) {
            return 50;
          }
          return 10;
        };
        if (typeof marginOffset === "number") {
          marginOffsetFn = function marginOffsetFn() {
            return marginOffset;
          };
        }

        var leftOn = finalOrientation.find(function (d) {
          return d === "left";
        });
        var rightOn = finalOrientation.find(function (d) {
          return d === "right";
        });
        var topOn = finalOrientation.find(function (d) {
          return d === "top";
        });
        var bottomOn = finalOrientation.find(function (d) {
          return d === "bottom";
        });

        var leftNodes = [];
        var rightNodes = [];
        var topNodes = [];
        var bottomNodes = [];

        adjustableAnnotations.forEach(function (aNote) {
          var noteData = aNote.props.noteData;
          var leftDist = leftOn ? noteData.x : Infinity;
          var rightDist = rightOn ? size[0] - noteData.x : Infinity;
          var topDist = topOn ? noteData.y : Infinity;
          var bottomDist = bottomOn ? size[1] - noteData.y : Infinity;

          var minDist = Math.min(leftDist, rightDist, topDist, bottomDist);

          if (leftDist === minDist) {
            leftNodes.push(aNote);
          } else if (rightDist === minDist) {
            rightNodes.push(aNote);
          } else if (topDist === minDist) {
            topNodes.push(aNote);
          } else {
            bottomNodes.push(aNote);
          }
        });

        //Adjust the margins based on which regions are active

        var leftForce = new labella_min.Force({
          minPos: 0 - margin.top,
          maxPos: bottomOn ? size[1] : size[1] + margin.bottom
        }).nodes(leftNodes.map(function (d) {
          return new labella_min.Node(d.props.noteData.y, noteDataHeight(d.props.noteData, annotationProcessor.characterWidth, annotationProcessor.lineHeight) + padding);
        })).compute();

        var rightForce = new labella_min.Force({
          minPos: topOn ? 0 : 0 - margin.top,
          maxPos: size[1] + margin.bottom
        }).nodes(rightNodes.map(function (d) {
          return new labella_min.Node(d.props.noteData.y, noteDataHeight(d.props.noteData, annotationProcessor.characterWidth, annotationProcessor.lineHeight) + padding);
        })).compute();

        var topForce = new labella_min.Force({
          minPos: leftOn ? 0 : 0 - margin.left,
          maxPos: size[0] + margin.right
        }).nodes(topNodes.map(function (d) {
          return new labella_min.Node(d.props.noteData.x, noteDataWidth(d.props.noteData, annotationProcessor.characterWidth) + padding);
        })).compute();

        var bottomForce = new labella_min.Force({
          minPos: 0 - margin.left,
          maxPos: rightOn ? size[0] : size[0] + margin.right
        }).nodes(bottomNodes.map(function (d) {
          return new labella_min.Node(d.props.noteData.x, noteDataWidth(d.props.noteData, annotationProcessor.characterWidth) + padding);
        })).compute();

        var bottomOffset = Math.max.apply(Math, toConsumableArray(bottomNodes.map(function (d) {
          return noteDataHeight(d.props.noteData, annotationProcessor.characterWidth, annotationProcessor.lineHeight) + padding;
        })));
        var topOffset = Math.max.apply(Math, toConsumableArray(topNodes.map(function (d) {
          return noteDataHeight(d.props.noteData, annotationProcessor.characterWidth, annotationProcessor.lineHeight) + padding;
        })));
        var leftOffset = Math.max.apply(Math, toConsumableArray(leftNodes.map(function (d) {
          return noteDataWidth(d.props.noteData, annotationProcessor.characterWidth) + padding;
        })));
        var rightOffset = Math.max.apply(Math, toConsumableArray(rightNodes.map(function (d) {
          return noteDataWidth(d.props.noteData, annotationProcessor.characterWidth) + padding;
        })));

        //      const nodeOffsetHeight = Math.max()

        var leftSortedNodes = leftForce.nodes();
        var rightSortedNodes = rightForce.nodes();
        var topSortedNodes = topForce.nodes();
        var bottomSortedNodes = bottomForce.nodes();

        leftNodes.forEach(function (note, i) {
          note.props.noteData.ny = leftSortedNodes[i].currentPos;
          note.props.noteData.nx = 0 - leftSortedNodes[i].layerIndex * leftOffset - marginOffsetFn("left", axes);
          if (note.props.noteData.note) {
            note.props.noteData.note.orientation = "leftRight";
            note.props.noteData.note.align = "right";
          }
        });

        rightNodes.forEach(function (note, i) {
          note.props.noteData.ny = rightSortedNodes[i].currentPos;
          note.props.noteData.nx = size[0] + rightSortedNodes[i].layerIndex * rightOffset + marginOffsetFn("right", axes);
          if (note.props.noteData.note) {
            note.props.noteData.note.orientation = "leftRight";
            note.props.noteData.note.align = "left";
          }
        });

        topNodes.forEach(function (note, i) {
          note.props.noteData.nx = topSortedNodes[i].currentPos;
          note.props.noteData.ny = 0 - topSortedNodes[i].layerIndex * topOffset - marginOffsetFn("top", axes);
        });

        bottomNodes.forEach(function (note, i) {
          note.props.noteData.nx = bottomSortedNodes[i].currentPos;
          note.props.noteData.ny = size[1] + bottomSortedNodes[i].layerIndex * bottomOffset + marginOffsetFn("bottom", axes);
        });
        return adjustableAnnotations;
      }
      return adjustableAnnotations;
      console.error("Unknown annotation handling function: Must be of a string 'bump' or 'marginalia' or a an object with type of those strings or a function that takes adjustable annotations and returns adjusted annotations");
    }
  }, {
    key: "createAnnotations",
    value: function createAnnotations(props) {
      var renderedSVGAnnotations = this.state.svgAnnotations,
          renderedHTMLAnnotations = [],
          adjustedAnnotations = this.state.adjustedAnnotations,
          adjustableAnnotationsKey = this.state.adjustedAnnotationsKey;

      var adjustedAnnotationsKey = this.state.adjustedAnnotationsKey,
          adjustedAnnotationsDataVersion = this.state.adjustedAnnotationsDataVersion;

      var annotations = props.annotations,
          _props$annotationHand = props.annotationHandling,
          annotationHandling = _props$annotationHand === undefined ? false : _props$annotationHand;

      var annotationProcessor = (typeof annotationHandling === "undefined" ? "undefined" : _typeof(annotationHandling)) !== "object" ? { type: annotationHandling } : annotationHandling;

      var _annotationProcessor$2 = annotationProcessor.dataVersion,
          dataVersion = _annotationProcessor$2 === undefined ? "" : _annotationProcessor$2;


      if (this.props.svgAnnotationRule) {
        var initialSVGAnnotations = this.generateSVGAnnotations(props, annotations);
        var adjustableAnnotations = initialSVGAnnotations.filter(function (d) {
          return d.props && d.props.noteData && !d.props.noteData.fixedPosition;
        });
        var fixedAnnotations = initialSVGAnnotations.filter(function (d) {
          return !d.props || !d.props.noteData || d.props.noteData.fixedPosition;
        });
        adjustableAnnotationsKey = adjustableAnnotations.map(adjustedAnnotationKeyMapper).join(",") + objectStringKey(Object.assign(annotationProcessor, {
          point: props.pointSizeFunction,
          label: props.labelSizeFunction
        }));

        if (annotationProcessor.type === false) {
          adjustedAnnotations = adjustableAnnotations;
        }

        if (adjustedAnnotations.length !== adjustableAnnotations.length || adjustedAnnotationsKey !== adjustableAnnotationsKey || adjustedAnnotationsDataVersion !== dataVersion) {
          adjustedAnnotations = this.processAnnotations(adjustableAnnotations, annotationProcessor, props);
        } else {
          //Handle when style or other attributes change
          adjustedAnnotations = adjustedAnnotations.map(function (d, i) {
            var newNoteData = Object.assign(adjustableAnnotations[i].props.noteData, {
              nx: d.props.noteData.nx,
              ny: d.props.noteData.ny,
              note: d.props.noteData.note
            });
            return React.createElement(SemioticAnnotation, { key: d.key, noteData: newNoteData });
          });
        }

        renderedSVGAnnotations = [].concat(toConsumableArray(adjustedAnnotations), toConsumableArray(fixedAnnotations));
      }

      if (this.props.htmlAnnotationRule) {
        renderedHTMLAnnotations = this.generateHTMLAnnotations(props, annotations);
      }

      this.setState({
        svgAnnotations: renderedSVGAnnotations,
        htmlAnnotations: renderedHTMLAnnotations,
        adjustedAnnotations: adjustedAnnotations,
        adjustedAnnotationsKey: adjustableAnnotationsKey,
        adjustedAnnotationsDataVersion: dataVersion
      });
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.createAnnotations(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.createAnnotations(nextProps);
    }
  }, {
    key: "render",
    value: function render() {
      var _state = this.state,
          svgAnnotations = _state.svgAnnotations,
          htmlAnnotations = _state.htmlAnnotations;
      var _props = this.props,
          useSpans = _props.useSpans,
          legendSettings = _props.legendSettings,
          margin = _props.margin;


      var renderedLegend = void 0;
      if (legendSettings) {
        var positionHash = {
          left: [15, 15],
          right: [this.props.size[0] + 15, 15]
        };
        var _legendSettings$posit = legendSettings.position,
            position = _legendSettings$posit === undefined ? "right" : _legendSettings$posit,
            _legendSettings$title = legendSettings.title,
            title = _legendSettings$title === undefined ? "Legend" : _legendSettings$title;

        var legendPosition = positionHash[position] || position;
        renderedLegend = React.createElement(
          "g",
          { transform: "translate(" + legendPosition + ")" },
          React.createElement(Legend, _extends({}, legendSettings, { title: title, position: position }))
        );
      }
      var svgStyle = {
        background: "none",
        pointerEvents: "none",
        position: "absolute",
        left: margin.left + "px",
        top: margin.top + "px"
        //    if (useSpans) {
      };svgStyle.overflow = "visible";
      //    }

      return React.createElement(
        SpanOrDiv,
        {
          span: useSpans,
          className: "annotation-layer",
          style: {
            position: "absolute",
            pointerEvents: "none",
            background: "none"
          }
        },
        React.createElement(
          "svg",
          {
            className: "annotation-layer-svg",
            height: this.props.size[1],
            width: this.props.size[0],
            style: svgStyle
          },
          React.createElement(
            "g",
            null,
            renderedLegend,
            svgAnnotations
          )
        ),
        useSpans ? null : React.createElement(
          "div",
          {
            className: "annotation-layer-html",
            style: {
              background: "none",
              pointerEvents: "none",
              position: "absolute",
              height: this.props.size[1] + "px",
              width: this.props.size[0] + "px",
              left: margin.left + "px",
              top: margin.top + "px"
            }
          },
          htmlAnnotations
        )
      );
    }
  }]);
  return AnnotationLayer;
}(React.Component);

AnnotationLayer.propTypes = {
  scale: propTypes.func,
  orient: propTypes.string,
  title: propTypes.string,
  format: propTypes.string,
  values: propTypes.array,
  properties: propTypes.object,
  position: propTypes.array
};

var ascending$1 = function (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector = function (compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }
      return lo;
    },
    right: function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator(f) {
  return function (d, x) {
    return ascending$1(f(d), x);
  };
}

var ascendingBisect = bisector(ascending$1);
var bisectRight = ascendingBisect.right;

var number = function (x) {
  return x === null ? NaN : +x;
};

var extent = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
};

var array = Array.prototype;

var slice$1 = array.slice;

var constant$1 = function (x) {
  return function () {
    return x;
  };
};

var identity$1 = function (x) {
  return x;
};

var range = function (start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

var ticks = function (start, stop, count) {
    var reverse = stop < start,
        i = -1,
        n,
        ticks,
        step;

    if (reverse) n = start, start = stop, stop = n;

    if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) {
            ticks[i] = (start + i) * step;
        }
    } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) {
            ticks[i] = (start - i) / step;
        }
    }

    if (reverse) ticks.reverse();

    return ticks;
};

function tickIncrement(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
    return stop < start ? -step1 : step1;
}

var thresholdSturges = function (values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram = function () {
  var value = identity$1,
      domain = extent,
      threshold = thresholdSturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) {
      tz.shift(), --m;
    }while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant$1([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$1(slice$1.call(_)) : constant$1(_), histogram) : threshold;
  };

  return histogram;
};

var quantile = function (values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
};

var max = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
};

var min = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
};

var sum$1 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
};

var datesForUnique = function datesForUnique(d) {
  return d instanceof Date ? d.toString() : d;
};

var projectAreaData = function projectAreaData(_ref) {
  var data = _ref.data,
      areaDataAccessor = _ref.areaDataAccessor,
      projection = _ref.projection,
      xAccessor = _ref.xAccessor,
      yAccessor = _ref.yAccessor;

  projection = projection ? projection : function (d) {
    return areaDataAccessor(d).map(function (p, q) {
      return [xAccessor(p, q), yAccessor(p, q)];
    });
  };
  data.forEach(function (d) {
    d._xyfCoordinates = projection(d);
  });
  return data;
};

var projectLineData = function projectLineData(_ref2) {
  var data = _ref2.data,
      lineDataAccessor = _ref2.lineDataAccessor,
      xProp = _ref2.xProp,
      yProp = _ref2.yProp,
      yPropTop = _ref2.yPropTop,
      yPropBottom = _ref2.yPropBottom,
      xAccessor = _ref2.xAccessor,
      yAccessor = _ref2.yAccessor;

  if (!Array.isArray(data)) {
    data = [data];
  }
  return data.map(function (d, i) {
    var originalLineData = Object.assign({}, d);
    originalLineData.data = lineDataAccessor(d).map(function (p, q) {
      var originalCoords = {};

      originalCoords[xProp] = xAccessor(p, q);
      originalCoords[yProp] = yAccessor(p, q);
      originalCoords[yPropTop] = originalCoords[yProp];
      originalCoords[yPropBottom] = originalCoords[yProp];
      originalCoords.data = p;

      return originalCoords;
    });
    originalLineData.key = originalLineData.key || i;
    return originalLineData;
  });
};

var differenceLine = function differenceLine(_ref3) {
  var data = _ref3.data,
      yProp = _ref3.yProp,
      yPropTop = _ref3.yPropTop,
      yPropBottom = _ref3.yPropBottom;

  data.forEach(function (l, i) {
    l.data.forEach(function (point, q) {
      var otherLine = i === 0 ? 1 : 0;
      if (point[yProp] > data[otherLine].data[q][yProp]) {
        point[yPropBottom] = data[otherLine].data[q][yProp];
        point[yPropTop] = point[yProp];
      } else {
        point[yPropTop] = point[yProp];
        point[yPropBottom] = point[yProp];
      }
    });
  });

  return data;
};

var stackedArea = function stackedArea(_ref4) {
  var _ref4$type = _ref4.type,
      type = _ref4$type === undefined ? "stackedarea" : _ref4$type,
      data = _ref4.data,
      xProp = _ref4.xProp,
      yProp = _ref4.yProp,
      yPropMiddle = _ref4.yPropMiddle,
      sort = _ref4.sort,
      yPropTop = _ref4.yPropTop,
      yPropBottom = _ref4.yPropBottom;

  /* Object.keys(allData.map((d,i) => oAccessor(d,i)).reduce((p,c) => {
      p[c] = true
      return p
    }, {})) */

  var uniqXValues = [].concat(toConsumableArray(new Set(data.map(function (d) {
    return d.data.map(function (p) {
      return datesForUnique(p[xProp]);
    });
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []))));
  var stackSort = function stackSort(a, b) {
    return sum$1(b.data.map(function (p) {
      return p[yProp];
    })) - sum$1(a.data.map(function (p) {
      return p[yProp];
    }));
  };
  if (type === "stackedpercent-invert" || type === "stackedarea-invert") {
    stackSort = function stackSort(a, b) {
      return sum$1(a.data.map(function (p) {
        return p[yProp];
      })) - sum$1(b.data.map(function (p) {
        return p[yProp];
      }));
    };
  }
  sort = sort === undefined ? stackSort : sort;

  if (sort !== null) {
    data = data.sort(sort);
  }

  uniqXValues.forEach(function (xValue) {
    var negativeOffset = 0;
    var positiveOffset = 0;
    var stepValues = data.map(function (d) {
      return d.data.filter(function (p) {
        return datesForUnique(p[xProp]) === xValue;
      });
    }).reduce(function (a, b) {
      return a.concat(b);
    }, []);

    var positiveStepTotal = sum$1(stepValues.map(function (d) {
      return d[yProp] > 0 ? d[yProp] : 0;
    }));
    var negativeStepTotal = sum$1(stepValues.map(function (d) {
      return d[yProp] < 0 ? d[yProp] : 0;
    }));

    stepValues.forEach(function (l) {
      if (l[yProp] < 0) {
        if (type === "linepercent" || type === "stackedpercent" || type === "stackedpercent-invert") {
          var percent = l[yProp] / negativeStepTotal;
          l.percent = percent;
          if (type === "linepercent") {
            l[yPropBottom] = l[yPropBottom] = l[yPropTop] = l[yPropMiddle] = percent;
          } else {
            var adjustment = negativeStepTotal >= 0 ? 0 : percent;
            l[yPropBottom] = negativeStepTotal === 0 ? 0 : -(negativeOffset / negativeStepTotal);
            l[yPropTop] = l[yPropBottom] - adjustment;
            l[yPropMiddle] = l[yPropBottom] - adjustment / 2;
          }
        } else {
          l[yPropBottom] = negativeOffset;
          l[yPropTop] = negativeOffset + l[yProp];
          l[yPropMiddle] = negativeOffset + l[yProp] / 2;
        }
        negativeOffset += l[yProp];
      } else {
        if (type === "linepercent" || type === "stackedpercent" || type === "stackedpercent-invert") {
          var _percent = l[yProp] / positiveStepTotal;
          l.percent = _percent;

          if (type === "linepercent") {
            l[yPropBottom] = l[yPropTop] = l[yPropMiddle] = _percent;
          } else {
            var _adjustment = positiveStepTotal <= 0 ? 0 : _percent;
            l[yPropBottom] = positiveStepTotal === 0 ? 0 : positiveOffset / positiveStepTotal;
            l[yPropTop] = l[yPropBottom] + _adjustment;
            l[yPropMiddle] = l[yPropBottom] + _adjustment / 2;
          }
        } else {
          l[yPropBottom] = positiveOffset;
          l[yPropTop] = positiveOffset + l[yProp];
          l[yPropMiddle] = positiveOffset + l[yProp] / 2;
        }
        positiveOffset += l[yProp];
      }
    });
  });

  return data;
};

var lineChart = function lineChart(_ref5) {
  var data = _ref5.data,
      y1 = _ref5.y1,
      yPropTop = _ref5.yPropTop,
      yPropMiddle = _ref5.yPropMiddle,
      yPropBottom = _ref5.yPropBottom;

  if (y1) {
    data.forEach(function (d) {
      d.data.forEach(function (p) {
        p[yPropBottom] = y1(p);
        p[yPropMiddle] = p[yPropBottom] + p[yPropTop] / 2;
      });
    });
  }

  return data;
};

var bumpChart = function bumpChart(_ref6) {
  var _ref6$type = _ref6.type,
      type = _ref6$type === undefined ? "bumpline" : _ref6$type,
      data = _ref6.data,
      xProp = _ref6.xProp,
      yProp = _ref6.yProp,
      yPropMiddle = _ref6.yPropMiddle,
      yPropTop = _ref6.yPropTop,
      yPropBottom = _ref6.yPropBottom;

  var uniqXValues = [].concat(toConsumableArray(new Set(data.map(function (d) {
    return d.data.map(function (p) {
      return datesForUnique(p[xProp]);
    });
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []))));

  var bumpSort = function bumpSort(a, b) {
    if (a[yProp] > b[yProp]) {
      return 1;
    }
    if (a[yProp] < b[yProp]) {
      return -1;
    }
    return -1;
  };
  if (type === "bumparea-invert" || type === "bumpline-invert") {
    bumpSort = function bumpSort(a, b) {
      if (a[yProp] < b[yProp]) {
        return 1;
      }
      if (a[yProp] > b[yProp]) {
        return -1;
      }
      return -1;
    };
  }

  uniqXValues.forEach(function (xValue) {
    var negativeOffset = 0;
    var positiveOffset = 0;

    data.map(function (d) {
      return d.data.filter(function (p) {
        return datesForUnique(p[xProp]) === xValue;
      });
    }).reduce(function (a, b) {
      return a.concat(b);
    }, []).sort(bumpSort).forEach(function (l, rank) {
      //determine ranking and offset by the number of less than this one at each step
      l._XYFrameRank = rank;
      if (type === "bumparea" || type === "bumparea-invert") {
        if (l[yProp] < 0) {
          l[yPropTop] = negativeOffset + l[yProp];
          l[yPropMiddle] = negativeOffset + l[yProp] / 2;
          l[yPropBottom] = negativeOffset;
          negativeOffset += l[yProp];
        } else {
          l[yPropTop] = positiveOffset + l[yProp];
          l[yPropMiddle] = positiveOffset + l[yProp] / 2;
          l[yPropBottom] = positiveOffset;
          positiveOffset += l[yProp];
        }
      } else {
        l[yProp] = rank;
        l[yPropTop] = rank;
        l[yPropBottom] = rank;
      }
    });
  });

  return data;
};

var dividedLine = function dividedLine(parameters, points) {
  var searchIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;

  var currentParameters = parameters(points[0], 0);
  var currentPointsArray = [];
  var dividedLinesData = [{ key: currentParameters, points: currentPointsArray }];
  points.forEach(function (point, pointI) {
    var newParameters = parameters(point, pointI);

    var matchingParams = newParameters === currentParameters;
    var stringNewParams = JSON.stringify(newParameters);
    var stringCurrentParams = JSON.stringify(currentParameters);

    if ((typeof currentParameters === "undefined" ? "undefined" : _typeof(currentParameters)) === "object") {
      matchingParams = stringNewParams === stringCurrentParams;
    }

    if (matchingParams) {
      currentPointsArray.push(point);
    } else {
      var lastPoint = currentPointsArray[currentPointsArray.length - 1];
      var pointA = lastPoint;
      var pointB = point;
      var stringBParams = stringNewParams;

      var x = 0;
      while (x < searchIterations && stringNewParams === stringBParams) {
        var keys = Object.keys(pointA);
        var findPoints = simpleSearchFunction({
          pointA: pointA,
          pointB: pointB,
          currentParameters: currentParameters,
          parameters: parameters,
          keys: keys
        });
        pointA = findPoints[0];
        pointB = findPoints[1];
        stringBParams = JSON.stringify(parameters(pointB));
        x++;
      }
      currentPointsArray.push(pointB);
      currentPointsArray = [pointB, point];
      dividedLinesData.push({ key: newParameters, points: currentPointsArray });
      currentParameters = newParameters;
    }
  });
  return dividedLinesData;
};

function simpleSearchFunction(_ref7) {
  var pointA = _ref7.pointA,
      pointB = _ref7.pointB,
      currentParameters = _ref7.currentParameters,
      parameters = _ref7.parameters,
      keys = _ref7.keys;

  var betweenPoint = {};
  keys.forEach(function (key) {
    betweenPoint[key] = typeof pointA[key] === "number" ? (pointA[key] + pointB[key]) / 2 : undefined;
  });
  var stringBetween = JSON.stringify(parameters(betweenPoint));
  var stringCurrent = JSON.stringify(currentParameters);

  if (stringBetween === stringCurrent) {
    return [betweenPoint, pointB];
  }
  return [pointA, betweenPoint];
}

function funnelize(_ref8) {
  var data = _ref8.data,
      steps = _ref8.steps,
      key = _ref8.key;

  var funnelData = [];
  if (!Array.isArray(data)) {
    data = [data];
  }
  if (!steps) {
    steps = data.map(function (d) {
      return Object.keys(d);
    }).reduce(function (a, b) {
      return a.concat(b);
    }, []);
  }

  data.forEach(function (datum, i) {
    var datumKey = key ? datum[key] : i;
    steps.forEach(function (step) {
      var funnelDatum = { funnelKey: datumKey };
      funnelDatum.stepName = step;
      funnelDatum.stepValue = datum[step] ? datum[step] : 0;
      funnelData.push(funnelDatum);
    });
  });

  return funnelData;
}

function relativeY(_ref9) {
  var point = _ref9.point,
      lines = _ref9.lines,
      projectedYMiddle = _ref9.projectedYMiddle,
      projectedY = _ref9.projectedY,
      projectedX = _ref9.projectedX,
      xAccessor = _ref9.xAccessor,
      yAccessor = _ref9.yAccessor,
      yScale = _ref9.yScale,
      xScale = _ref9.xScale,
      idAccessor = _ref9.idAccessor;

  if (idAccessor(point)) {
    var thisLine = lines.data.find(function (l) {
      return idAccessor(l) === idAccessor(point);
    });
    if (!thisLine) {
      return null;
    }
    var thisPoint = thisLine.data.find(function (p) {
      return xScale(p[projectedX]) === xScale(xAccessor(point));
    });
    if (!thisPoint) {
      return null;
    }
    point = thisPoint;
  }
  return yScale(point[projectedYMiddle] || point[projectedY] || yAccessor(point));
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

var namespace = function (name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
};

function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

var creator = function (name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
};

var nextId = 0;

function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function get(node) {
    var id = this._;
    while (!(id in node)) {
      if (!(node = node.parentNode)) return;
    }return node[id];
  },
  set: function set(node, value) {
    return node[this._] = value;
  },
  remove: function remove(node) {
    return this._ in node && delete node[this._];
  },
  toString: function toString() {
    return this._;
  }
};

var matcher = function matcher(selector) {
  return function () {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;
    matcher = function matcher(selector) {
      return function () {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
    if (!on) this.__on = [o];else on.push(o);
  };
}

var selection_on = function (typename, value, capture) {
  var typenames = parseTypenames(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) {
    this.each(on(typenames[i], value, capture));
  }return this;
};

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

var sourceEvent = function () {
  var current = event,
      source;
  while (source = current.sourceEvent) {
    current = source;
  }return current;
};

var point = function (node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
};

var mouse = function (node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
};

function none$2() {}

var selector = function (selector) {
  return selector == null ? none$2 : function () {
    return this.querySelector(selector);
  };
};

var selection_select = function (select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

function empty() {
  return [];
}

var selectorAll = function (selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
};

var selection_selectAll = function (select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
};

var selection_filter = function (match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

var sparse = function (update) {
  return new Array(update.length);
};

var selection_enter = function () {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
};

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

var constant$2 = function (x) {
  return function () {
    return x;
  };
};

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

var selection_data = function (value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$2(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {}
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
};

var selection_exit = function () {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
};

var selection_merge = function (selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
};

var selection_order = function () {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
};

var selection_sort = function (compare) {
  if (!compare) compare = ascending$2;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
};

function ascending$2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

var selection_call = function () {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
};

var selection_nodes = function () {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
};

var selection_node = function () {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
};

var selection_size = function () {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
};

var selection_empty = function () {
  return !this.node();
};

var selection_each = function (callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
};

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

var selection_attr = function (name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
};

var window$1 = function (node) {
    return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
    node.document && node // node is a Window
    || node.defaultView; // node is a Document
};

function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

var selection_style = function (name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
};

function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window$1(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

var selection_property = function (name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
};

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;
  while (++i < n) {
    list.add(names[i]);
  }
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;
  while (++i < n) {
    list.remove(names[i]);
  }
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

var selection_classed = function (name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;
    while (++i < n) {
      if (!list.contains(names[i])) return false;
    }return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
};

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

var selection_text = function (value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
};

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

var selection_html = function (value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
};

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

var selection_raise = function () {
  return this.each(raise);
};

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

var selection_lower = function () {
  return this.each(lower);
};

var selection_append = function (name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
};

function constantNull() {
  return null;
}

var selection_insert = function (name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
};

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

var selection_remove = function () {
  return this.each(remove);
};

var selection_datum = function (value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
};

function dispatchEvent(node, type, params) {
  var window = window$1(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

var selection_dispatch = function (type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
};

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

var select = function (selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
};

var selectAll = function (selector) {
    return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
};

var touch = function (node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
};

var touches = function (node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
};



var d3Selection = Object.freeze({
	creator: creator,
	local: local,
	matcher: matcher$1,
	mouse: mouse,
	namespace: namespace,
	namespaces: namespaces,
	select: select,
	selectAll: selectAll,
	selection: selection,
	selector: selector,
	selectorAll: selectorAll,
	style: styleValue,
	touch: touch,
	touches: touches,
	window: window$1,
	get event () { return event; },
	customEvent: customEvent
});

var noop$1 = { value: function value() {} };

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name: name };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) {
        if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
      }return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);else if (callback == null) for (t in _) {
        _[t] = set$2(_[t], typename.name, null);
      }
    }

    return this;
  },
  copy: function copy() {
    var copy = {},
        _ = this._;
    for (var t in _) {
      copy[t] = _[t].slice();
    }return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
      args[i] = arguments[i + 2];
    }if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  }
};

function get$2(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$2(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name: name, value: callback });
  return type;
}

var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1000;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date;
var setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead,
      e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

var timeout$1 = function (callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
};

var emptyOn = dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

var schedule = function (node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
};

function init(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
  return schedule;
}

function set$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
  return schedule;
}

function get$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout$1(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          delete schedules[i];
        }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout$1(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) {
      return;
    } // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

var interrupt = function (node, name) {
  var schedules = node.__transition,
      schedule$$1,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule$$1 = schedules[i]).name !== name) {
      empty = false;continue;
    }
    active = schedule$$1.state > STARTING && schedule$$1.state < ENDING;
    schedule$$1.state = ENDED;
    schedule$$1.timer.stop();
    if (active) schedule$$1.on.call("interrupt", node, node.__data__, schedule$$1.index, schedule$$1.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
};

var selection_interrupt = function (name) {
  return this.each(function () {
    interrupt(this, name);
  });
};

var define = function (constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) {
    prototype[key] = definition[key];
  }return prototype;
}

function Color() {}

var _darker = 0.7;
var _brighter = 1 / _darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  toString: function toString() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1)) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
  },
  toString: function toString() {
    var a = this.opacity;a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function brighter(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb$$1() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb$$1() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function brighter$$1(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker$$1(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb$$1() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));



var d3Color = Object.freeze({
	color: color,
	rgb: rgb,
	hsl: hsl,
	lab: lab,
	hcl: hcl,
	cubehelix: cubehelix
});

var constant$3 = function (x) {
  return function () {
    return x;
  };
};

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
}

var interpolateRgb = (function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
})(1);

var array$1 = function (a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = interpolate(a[i], b[i]);
  }for (; i < nb; ++i) {
    c[i] = b[i];
  }return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }return c;
  };
};

var date = function (a, b) {
  var d = new Date();
  return a = +a, b -= a, function (t) {
    return d.setTime(a + b * t), d;
  };
};

var interpolateNumber = function (a, b) {
  return a = +a, b -= a, function (t) {
    return a + b * t;
  };
};

var object = function (a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || (typeof a === "undefined" ? "undefined" : _typeof(a)) !== "object") a = {};
  if (b === null || (typeof b === "undefined" ? "undefined" : _typeof(b)) !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

var interpolateString = function (a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({ i: i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }return s.join("");
  });
};

var interpolate = function (a, b) {
    var t = typeof b === "undefined" ? "undefined" : _typeof(b),
        c;
    return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date : Array.isArray(b) ? array$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
};

var interpolateRound = function (a, b) {
  return a = +a, b -= a, function (t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function (a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity$2;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity$2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function (t) {
      var i = -1,
          n = q.length,
          o;
      while (++i < n) {
        s[(o = q[i]).i] = o.x(t);
      }return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;

function cubehelix$1(hue$$1) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  }(1);
}

cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule$$1 = set$1(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule$$1.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule$$1 = set$1(this, id),
        tween = schedule$$1.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule$$1.tween = tween1;
  };
}

var transition_tween = function (name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$1(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
};

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function () {
    var schedule$$1 = set$1(this, id);
    (schedule$$1.value || (schedule$$1.value = {}))[name] = value.apply(this, arguments);
  });

  return function (node) {
    return get$1(node, id).value[name];
  };
}

var interpolate$1 = function (a, b) {
    var c;
    return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
};

function attrRemove$1(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction$1(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS$1(fullname, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

var transition_attr = function (name, value) {
  var fullname = namespace(name),
      i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname) : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value));
};

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

var transition_attrTween = function (name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
};

function delayFunction(id, value) {
  return function () {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    init(this, id).delay = value;
  };
}

var transition_delay = function (value) {
  var id = this._id;

  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : get$1(this.node(), id).delay;
};

function durationFunction(id, value) {
  return function () {
    set$1(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    set$1(this, id).duration = value;
  };
}

var transition_duration = function (value) {
  var id = this._id;

  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : get$1(this.node(), id).duration;
};

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    set$1(this, id).ease = value;
  };
}

var transition_ease = function (value) {
  var id = this._id;

  return arguments.length ? this.each(easeConstant(id, value)) : get$1(this.node(), id).ease;
};

var transition_filter = function (match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
};

var transition_merge = function (transition$$1) {
  if (transition$$1._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
};

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? init : set$1;
  return function () {
    var schedule$$1 = sit(this, id),
        on = schedule$$1.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule$$1.on = on1;
  };
}

var transition_on = function (name, listener) {
  var id = this._id;

  return arguments.length < 2 ? get$1(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
};

function removeFunction(id) {
  return function () {
    var parent = this.parentNode;
    for (var i in this.__transition) {
      if (+i !== id) return;
    }if (parent) parent.removeChild(this);
  };
}

var transition_remove = function () {
  return this.on("end.remove", removeFunction(this._id));
};

var transition_select = function (select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
};

var transition_selectAll = function (select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
};

var Selection$1 = selection.prototype.constructor;

var transition_selection = function () {
  return new Selection$1(this._groups, this._parents);
};

function styleRemove$1(name, interpolate) {
    var value00, value10, interpolate0;
    return function () {
        var style = window$1(this).getComputedStyle(this, null),
            value0 = style.getPropertyValue(name),
            value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
        return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
    };
}

function styleRemoveEnd(name) {
    return function () {
        this.style.removeProperty(name);
    };
}

function styleConstant$1(name, interpolate, value1) {
    var value00, interpolate0;
    return function () {
        var value0 = window$1(this).getComputedStyle(this, null).getPropertyValue(name);
        return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
    };
}

function styleFunction$1(name, interpolate, value) {
    var value00, value10, interpolate0;
    return function () {
        var style = window$1(this).getComputedStyle(this, null),
            value0 = style.getPropertyValue(name),
            value1 = value(this);
        if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
        return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
    };
}

var transition_style = function (name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
    return value == null ? this.styleTween(name, styleRemove$1(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction$1(name, i, tweenValue(this, "style." + name, value)) : styleConstant$1(name, i, value), priority);
};

function styleTween(name, value, priority) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

var transition_styleTween = function (name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
};

function textConstant$1(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

var transition_text = function (value) {
  return this.tween("text", typeof value === "function" ? textFunction$1(tweenValue(this, "text", value)) : textConstant$1(value == null ? "" : value + ""));
};

var transition_transition = function () {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$1(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
};

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var pi$2 = Math.PI;

var tau$2 = 2 * Math.PI;

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

var selection_transition = function (name) {
  var id, timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
};

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var constant$4 = function (x) {
  return function constant() {
    return x;
  };
};

var epsilon$2 = 1e-12;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var tau$3 = 2 * pi$3;

function arcInnerRadius$1(d) {
  return d.innerRadius;
}

function arcOuterRadius$1(d) {
  return d.outerRadius;
}

function arcStartAngle$1(d) {
  return d.startAngle;
}

function arcEndAngle$1(d) {
  return d.endAngle;
}

function arcPadAngle$1(d) {
  return d && d.padAngle; // Note: optional!
}

function asin$1(x) {
  return x >= 1 ? halfPi$2 : x <= -1 ? -halfPi$2 : Math.asin(x);
}

function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents$1(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc$1 = function () {
  var innerRadius = arcInnerRadius$1,
      outerRadius = arcOuterRadius$1,
      cornerRadius = constant$4(0),
      padRadius = null,
      startAngle = arcStartAngle$1,
      endAngle = arcEndAngle$1,
      padAngle = arcPadAngle$1,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$2,
        a1 = endAngle.apply(this, arguments) - halfPi$2,
        da = Math.abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$2)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$3 - epsilon$2) {
        context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$2) {
          context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > epsilon$2 && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)),
              rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$2) {
            var p0 = asin$1(rp / r0 * Math.sin(ap)),
                p1 = asin$1(rp / r1 * Math.sin(ap));
            if ((da0 -= p0 * 2) > epsilon$2) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$2) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * Math.cos(a01),
              y01 = r1 * Math.sin(a01),
              x10 = r0 * Math.cos(a10),
              y10 = r0 * Math.sin(a10);

          // Apply rounded corners?
          if (rc > epsilon$2) {
            var x11 = r1 * Math.cos(a11),
                y11 = r1 * Math.sin(a11),
                x00 = r0 * Math.cos(a00),
                y00 = r0 * Math.sin(a00);

            // Restrict the corner radius according to the sector angle.
            if (da < pi$3) {
              var oc = da0 > epsilon$2 ? intersect$1(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                  ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                  lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
              rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$2)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$2) {
              t0 = cornerTangents$1(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);

              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$2) || !(da0 > epsilon$2)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$2) {
              t0 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents$1(x01, y01, x00, y00, r0, -rc0, cw);

              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$3 / 2;
    return [Math.cos(a) * r, Math.sin(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$4(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$4(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$4(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
};

function Linear$1(context) {
  this._context = context;
}

Linear$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        this._context.lineTo(x, y);break;
    }
  }
};

var curveLinear$1 = function (context) {
  return new Linear$1(context);
};

function x$1(p) {
  return p[0];
}

function y$1(p) {
  return p[1];
}

var line$1 = function () {
  var x$$1 = x$1,
      y$$1 = y$1,
      defined = constant$4(true),
      context = null,
      curve = curveLinear$1,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$4(+_), line) : x$$1;
  };

  line.y = function (_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$4(+_), line) : y$$1;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area$1 = function () {
  var x0 = x$1,
      x1 = null,
      y0 = constant$4(0),
      y1 = y$1,
      defined = constant$4(true),
      context = null,
      curve = curveLinear$1,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line$1().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending$3 = function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity$3 = function (d) {
  return d;
};

var pie$1 = function () {
  var value = identity$3,
      sortValues = descending$3,
      sort = null,
      startAngle = constant$4(0),
      endAngle = constant$4(tau$3),
      padAngle = constant$4(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$3, Math.max(-tau$3, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$4(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear$1 = curveRadial$1(curveLinear$1);

function Radial$1(curve) {
  this._curve = curve;
}

Radial$1.prototype = {
  areaStart: function areaStart() {
    this._curve.areaStart();
  },
  areaEnd: function areaEnd() {
    this._curve.areaEnd();
  },
  lineStart: function lineStart() {
    this._curve.lineStart();
  },
  lineEnd: function lineEnd() {
    this._curve.lineEnd();
  },
  point: function point(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial$1(curve) {

  function radial(context) {
    return new Radial$1(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function radialLine$2(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c(curveRadial$1(_)) : c()._curve;
  };

  return l;
}

var radialLine$3 = function () {
  return radialLine$2(line$1().curve(curveRadialLinear$1));
};

var radialArea$1 = function () {
  var a = area$1().curve(curveRadialLinear$1),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return radialLine$2(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return radialLine$2(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return radialLine$2(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return radialLine$2(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c(curveRadial$1(_)) : c()._curve;
  };

  return a;
};

var circle$3 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / pi$3);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$3);
  }
};

var cross$2 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30$1 = Math.sqrt(1 / 3);
var tan30_2$1 = tan30$1 * 2;

var diamond$1 = {
  draw: function draw(context, size) {
    var y = Math.sqrt(size / tan30_2$1),
        x = y * tan30$1;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka$1 = 0.89081309152928522810;
var kr$1 = Math.sin(pi$3 / 10) / Math.sin(7 * pi$3 / 10);
var kx$1 = Math.sin(tau$3 / 10) * kr$1;
var ky$1 = -Math.cos(tau$3 / 10) * kr$1;

var star$1 = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size * ka$1),
            x = kx$1 * r,
            y = ky$1 * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
            var a = tau$3 * i / 5,
                c = Math.cos(a),
                s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
    }
};

var square$1 = {
  draw: function draw(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3$1 = Math.sqrt(3);

var triangle$1 = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3$1 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3$1 * y, -y);
    context.lineTo(sqrt3$1 * y, -y);
    context.closePath();
  }
};

var c$1 = -0.5;
var s$1 = Math.sqrt(3) / 2;
var k$1 = 1 / Math.sqrt(12);
var a$1 = (k$1 / 2 + 1) * 3;

var wye$1 = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size / a$1),
            x0 = r / 2,
            y0 = r * k$1,
            x1 = x0,
            y1 = r * k$1 + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c$1 * x0 - s$1 * y0, s$1 * x0 + c$1 * y0);
        context.lineTo(c$1 * x1 - s$1 * y1, s$1 * x1 + c$1 * y1);
        context.lineTo(c$1 * x2 - s$1 * y2, s$1 * x2 + c$1 * y2);
        context.lineTo(c$1 * x0 + s$1 * y0, c$1 * y0 - s$1 * x0);
        context.lineTo(c$1 * x1 + s$1 * y1, c$1 * y1 - s$1 * x1);
        context.lineTo(c$1 * x2 + s$1 * y2, c$1 * y2 - s$1 * x2);
        context.closePath();
    }
};

var symbols$1 = [circle$3, cross$2, diamond$1, square$1, star$1, triangle$1, wye$1];

var symbol$1 = function () {
  var type = constant$4(circle$3),
      size = constant$4(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$4(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$4(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop$2 = function () {};

function _point$4(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis$1(context) {
  this._context = context;
}

Basis$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 3:
        _point$4(this, this._x1, this._y1); // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default:
        _point$4(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis$3 = function (context) {
  return new Basis$1(context);
};

function BasisClosed$1(context) {
  this._context = context;
}

BasisClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x2 = x, this._y2 = y;break;
      case 1:
        this._point = 2;this._x3 = x, this._y3 = y;break;
      case 2:
        this._point = 3;this._x4 = x, this._y4 = y;this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);break;
      default:
        _point$4(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed$2 = function (context) {
  return new BasisClosed$1(context);
};

function BasisOpen$1(context) {
  this._context = context;
}

BasisOpen$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$4(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen$1 = function (context) {
  return new BasisOpen$1(context);
};

function Bundle$1(context, beta) {
  this._basis = new Basis$1(context);
  this._beta = beta;
}

Bundle$1.prototype = {
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle$1 = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis$1(context) : new Bundle$1(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function _point$5(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        _point$5(this, this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;this._x1 = x, this._y1 = y;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$5(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal$1 = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal$1(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$5(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed$1 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed$1(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen$1(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$5(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen$1 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen$1(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function _point$6(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$2) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        this.point(this._x2, this._y2);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$6(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom$1(context, alpha) : new Cardinal$1(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$6(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed$1 = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomClosed$1(context, alpha) : new CardinalClosed$1(context, 0);
  }

  catmullRom$$1.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function CatmullRomOpen$1(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$6(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen$1 = (function custom(alpha) {

  function catmullRom$$1(context) {
    return alpha ? new CatmullRomOpen$1(context, alpha) : new CardinalOpen$1(context, 0);
  }

  catmullRom$$1.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom$$1;
})(0.5);

function LinearClosed$1(context) {
  this._context = context;
}

LinearClosed$1.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._point) this._context.closePath();
  },
  point: function point(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

var linearClosed = function (context) {
  return new LinearClosed$1(context);
};

function sign$1(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3$1(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2$1(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function _point$7(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX$1(context) {
  this._context = context;
}

MonotoneX$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
      case 3:
        _point$7(this, this._t0, slope2$1(this, this._t0));break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;_point$7(this, slope2$1(this, t1 = slope3$1(this, x, y)), t1);break;
      default:
        _point$7(this, this._t0, t1 = slope3$1(this, x, y));break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY$1(context) {
  this._context = new ReflectContext$1(context);
}

(MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function (x, y) {
  MonotoneX$1.prototype.point.call(this, y, x);
};

function ReflectContext$1(context) {
  this._context = context;
}

ReflectContext$1.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX$1(context) {
  return new MonotoneX$1(context);
}

function monotoneY$1(context) {
  return new MonotoneY$1(context);
}

function Natural$1(context) {
  this._context = context;
}

Natural$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints$1(x),
            py = controlPoints$1(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints$1(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) {
    a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  }a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) {
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  }a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) {
    a[i] = (r[i] - a[i + 1]) / b[i];
  }b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) {
    b[i] = 2 * x[i + 1] - a[i + 1];
  }return [a, b];
}

var natural$1 = function (context) {
  return new Natural$1(context);
};

function Step$1(context, t) {
  this._context = context;
  this._t = t;
}

Step$1.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
    }
    this._x = x, this._y = y;
  }
};

var step$1 = function (context) {
  return new Step$1(context, 0.5);
};

function stepBefore$1(context) {
  return new Step$1(context, 0);
}

function stepAfter$1(context) {
  return new Step$1(context, 1);
}

var slice$2 = Array.prototype.slice;

var none$3 = function (series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (var j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$4 = function (series) {
  var n = series.length,
      o = new Array(n);
  while (--n >= 0) {
    o[n] = n;
  }return o;
};

function stackValue$1(d, key) {
  return d[key];
}

var stack$1 = function () {
  var keys = constant$4([]),
      order = none$4,
      offset = none$3,
      value = stackValue$1;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$4(slice$2.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$4(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? none$4 : typeof _ === "function" ? _ : constant$4(slice$2.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? none$3 : _, stack) : offset;
  };

  return stack;
};

var expand$1 = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }if (y) for (i = 0; i < n; ++i) {
      series[i][j][1] /= y;
    }
  }
  none$3(series, order);
};

var silhouette$1 = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }s0[j][1] += s0[j][0] = -y / 2;
  }
  none$3(series, order);
};

var wiggle$1 = function (series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$3(series, order);
};

var ascending$3 = function (series) {
  var sums = series.map(sum$2);
  return none$4(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
};

function sum$2(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;
  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }return s;
}

var descending$4 = function (series) {
  return ascending$3(series).reverse();
};

var insideOut$1 = function (series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = none$4(series).sort(function (a, b) {
    return sums[b] - sums[a];
  }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse$1 = function (series) {
  return none$4(series).reverse();
};



var d3Shape$1 = Object.freeze({
	arc: arc$1,
	area: area$1,
	line: line$1,
	pie: pie$1,
	radialArea: radialArea$1,
	radialLine: radialLine$3,
	symbol: symbol$1,
	symbols: symbols$1,
	symbolCircle: circle$3,
	symbolCross: cross$2,
	symbolDiamond: diamond$1,
	symbolSquare: square$1,
	symbolStar: star$1,
	symbolTriangle: triangle$1,
	symbolWye: wye$1,
	curveBasisClosed: basisClosed$2,
	curveBasisOpen: basisOpen$1,
	curveBasis: basis$3,
	curveBundle: bundle$1,
	curveCardinalClosed: cardinalClosed$1,
	curveCardinalOpen: cardinalOpen$1,
	curveCardinal: cardinal$1,
	curveCatmullRomClosed: catmullRomClosed$1,
	curveCatmullRomOpen: catmullRomOpen$1,
	curveCatmullRom: catmullRom,
	curveLinearClosed: linearClosed,
	curveLinear: curveLinear$1,
	curveMonotoneX: monotoneX$1,
	curveMonotoneY: monotoneY$1,
	curveNatural: natural$1,
	curveStep: step$1,
	curveStepAfter: stepAfter$1,
	curveStepBefore: stepBefore$1,
	stack: stack$1,
	stackOffsetExpand: expand$1,
	stackOffsetNone: none$3,
	stackOffsetSilhouette: silhouette$1,
	stackOffsetWiggle: wiggle$1,
	stackOrderAscending: ascending$3,
	stackOrderDescending: descending$4,
	stackOrderInsideOut: insideOut$1,
	stackOrderNone: none$4,
	stackOrderReverse: reverse$1
});

var prefix = "$";

function Map$1() {}

Map$1.prototype = map$1.prototype = {
  constructor: Map$1,
  has: function has(key) {
    return prefix + key in this;
  },
  get: function get(key) {
    return this[prefix + key];
  },
  set: function set(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function remove(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function clear() {
    for (var property in this) {
      if (property[0] === prefix) delete this[property];
    }
  },
  keys: function keys() {
    var keys = [];
    for (var property in this) {
      if (property[0] === prefix) keys.push(property.slice(1));
    }return keys;
  },
  values: function values() {
    var values = [];
    for (var property in this) {
      if (property[0] === prefix) values.push(this[property]);
    }return values;
  },
  entries: function entries() {
    var entries = [];
    for (var property in this) {
      if (property[0] === prefix) entries.push({ key: property.slice(1), value: this[property] });
    }return entries;
  },
  size: function size() {
    var size = 0;
    for (var property in this) {
      if (property[0] === prefix) ++size;
    }return size;
  },
  empty: function empty() {
    for (var property in this) {
      if (property[0] === prefix) return false;
    }return true;
  },
  each: function each(f) {
    for (var property in this) {
      if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  }
};

function map$1(object, f) {
  var map = new Map$1();

  // Copy constructor.
  if (object instanceof Map$1) object.each(function (value, key) {
    map.set(key, value);
  });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f(o = object[i], i, object), o);
      }
    }

    // Convert object to map.
    else if (object) for (var key in object) {
        map.set(key, object[key]);
      }return map;
}

var nest = function () {
  var keys = [],
      _sortKeys = [],
      _sortValues,
      _rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return _rollup != null ? _rollup(array) : _sortValues != null ? array.sort(_sortValues) : array;

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function _entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = _sortKeys[depth - 1];
    if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({ key: k, values: _entries(v, depth) });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function object(array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function map(array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function entries(array) {
      return _entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function key(d) {
      keys.push(d);return nest;
    },
    sortKeys: function sortKeys(order) {
      _sortKeys[keys.length - 1] = order;return nest;
    },
    sortValues: function sortValues(order) {
      _sortValues = order;return nest;
    },
    rollup: function rollup(f) {
      _rollup = f;return nest;
    }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set$1() {}

var proto = map$1.prototype;

Set$1.prototype = set$3.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function add(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set$3(object, f) {
  var set = new Set$1();

  // Copy constructor.
  if (object instanceof Set$1) object.each(function (value) {
    set.add(value);
  });

  // Otherwise, assume it’s an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) {
        set.add(object[i]);
      } else while (++i < n) {
        set.add(f(object[i], i, object));
      }
    }

  return set;
}

var array$2 = Array.prototype;

var map$3 = array$2.map;
var slice$3 = array$2.slice;

var implicit = { name: "implicit" };

function ordinal(range) {
  var index = map$1(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice$3.call(range);

  function scale(d) {
    var key = d + "",
        i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1,
        n = _.length,
        d,
        key;
    while (++i < n) {
      if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    }return scale;
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$3.call(_), scale) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return ordinal().domain(domain).range(range).unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function (_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function (_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function (_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range$$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point$1() {
  return pointish(band().paddingInner(1));
}

var constant$5 = function (x) {
  return function () {
    return x;
  };
};

var number$1 = function (x) {
  return +x;
};

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : constant$5(b);
}

function deinterpolateClamp(deinterpolate) {
  return function (a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function (x) {
      return x <= a ? 0 : x >= b ? 1 : d(x);
    };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function (a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function (t) {
      return t <= 0 ? a : t >= 1 ? b : r(t);
    };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function (x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate$$1 = interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function (y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function (_) {
    return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$3.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = slice$3.call(_), interpolate$$1 = interpolateRound, rescale();
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function (_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
var formatDecimal = function (x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i,
      coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
};

var exponent$1 = function (x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function (grouping, thousands) {
  return function (value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function (numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
};

var formatDefault = function (x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".":
        i0 = i1 = i;break;
      case "0":
        if (i0 === 0) i0 = i;i1 = i;break;
      case "e":
        break out;
      default:
        if (i0 > 0) i0 = 0;break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
};

var prefixExponent;

var formatPrefixAuto = function (x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function (x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "": formatDefault,
  "%": function _(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function b(x) {
    return Math.round(x).toString(2);
  },
  "c": function c(x) {
    return x + "";
  },
  "d": function d(x) {
    return Math.round(x).toString(10);
  },
  "e": function e(x, p) {
    return x.toExponential(p);
  },
  "f": function f(x, p) {
    return x.toFixed(p);
  },
  "g": function g(x, p) {
    return x.toPrecision(p);
  },
  "o": function o(x) {
    return Math.round(x).toString(8);
  },
  "p": function p(x, _p) {
    return formatRounded(x * 100, _p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function X(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function x(_x) {
    return Math.round(_x).toString(16);
  }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
};

var identity$5 = function (x) {
  return x;
};

var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

var formatLocale = function (locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$5,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$5,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);break;
        default:
          value = padding + valuePrefix + value + valueSuffix;break;
      }

      return numerals(value);
    }

    format.toString = function () {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale;
var format;
var formatPrefix;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

var precisionFixed = function (step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
};

var precisionPrefix = function (step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
};

var precisionRound = function (step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
};

var tickFormat = function (domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }
  return format(specifier);
};

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function (count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function (count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function (count) {
    var d = domain(),
        i = d.length - 1,
        n = count == null ? 10 : count,
        start = d[0],
        stop = d[i],
        step = tickStep(start, stop, n);

    if (step) {
      step = tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
      d[0] = Math.floor(start / step) * step;
      d[i] = Math.ceil(stop / step) * step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$2() {
  var scale = continuous(deinterpolateLinear, interpolateNumber);

  scale.copy = function () {
    return copy(scale, linear$2());
  };

  return linearish(scale);
}

function identity$4() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function (_) {
    return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();
  };

  scale.copy = function () {
    return identity$4().domain(domain);
  };

  return linearish(scale);
}

var nice = function (domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
};

function deinterpolate(a, b) {
  return (b = Math.log(b / a)) ? function (x) {
    return Math.log(x / a) / b;
  } : constant$5(b);
}

function reinterpolate(a, b) {
  return a < 0 ? function (t) {
    return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
  } : function (t) {
    return Math.pow(b, t) * Math.pow(a, 1 - t);
  };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}

function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}

function reflect(f) {
  return function (x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function (count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function (count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function () {
    return domain(nice(domain(), {
      floor: function floor(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function ceil(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };

  scale.copy = function () {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise$1(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent))) ? function (x) {
      return (raise$1(x, exponent) - a) / b;
    } : constant$5(b);
  }

  function reinterpolate(a, b) {
    b = raise$1(b, exponent) - (a = raise$1(a, exponent));
    return function (t) {
      return raise$1(a + b * t, 1 / exponent);
    };
  }

  scale.exponent = function (_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function () {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0,
        n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) {
      thresholds[i - 1] = quantile(domain, i / n);
    }return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[bisectRight(thresholds, x)];
  }

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) {
      if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    }domain.sort(ascending$1);
    return rescale();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$3.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function () {
    return thresholds.slice();
  };

  scale.copy = function () {
    return quantile$1().domain(domain).range(range);
  };

  return scale;
}

function quantize$1() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) {
      domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    }return scale;
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function (_) {
    return arguments.length ? (n = (range = slice$3.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return quantize$1().domain([x0, x1]).range(range);
  };

  return linearish(scale);
}

function threshold$2() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[bisectRight(domain, x, 0, n)];
  }

  scale.domain = function (_) {
    return arguments.length ? (domain = slice$3.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = slice$3.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return threshold$2().domain(domain).range(range);
  };

  return scale;
}

var t0$1 = new Date();
var t1$1 = new Date();

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do {
      range.push(new Date(+start));
    } while ((offseti(start, step), floori(start), start < stop));
    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) {
        date.setTime(date - 1);
      }
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}

var millisecond = newInterval(function () {
  // noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};

var durationSecond$1 = 1e3;
var durationMinute$1 = 6e4;
var durationHour$1 = 36e5;
var durationDay$1 = 864e5;
var durationWeek$1 = 6048e5;

var second = newInterval(function (date) {
  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);
}, function (date, step) {
  date.setTime(+date + step * durationSecond$1);
}, function (start, end) {
  return (end - start) / durationSecond$1;
}, function (date) {
  return date.getUTCSeconds();
});

var minute = newInterval(function (date) {
  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);
}, function (date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function (start, end) {
  return (end - start) / durationMinute$1;
}, function (date) {
  return date.getMinutes();
});

var hour = newInterval(function (date) {
  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;
  if (offset < 0) offset += durationHour$1;
  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);
}, function (date, step) {
  date.setTime(+date + step * durationHour$1);
}, function (start, end) {
  return (end - start) / durationHour$1;
}, function (date) {
  return date.getHours();
});

var day = newInterval(function (date) {
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
}, function (date) {
  return date.getDate() - 1;
});

function weekday(i) {
  return newInterval(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var month = newInterval(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});

var year = newInterval(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var utcMinute = newInterval(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function (start, end) {
  return (end - start) / durationMinute$1;
}, function (date) {
  return date.getUTCMinutes();
});

var utcHour = newInterval(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationHour$1);
}, function (start, end) {
  return (end - start) / durationHour$1;
}, function (date) {
  return date.getUTCHours();
});

var utcDay = newInterval(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / durationDay$1;
}, function (date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / durationWeek$1;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcMonth = newInterval(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});

var utcYear = newInterval(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return { y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 };
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function (string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function format(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function () {
        return specifier;
      };
      return f;
    },
    parse: function parse(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function () {
        return specifier;
      };
      return p;
    },
    utcFormat: function utcFormat(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function () {
        return specifier;
      };
      return f;
    },
    utcParse: function utcParse(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function () {
        return specifier;
      };
      return p;
    }
  };
}

var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {},
      i = -1,
      n = names.length;
  while (++i < n) {
    map[names[i].toLowerCase()] = i;
  }return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

var locale$1;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  timeParse = locale$1.parse;
  utcFormat = locale$1.utcFormat;
  utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
    return date.toISOString();
}

var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date$1(t) {
  return new Date(t);
}

function number$2(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
  var scale = continuous(deinterpolateLinear, interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [[second$$1, 1, durationSecond], [second$$1, 5, 5 * durationSecond], [second$$1, 15, 15 * durationSecond], [second$$1, 30, 30 * durationSecond], [minute$$1, 1, durationMinute], [minute$$1, 5, 5 * durationMinute], [minute$$1, 15, 15 * durationMinute], [minute$$1, 30, 30 * durationMinute], [hour$$1, 1, durationHour], [hour$$1, 3, 3 * durationHour], [hour$$1, 6, 6 * durationHour], [hour$$1, 12, 12 * durationHour], [day$$1, 1, durationDay], [day$$1, 2, 2 * durationDay], [week, 1, durationWeek], [month$$1, 1, durationMonth], [month$$1, 3, 3 * durationMonth], [year$$1, 1, durationYear]];

  function tickFormat(date) {
    return (second$$1(date) < date ? formatMillisecond : minute$$1(date) < date ? formatSecond : hour$$1(date) < date ? formatMinute : day$$1(date) < date ? formatHour : month$$1(date) < date ? week(date) < date ? formatDay : formatWeek : year$$1(date) < date ? formatMonth : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function (i) {
        return i[2];
      }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year$$1;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = tickStep(start, stop, interval);
        interval = millisecond$$1;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function (y) {
    return new Date(invert(y));
  };

  scale.domain = function (_) {
    return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);
  };

  scale.ticks = function (interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function (interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function () {
    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
  };

  return scale;
}

var time = function () {
  return calendar(year, month, sunday, day, hour, minute, second, millisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
};

var utcTime = function () {
  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
};

var colors = function (s) {
  return s.match(/.{6}/g).map(function (x) {
    return "#" + x;
  });
};

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix();

var rainbow$1 = function (t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
};

function ramp(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function () {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}



var d3Scale = Object.freeze({
	scaleBand: band,
	scalePoint: point$1,
	scaleIdentity: identity$4,
	scaleLinear: linear$2,
	scaleLog: log,
	scaleOrdinal: ordinal,
	scaleImplicit: implicit,
	scalePow: pow,
	scaleSqrt: sqrt,
	scaleQuantile: quantile$1,
	scaleQuantize: quantize$1,
	scaleThreshold: threshold$2,
	scaleTime: time,
	scaleUtc: utcTime,
	schemeCategory10: category10,
	schemeCategory20b: category20b,
	schemeCategory20c: category20c,
	schemeCategory20: category20,
	interpolateCubehelixDefault: cubehelix$3,
	interpolateRainbow: rainbow$1,
	interpolateWarm: warm,
	interpolateCool: cool,
	interpolateViridis: viridis,
	interpolateMagma: magma,
	interpolateInferno: inferno,
	interpolatePlasma: plasma,
	scaleSequential: sequential
});

var drawing = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof$$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  };

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  exports.areaLineGenerator = areaLineGenerator;
  exports.areaLine = areaLine;
  exports.verticalbar = verticalbar;
  exports.horizontalbar = horizontalbar;
  exports.pathStr = pathStr;
  exports.circlePath = circlePath;
  exports.rectPath = rectPath;
  exports.linePath = linePath;
  exports.jitterLine = jitterLine;
  exports.cheapSketchy = cheapSketchy;
  exports.cheapPopArtsy = cheapPopArtsy;
  exports.randomColor = randomColor;
  exports.painty = painty;
  exports.sketchy = sketchy;
  exports.generateSVG = generateSVG;

  var _react2 = _interopRequireDefault(React);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  //All generic line constructors expect a projected coordinates array with x & y coordinates, if there are no y1 & x1 coordinates then it defaults to 0-width
  function roundToTenth(number) {
    return Math.round(number * 10) / 10;
  }

  function areaLineGenerator(customAccessors, interpolator) {
    var lineGenerator = (0, d3Shape$1.area)().x0(customAccessors.x).y0(customAccessors.y).x1(customAccessors.x1).y1(customAccessors.y1).interpolate(interpolator || "linear");
    return lineGenerator;
  }

  function areaLine(props) {
    var lineGenerator = areaLineGenerator(props.customAccessors, props.interpolate);
    props.d = lineGenerator(props.coordinates);

    return props;
  }

  function verticalbar(props) {
    props.y = props.y - props.height;
    return props;
  }

  function horizontalbar(props) {
    //just flips height for width
    var originalHeight = props.height;
    var originalWidth = props.width;
    props.width = originalHeight;
    props.height = originalWidth;

    return props;
  }

  function pathStr(_ref) {
    var x = _ref.x,
        y = _ref.y,
        width = _ref.width,
        height = _ref.height,
        cx = _ref.cx,
        cy = _ref.cy,
        r = _ref.r;

    if (cx !== undefined) {
      return ["M", roundToTenth(cx - r), roundToTenth(cy), "a", r, r, 0, 1, 0, r * 2, 0, "a", r, r, 0, 1, 0, -(r * 2), 0].join(" ") + "Z";
    }
    return ["M", roundToTenth(x), roundToTenth(y), "h", width, "v", height, "h", -width, "v", -height].join(" ") + "Z";
  }

  function circlePath(cx, cy, r) {
    return pathStr({ cx: cx, cy: cy, r: r });
  }

  function rectPath(x, y, width, height) {
    return pathStr({ x: x, y: y, width: width, height: height });
  }

  function linePath(x1, x2, y1, y2) {
    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "L";
  }

  function jitterLine(pathNode) {
    var length = pathNode.getTotalLength();
    var j = 2;
    var x = j + Math.random() * j * 5;
    var jitteredPoints = [];
    var lineGen = (0, d3Shape$1.line)().x(function (d) {
      return d.x;
    }).y(function (d) {
      return d.y;
    }).curve(d3Shape$1.curveBasis);

    var newPoint = pathNode.getPointAtLength(0);
    jitteredPoints.push(newPoint);

    while (x < length) {
      newPoint = pathNode.getPointAtLength(x);
      var newX = newPoint.x + (Math.random() * j - j / 2);
      var newY = newPoint.y + (Math.random() * j - j / 2);
      jitteredPoints.push({ x: newX, y: newY });
      x += j + Math.random() * j * 5;
    }
    newPoint = pathNode.getPointAtLength(length);
    jitteredPoints.push(newPoint);

    return lineGen(jitteredPoints);
  }

  function cheapSketchy(path) {
    var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    if (opacity === 0) {
      //no fill
      return "";
    }
    var opacitySketchyScale = (0, d3Scale.scaleLinear)().domain([0, 1]).range([10, 1]).clamp(true);
    var length = path.getTotalLength();
    var drawCode = "";
    var x = 0;
    var step = opacitySketchyScale(opacity);

    while (x < length / 2) {
      var start = path.getPointAtLength(x);
      var end = path.getPointAtLength(length - x);

      drawCode += " M" + (start.x + (Math.random() * step - step / 2)) + " " + (start.y + (Math.random() * step - step / 2)) + "L" + (end.x + (Math.random() * step - step / 2)) + " " + (end.y + (Math.random() * step - step / 2));

      x += step + Math.random() * step;
    }

    return drawCode;
  }

  function cheapPopArtsy(path, size) {
    var length = path.getTotalLength();
    var circles = [];
    var x = 0;
    var step = size * 3;

    while (x < length / 2) {
      var start = path.getPointAtLength(x);
      var end = path.getPointAtLength(length - x);
      var distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
      var begin = size / 2;
      while (begin < distance - size / 2) {
        var percent = begin / distance;
        var circleXa = percent * start.x;
        var circleXb = (1 - percent) * end.x;
        var circleYa = percent * start.y;
        var circleYb = (1 - percent) * end.y;
        circles.push([circleXa + circleXb, circleYa + circleYb]);
        begin = begin + (step + Math.random());
      }
      x = x + step;
    }

    return circles;
  }

  function randomColor(baseColor, range) {
    var hslBase = (0, d3Color.hsl)(baseColor);
    hslBase.h = hslBase.h + (Math.floor(Math.random() * (range * 255)) - Math.floor(range / 2));
    hslBase.s = hslBase.s + (Math.floor(Math.random() * range) - Math.floor(range / 2));
    hslBase.l = hslBase.l + (Math.floor(Math.random() * range) - Math.floor(range / 2));
    return hslBase.toString();
  }

  function painty(markType, cloneProps) {
    delete cloneProps.markType;
    if ((markType === "path" || markType === "circle" || markType === "line" || markType === "rect") && cloneProps.style && (cloneProps.style.stroke || cloneProps.style.fill)) {
      if (markType === "circle") {
        cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
      }

      if (markType === "rect") {
        cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
      }

      if (markType === "line") {
        cloneProps.d = linePath(cloneProps.x1, cloneProps.x2, cloneProps.y1, cloneProps.y2);
      }

      (0, d3Selection.select)("body").append("svg").attr("id", "sketchyTempSVG");

      var fills = [];
      var outlines = [];

      cloneProps.d.split("M").filter(function (d, i) {
        return i !== 0;
      }).forEach(function (pathD, i) {
        var pathDummy = (0, d3Selection.select)("#sketchyTempSVG").append("path").attr("class", cloneProps.className).attr("d", "M" + pathD);

        var pathNode = pathDummy.node();

        if (cloneProps.style && cloneProps.style.fill !== "none") {
          var sketchyFill = cheapPopArtsy(pathNode, 4);
          var fillProps = _extends$$1({}, cloneProps);
          var fillStyle = _extends$$1({}, cloneProps.style);
          var fillValue = fillStyle.fill;
          fillProps.style = fillStyle;
          delete fillProps.d;
          delete fillProps.style.fillOpacity;
          delete fillProps.style.stroke;
          delete fillProps.style.strokeWidth;

          fills.push(sketchyFill.map(function (circle, ci) {
            fillProps.key = "painty-fill-" + i + "-" + ci;
            fillProps.cx = circle[0];
            fillProps.cy = circle[1];
            fillProps.style = _extends$$1({}, fillProps.style);
            fillProps.style.fill = fillProps.style.fill.substr(0, 3) === "url" ? fillProps.style.fill : randomColor(fillValue, 0.05);
            fillProps.r = Math.random() * 2 + 3;
            return _react2.default.createElement("circle", fillProps);
          }));
        }

        if (cloneProps.style && cloneProps.style.stroke !== "none" && cloneProps.style.strokeWidth !== 0) {
          var sketchyOutline = jitterLine(pathNode);

          var outlineProps = _extends$$1({}, cloneProps);
          var outlineStyle = _extends$$1({}, cloneProps.style);
          outlineProps.style = outlineStyle;
          outlineProps.d = sketchyOutline;
          outlineProps.key = "painty-outline-" + i;
          outlineProps.style.fill = "none";

          outlines.push(_react2.default.createElement("path", outlineProps));
        }
      });

      (0, d3Selection.select)("#sketchyTempSVG").remove();

      return [_react2.default.createElement("path", {
        key: "painty-interaction-overlay",
        d: cloneProps.d,
        style: { opacity: 0 }
      }), _react2.default.createElement("g", { key: "painty-fill", style: { filter: "url(#paintyFilterHeavy)" } }, fills), outlines];
    }

    return _react2.default.createElement(markType, cloneProps);
  }

  function sketchy(markType, cloneProps) {
    delete cloneProps.markType;
    if (markType === "text" && _typeof$$1(cloneProps.children) !== "object") {
      var stringyChild = cloneProps.children.toString();
      var x = 0;
      var sketchyText = [];
      var sketchyBase = [];
      while (x <= stringyChild.length + 1) {
        var random = parseInt(Math.random() * 2) + 1;
        var randomSub = stringyChild.substring(x, random + x);

        var randomTspan = _react2.default.createElement("tspan", {
          style: {
            fontSize: 10 + parseInt(Math.random() * 6) + "px",
            strokeWidth: 0,
            fontWeight: Math.random() < 0.5 ? "900" : "100"
          }
        }, randomSub);
        sketchyBase.push(randomSub);
        sketchyText.push(randomTspan);
        x += random;
      }

      cloneProps.children = sketchyText;
      return _react2.default.createElement("text", cloneProps);
    }

    if ((markType === "path" || markType === "circle" || markType === "line" || markType === "rect") && cloneProps.style && (cloneProps.style.stroke || cloneProps.style.fill)) {
      if (markType === "circle") {
        cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
      }

      if (markType === "rect") {
        cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
      }

      if (markType === "line") {
        cloneProps.d = linePath(cloneProps.x1, cloneProps.x2, cloneProps.y1, cloneProps.y2);
      }
      var fills = [];
      var outlines = [];
      var sketchKey = Math.random().toString();

      if (cloneProps.d) {
        (0, d3Selection.select)("body").append("svg").attr("id", "sketchyTempSVG");

        var mType = cloneProps.d.substring(0, 1) === "M" ? "M" : "m";

        cloneProps.d.split(mType).filter(function (d, i) {
          return i !== 0;
        }).forEach(function (pathD, i) {
          var pathDummy = (0, d3Selection.select)("#sketchyTempSVG").append("path").attr("class", cloneProps.className).attr("d", "" + mType + pathD);

          var pathNode = pathDummy.node();
          if (cloneProps.style && cloneProps.style.fill !== "none") {
            var fillProps = _extends$$1({}, cloneProps);
            var fillStyle = _extends$$1({}, cloneProps.style);
            var sketchyFill = cheapSketchy(pathNode, fillStyle.fillOpacity);
            if (markType !== "rect" && markType !== "circle") {
              fillStyle.clipPath = "url(#clip-path-" + sketchKey + ")";
            }
            fillProps.style = fillStyle;
            fillProps.d = sketchyFill;
            fillStyle.stroke = fillStyle.fill;
            fillStyle.strokeWidth = "1px";
            //            fillStyle.strokeOpacity = fillStyle.fillOpacity ? fillStyle.fillOpacity : 1;
            fillStyle.fill = "none";
            fillProps.key = "sketchFill-" + i;
            fills.push(_react2.default.createElement("path", fillProps));
          }
          if (cloneProps.style && cloneProps.style.stroke !== "none" && cloneProps.style.strokeWidth !== 0) {
            var sketchyOutline = jitterLine(pathNode);

            var outlineProps = _extends$$1({}, cloneProps);
            var outlineStyle = _extends$$1({}, cloneProps.style);
            outlineProps.style = outlineStyle;
            outlineProps.d = sketchyOutline;
            outlineProps.key = "sketchOutline-" + i;
            outlineProps.style.fill = "none";
            outlines.push(_react2.default.createElement("path", outlineProps));
          }
        });
      }

      (0, d3Selection.select)("#sketchyTempSVG").remove();
      var generatedClipPath = void 0;
      if (markType !== "rect" && markType !== "circle") {
        generatedClipPath = _react2.default.createElement("clipPath", { key: "sketchy-clip-overlay", id: "clip-path-" + sketchKey }, _react2.default.createElement("path", { d: cloneProps.d, style: { opacity: 0 } }));
      }

      return [generatedClipPath, _react2.default.createElement("path", {
        key: "sketchy-interaction-overlay",
        d: cloneProps.d,
        style: { opacity: 0 }
      }), fills, outlines];
    }

    return _react2.default.createElement(markType, cloneProps);
  }

  function generateSVG(props, className) {
    var markType = props.markType;
    var renderMode = props.renderMode;

    var cloneProps = _extends$$1({}, props);
    delete cloneProps.markType;
    delete cloneProps.renderMode;
    delete cloneProps.resetAfter;
    delete cloneProps.droppable;
    delete cloneProps.nid;
    delete cloneProps.dropFunction;
    delete cloneProps.context;
    delete cloneProps.updateContext;
    delete cloneProps.parameters;
    delete cloneProps.lineDataAccessor;
    delete cloneProps.customAccessors;
    delete cloneProps.interpolate;
    delete cloneProps.forceUpdate;
    delete cloneProps.searchIterations;
    delete cloneProps.simpleInterpolate;
    delete cloneProps.transitionDuration;

    if (markType === "verticalbar") {
      markType = "rect";
      cloneProps = verticalbar(cloneProps);
    } else if (markType === "horizontalbar") {
      markType = "rect";
      cloneProps = horizontalbar(cloneProps);
    } else if (markType === "simpleline") {
      markType = "path";
      cloneProps = areaLine(cloneProps);
    }

    //        let transform = cloneProps['transform'];
    if (props.draggable) {
      delete cloneProps.transform;
    }

    cloneProps.className = className;

    var actualSVG = null;

    if (renderMode === "sketchy") {
      actualSVG = sketchy(markType, cloneProps);
    } else if (renderMode === "painty") {
      actualSVG = painty(markType, cloneProps);
    } else if (renderMode === "forcePath" && markType === "circle") {
      cloneProps.d = circlePath(cloneProps.cx || 0, cloneProps.cy || 0, cloneProps.r);
      markType = "path";
      actualSVG = _react2.default.createElement(markType, cloneProps);
    } else if (renderMode === "forcePath" && markType === "rect") {
      cloneProps.d = rectPath(cloneProps.x || 0, cloneProps.y || 0, cloneProps.width, cloneProps.height);
      markType = "path";
      actualSVG = _react2.default.createElement(markType, cloneProps);
    } else {
      if (props.markType === "text" && _typeof$$1(cloneProps.children) !== "object") {
        cloneProps.children = _react2.default.createElement("tspan", null, cloneProps.children);
      }
      actualSVG = _react2.default.createElement(markType, cloneProps);
    }
    return actualSVG;
  }
});

unwrapExports(drawing);
var drawing_1 = drawing.areaLineGenerator;
var drawing_2 = drawing.areaLine;
var drawing_3 = drawing.verticalbar;
var drawing_4 = drawing.horizontalbar;
var drawing_5 = drawing.pathStr;
var drawing_6 = drawing.circlePath;
var drawing_7 = drawing.rectPath;
var drawing_8 = drawing.linePath;
var drawing_9 = drawing.jitterLine;
var drawing_10 = drawing.cheapSketchy;
var drawing_11 = drawing.cheapPopArtsy;
var drawing_12 = drawing.randomColor;
var drawing_13 = drawing.painty;
var drawing_14 = drawing.sketchy;
var drawing_15 = drawing.generateSVG;

var markTransition = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var styleTransitionWhitelist = exports.styleTransitionWhitelist = ["strokeOpacity", "fillOpacity", "strokeWidth", "fill", "stroke", "opacity", "strokeDasharray"];

  var attributeTransitionWhitelist = exports.attributeTransitionWhitelist = ["d", "height", "width", "transform", "x", "y", "cx", "cy", "x1", "x2", "y1", "y2", "rx", "ry", "r"].concat(styleTransitionWhitelist);

  //TODO find React Everything to everything translater
  var reactCSSNameStyleHash = exports.reactCSSNameStyleHash = {
    strokeWidth: "stroke-width",
    fillOpacity: "fill-opacity",
    strokeOpacity: "stroke-opacity",
    strokeDasharray: "stroke-dasharray"
  };

  var differentD = exports.differentD = function differentD(d, newD) {
    if (!d || !newD) {
      return true;
    }
    var lowerD = d.toLowerCase();
    var lowerNewD = newD.toLowerCase();

    if ((lowerD.match(/m/g) || []).length !== (lowerNewD.match(/m/g) || []).length) {
      return true;
    }

    if ((lowerD.match(/l/g) || []).length !== (lowerNewD.match(/l/g) || []).length) {
      return true;
    }

    if ((lowerD.match(/c/g) || []).length !== (lowerNewD.match(/c/g) || []).length) {
      return true;
    }

    if ((lowerD.match(/a/g) || []).length !== (lowerNewD.match(/a/g) || []).length) {
      return true;
    }

    return false;
  };
});

unwrapExports(markTransition);
var markTransition_1 = markTransition.styleTransitionWhitelist;
var markTransition_2 = markTransition.attributeTransitionWhitelist;
var markTransition_3 = markTransition.reactCSSNameStyleHash;
var markTransition_4 = markTransition.differentD;

var Mark_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var Mark = function (_React$Component) {
    _inherits(Mark, _React$Component);

    function Mark(props) {
      _classCallCheck(this, Mark);

      var _this = _possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).call(this, props));

      _this._mouseup = _this._mouseup.bind(_this);
      _this._mousedown = _this._mousedown.bind(_this);
      _this._mousemove = _this._mousemove.bind(_this);

      _this.state = {
        translate: [0, 0],
        mouseOrigin: [],
        translateOrigin: [0, 0],
        dragging: false,
        uiUpdate: false
      };
      return _this;
    }

    _createClass(Mark, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        //data-driven transition time?
        if (this.props.markType !== nextProps.markType || this.state.dragging || this.props.forceUpdate || nextProps.forceUpdate || this.props.renderMode !== nextProps.renderMode || this.props.className !== nextProps.className || this.props.children !== nextProps.children) {
          return true;
        }

        var canvas = this.props.canvas !== true && this.props.canvas || this.context && this.context.canvas;

        var node = this.node;

        var actualSVG = (0, drawing.generateSVG)(nextProps, nextProps.className);
        var cloneProps = actualSVG.props;

        if (!cloneProps) {
          return true;
        }

        var _nextProps$transition = nextProps.transitionDuration,
            transitionDuration = _nextProps$transition === undefined ? {} : _nextProps$transition;

        var isDefault = typeof transitionDuration === "number";
        var defaultDuration = isDefault ? transitionDuration : 1000;
        transitionDuration = isDefault ? { default: defaultDuration } : _extends$$1({ default: defaultDuration }, transitionDuration);

        markTransition.attributeTransitionWhitelist.forEach(function (attr) {
          if ((0, d3Selection.select)(node).select("*").transition) {
            if (attr === "d" && (0, markTransition.differentD)(cloneProps.d, this.props.d)) {
              (0, d3Selection.select)(node).select("*").attr("d", cloneProps.d);
            } else if (cloneProps[attr] !== this.props[attr]) {
              if (markTransition.reactCSSNameStyleHash[attr]) {
                attr = markTransition.reactCSSNameStyleHash[attr];
              }

              var _transitionDuration = transitionDuration,
                  defaultDur = _transitionDuration.default,
                  _transitionDuration$a = _transitionDuration[attr],
                  appliedDuration = _transitionDuration$a === undefined ? defaultDur : _transitionDuration$a;

              (0, d3Selection.select)(node).select("*").transition(attr).duration(appliedDuration).attr(attr, cloneProps[attr]);
            }
          }
        }, this);

        if (cloneProps.style) {
          markTransition.attributeTransitionWhitelist.forEach(function (style) {
            if (cloneProps.style[style] !== this.props.style[style]) {
              var nextValue = cloneProps.style[style];

              if (markTransition.reactCSSNameStyleHash[style]) {
                style = markTransition.reactCSSNameStyleHash[style];
              }

              if ((0, d3Selection.select)(node).select("*").transition) {
                var _transitionDuration2 = transitionDuration,
                    defaultDur = _transitionDuration2.default,
                    _transitionDuration2$ = _transitionDuration2[style],
                    appliedDuration = _transitionDuration2$ === undefined ? defaultDur : _transitionDuration2$;

                (0, d3Selection.select)(node).select("*").transition(style).duration(appliedDuration).style(style, nextValue);
              } else {
                (0, d3Selection.select)(node).select("*").style(style, nextValue);
              }
            }
          }, this);
        }

        return false;
      }
    }, {
      key: "_mouseup",
      value: function _mouseup() {
        document.onmousemove = null;

        var finalTranslate = [0, 0];
        if (!this.props.resetAfter) finalTranslate = this.state.translate;

        this.setState({
          dragging: false,
          translate: finalTranslate,
          uiUpdate: false
        });
        if (this.props.dropFunction && this.props.context && this.props.context.dragSource) {
          this.props.dropFunction(this.props.context.dragSource.props, this.props);
          this.props.updateContext("dragSource", undefined);
        }
      }
    }, {
      key: "_mousedown",
      value: function _mousedown(event) {
        this.setState({
          mouseOrigin: [event.pageX, event.pageY],
          translateOrigin: this.state.translate,
          dragging: true
        });
        document.onmouseup = this._mouseup;
        document.onmousemove = this._mousemove;
      }
    }, {
      key: "_mousemove",
      value: function _mousemove(event) {
        var xAdjust = this.props.freezeX ? 0 : 1;
        var yAdjust = this.props.freezeY ? 0 : 1;

        var adjustedPosition = [event.pageX - this.state.mouseOrigin[0], event.pageY - this.state.mouseOrigin[1]];
        var adjustedTranslate = [(adjustedPosition[0] + this.state.translateOrigin[0]) * xAdjust, (adjustedPosition[1] + this.state.translateOrigin[1]) * yAdjust];
        if (this.props.dropFunction && this.state.uiUpdate === false) {
          this.props.updateContext("dragSource", this);
          this.setState({
            translate: adjustedTranslate,
            uiUpdate: true,
            dragging: true
          });
        } else {
          this.setState({ translate: adjustedTranslate });
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var className = this.props.className || "";

        var mouseIn = null;
        var mouseOut = null;

        var actualSVG = (0, drawing.generateSVG)(this.props, className);

        if (this.props.draggable) {
          return _react2.default.createElement("g", {
            ref: function ref(node) {
              return _this2.node = node;
            },
            className: className,
            onMouseEnter: mouseIn,
            onMouseOut: mouseOut,
            onDoubleClick: this._doubleclick,
            style: {
              pointerEvents: this.props.dropFunction && this.state.dragging ? "none" : "all"
            },
            onMouseDown: this._mousedown,
            onMouseUp: this._mouseup,
            transform: "translate(" + this.state.translate + ")"
          }, actualSVG);
        } else {
          return _react2.default.createElement("g", {
            ref: function ref(node) {
              return _this2.node = node;
            },
            className: className,
            onMouseEnter: mouseIn,
            onMouseOut: mouseOut
          }, actualSVG);
        }
      }
    }]);

    return Mark;
  }(_react2.default.Component);

  Mark.propTypes = {
    markType: _propTypes2.default.string.isRequired,
    forceUpdate: _propTypes2.default.bool,
    renderMode: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    draggable: _propTypes2.default.bool,
    dropFunction: _propTypes2.default.func,
    resetAfter: _propTypes2.default.bool,
    freezeX: _propTypes2.default.bool,
    freezeY: _propTypes2.default.bool,
    context: _propTypes2.default.object,
    updateContext: _propTypes2.default.func,
    className: _propTypes2.default.string
  };

  Mark.contextTypes = {
    canvas: _propTypes2.default.object
  };

  exports.default = Mark;
  module.exports = exports['default'];
});

unwrapExports(Mark_1);

var DraggableMark_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _extends$$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }return target;
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _Mark2 = _interopRequireDefault(Mark_1);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var DraggableMark = function (_React$Component) {
    _inherits(DraggableMark, _React$Component);

    function DraggableMark() {
      _classCallCheck(this, DraggableMark);

      return _possibleConstructorReturn(this, (DraggableMark.__proto__ || Object.getPrototypeOf(DraggableMark)).apply(this, arguments));
    }

    _createClass(DraggableMark, [{
      key: "render",
      value: function render() {
        return _react2.default.createElement(_Mark2.default, _extends$$1({
          draggable: true,
          resetAfter: true,
          droppable: true
        }, this.props));
      }
    }]);

    return DraggableMark;
  }(_react2.default.Component);

  DraggableMark.propTypes = {
    draggable: _propTypes2.default.bool,
    resetAfter: _propTypes2.default.bool,
    droppable: _propTypes2.default.bool
  };

  exports.default = DraggableMark;
  module.exports = exports['default'];
});

unwrapExports(DraggableMark_1);

var MarkContext_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _typeof$$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  };

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _react2 = _interopRequireDefault(React);

  var _propTypes2 = _interopRequireDefault(propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  // components

  var MarkContext = function (_React$Component) {
    _inherits(MarkContext, _React$Component);

    function MarkContext(props) {
      _classCallCheck(this, MarkContext);

      var _this = _possibleConstructorReturn(this, (MarkContext.__proto__ || Object.getPrototypeOf(MarkContext)).call(this, props));

      _this.mapElements = _this.mapElements.bind(_this);
      _this.shouldComponentUpdate = _this.shouldComponentUpdate.bind(_this);
      _this.updateContext = _this.updateContext.bind(_this);
      _this.state = { context: {} };
      return _this;
    }

    _createClass(MarkContext, [{
      key: "mapElements",
      value: function mapElements(element, ei) {
        if (!element) return null;

        var props = {
          key: "mc-mark-" + ei
        };

        if (typeof element.type !== "string") {
          props.context = this.state.context;
          props.updateContext = this.updateContext;
        }
        if (Array.isArray(element)) return element.map(this.mapElements);

        return _react2.default.cloneElement(element, props);
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps) {
        if (this.props.xyFrameChildren && this.props.renderNumber === nextProps.renderNumber) {
          return false;
        }
        return true;
      }
    }, {
      key: "updateContext",
      value: function updateContext(prop, value) {
        var currentContext = this.state.context;
        currentContext[prop] = value;
        this.setState({ context: currentContext });
      }
    }, {
      key: "render",
      value: function render() {
        var elements = null;

        if (Array.isArray(this.props.children)) elements = this.props.children.map(this.mapElements);else if (_typeof$$1(this.props.children) === "object") elements = this.mapElements(this.props.children);

        var transform = [0, 0];

        transform[0] = this.props.position ? this.props.position[0] : 0;
        transform[1] = this.props.position ? this.props.position[1] : 0;

        return _react2.default.createElement("g", { transform: "translate(" + transform.toString() + ")" }, elements);
      }
    }]);

    return MarkContext;
  }(_react2.default.Component);

  MarkContext.propTypes = {
    position: _propTypes2.default.array,
    xyFrameChildren: _propTypes2.default.bool,
    renderNumber: _propTypes2.default.number
  };
  exports.default = MarkContext;
  module.exports = exports['default'];
});

unwrapExports(MarkContext_1);

var lib$1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MarkContext = exports.Mark = exports.DraggableMark = undefined;

  var _Mark2 = _interopRequireDefault(Mark_1);

  var _DraggableMark2 = _interopRequireDefault(DraggableMark_1);

  var _MarkContext2 = _interopRequireDefault(MarkContext_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  exports.default = {
    DraggableMark: _DraggableMark2.default,
    Mark: _Mark2.default,
    MarkContext: _MarkContext2.default
  };
  exports.DraggableMark = _DraggableMark2.default;
  exports.Mark = _Mark2.default;
  exports.MarkContext = _MarkContext2.default;
});

unwrapExports(lib$1);
var lib_1$1 = lib$1.MarkContext;
var lib_2$1 = lib$1.Mark;
var lib_3$1 = lib$1.DraggableMark;

// components

var DividedLine = function (_React$Component) {
  inherits(DividedLine, _React$Component);

  function DividedLine(props) {
    classCallCheck(this, DividedLine);

    var _this = possibleConstructorReturn(this, (DividedLine.__proto__ || Object.getPrototypeOf(DividedLine)).call(this, props));

    _this.createLineSegments = _this.createLineSegments.bind(_this);
    return _this;
  }

  createClass(DividedLine, [{
    key: "createLineSegments",
    value: function createLineSegments() {
      var _this2 = this;

      var params = this.props.parameters;
      var className = this.props.className;
      var interpolate = this.props.interpolate || curveLinear;

      var data = projectLineData({
        data: this.props.data,
        lineDataAccessor: this.props.lineDataAccessor,
        xProp: "_x",
        yProp: "_y",
        xAccessor: this.props.customAccessors.x,
        yAccessor: this.props.customAccessors.y
      });

      //Compatibility before Semiotic 2
      data.forEach(function (projectedD) {
        projectedD.data = projectedD.data.map(function (d) {
          return _extends({}, d.data, d);
        });
      });

      var lines = dividedLine(params, data[0].data, this.props.searchIterations);

      var lineRender = line().curve(interpolate).x(function (d) {
        return d._x;
      }).y(function (d) {
        return d._y;
      });

      return lines.map(function (d, i) {
        return React.createElement(lib_2$1, _extends({}, _this2.props, {
          className: className,
          markType: "path",
          key: "DividedLine-" + i,
          style: d.key,
          d: lineRender(d.points)
        }));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var lines = this.createLineSegments();

      return React.createElement(
        "g",
        null,
        lines
      );
    }
  }]);
  return DividedLine;
}(React.Component);

DividedLine.propTypes = {
  parameters: propTypes.func,
  className: propTypes.string,
  interpolate: propTypes.func,
  data: propTypes.oneOfType([propTypes.array, propTypes.object]),
  lineDataAccessor: propTypes.func,
  customAccessors: propTypes.object,
  searchIterations: propTypes.number
};

var defaultTickLineGenerator = function defaultTickLineGenerator(_ref) {
  var xy = _ref.xy,
      orient = _ref.orient,
      i = _ref.i;
  return React.createElement(lib_2$1, {
    key: i,
    markType: "path",
    renderMode: xy.renderMode,
    stroke: "black",
    strokeWidth: "1px",
    simpleInterpolate: true,
    d: "M" + xy.x1 + "," + xy.y1 + "L" + xy.x2 + "," + xy.y2,
    className: "tick-line tick " + orient
  });
};

function axisPieces(_ref2) {
  var _ref2$renderMode = _ref2.renderMode,
      renderMode = _ref2$renderMode === undefined ? function () {
    return undefined;
  } : _ref2$renderMode,
      _ref2$padding = _ref2.padding,
      padding = _ref2$padding === undefined ? 5 : _ref2$padding,
      tickValues = _ref2.tickValues,
      scale = _ref2.scale,
      ticks = _ref2.ticks,
      _ref2$orient = _ref2.orient,
      orient = _ref2$orient === undefined ? "left" : _ref2$orient,
      size = _ref2.size,
      _ref2$footer = _ref2.footer,
      footer = _ref2$footer === undefined ? false : _ref2$footer,
      _ref2$tickSize = _ref2.tickSize,
      tickSize = _ref2$tickSize === undefined ? footer ? -10 : ["top", "bottom"].find(function (d) {
    return d === orient;
  }) ? size[1] : size[0] : _ref2$tickSize;

  //returns x1 (start of line), x2 (end of line) associated with the value of the tick
  var axisDomain = [],
      position1 = void 0,
      position2 = void 0,
      domain1 = void 0,
      domain2 = void 0,
      tposition1 = void 0,
      tposition2 = void 0,
      textPositionMod = 0,
      textPositionMod2 = 0,
      defaultAnchor = "middle";

  switch (orient) {
    case "top":
      position1 = "x1";
      position2 = "x2";
      domain1 = "y1";
      domain2 = "y2";
      axisDomain = [0, tickSize];
      tposition1 = "tx";
      tposition2 = "ty";
      textPositionMod -= 20 - padding;
      break;
    case "bottom":
      position1 = "x1";
      position2 = "x2";
      domain1 = "y2";
      domain2 = "y1";
      axisDomain = [size[1], size[1] - tickSize];
      tposition1 = "tx";
      tposition2 = "ty";
      textPositionMod += 20 + padding;
      break;
    case "right":
      position1 = "y2";
      position2 = "y1";
      domain1 = "x2";
      domain2 = "x1";
      axisDomain = [size[0], size[0] - tickSize];
      tposition1 = "ty";
      tposition2 = "tx";
      textPositionMod += 5 + padding;
      textPositionMod2 += 5;
      defaultAnchor = "start";
      break;
    //left
    default:
      position1 = "y1";
      position2 = "y2";
      domain1 = "x1";
      domain2 = "x2";
      axisDomain = [0, tickSize];
      tposition1 = "ty";
      tposition2 = "tx";
      textPositionMod -= 5 + padding;
      textPositionMod2 += 5;
      defaultAnchor = "end";
      break;
  }

  var axisSize = Math.abs(scale.range()[1] - scale.range()[0]);

  if (!tickValues) {
    if (!ticks) {
      ticks = Math.max(1, parseInt(axisSize / 40, 10));
    }
    tickValues = scale.ticks(ticks);
  }

  return tickValues.map(function (tick, i) {
    var _ref3;

    var tickPosition = scale(tick);
    return _ref3 = {}, defineProperty(_ref3, position1, tickPosition), defineProperty(_ref3, position2, tickPosition), defineProperty(_ref3, domain1, axisDomain[0]), defineProperty(_ref3, domain2, axisDomain[1]), defineProperty(_ref3, tposition1, tickPosition + textPositionMod2), defineProperty(_ref3, tposition2, axisDomain[0] + textPositionMod), defineProperty(_ref3, "defaultAnchor", defaultAnchor), defineProperty(_ref3, "renderMode", renderMode(tick, i)), defineProperty(_ref3, "value", tick), _ref3;
  });
}

var axisLabels = function axisLabels(_ref4) {
  var axisParts = _ref4.axisParts,
      tickFormat = _ref4.tickFormat,
      _ref4$rotate = _ref4.rotate,
      rotate = _ref4$rotate === undefined ? 0 : _ref4$rotate;

  return axisParts.map(function (axisPart, i) {
    var renderedValue = tickFormat(axisPart.value);
    if ((typeof renderedValue === "undefined" ? "undefined" : _typeof(renderedValue)) !== "object" || renderedValue instanceof Date) {
      renderedValue = React.createElement(
        "text",
        { textAnchor: axisPart.defaultAnchor },
        renderedValue.toString ? renderedValue.toString() : renderedValue
      );
    }

    return React.createElement(
      "g",
      {
        key: i,
        pointerEvents: "none",
        transform: "translate(" + axisPart.tx + "," + axisPart.ty + ")rotate(" + rotate + ")"
      },
      renderedValue
    );
  });
};

var axisLines = function axisLines(_ref5) {
  var axisParts = _ref5.axisParts,
      orient = _ref5.orient,
      _ref5$tickLineGenerat = _ref5.tickLineGenerator,
      tickLineGenerator = _ref5$tickLineGenerat === undefined ? defaultTickLineGenerator : _ref5$tickLineGenerat;

  return axisParts.map(function (axisPart, i) {
    return tickLineGenerator({ xy: axisPart, orient: orient, i: i });
  });
};

// components

function formatValue(value, props) {
  if (props.tickFormat) {
    return props.tickFormat(value);
  }
  if (value.toString) {
    return value.toString();
  }
  return value;
}

var Axis = function (_React$Component) {
  inherits(Axis, _React$Component);

  function Axis(props) {
    classCallCheck(this, Axis);

    var _this = possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this, props));

    _this.state = { hoverAnnotation: 0 };
    return _this;
  }

  createClass(Axis, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var position = this.props.position || [0, 0];
      var _props = this.props,
          rotate = _props.rotate,
          label = _props.label,
          _props$orient = _props.orient,
          orient = _props$orient === undefined ? "left" : _props$orient,
          _props$tickFormat = _props.tickFormat,
          tickFormat = _props$tickFormat === undefined ? function (d) {
        return d;
      } : _props$tickFormat,
          size = _props.size,
          _props$width = _props.width,
          width = _props$width === undefined ? size && size[0] || 0 : _props$width,
          _props$height = _props.height,
          height = _props$height === undefined ? size && size[1] || 0 : _props$height,
          className = _props.className,
          padding = _props.padding,
          tickValues = _props.tickValues,
          scale = _props.scale,
          ticks = _props.ticks,
          footer = _props.footer,
          tickSize = _props.tickSize,
          tickLineGenerator = _props.tickLineGenerator,
          _props$baseline = _props.baseline,
          baseline = _props$baseline === undefined ? true : _props$baseline,
          _props$margin = _props.margin,
          margin = _props$margin === undefined ? { top: 0, bottom: 0, left: 0, right: 0 } : _props$margin;


      if (this.props.format) {
        console.error("axis `format` has been deprecated use `tickFormat`");
      }

      var axisTickLines = void 0;
      var axisParts = this.props.axisParts;

      if (!axisParts) {
        axisParts = axisPieces({
          padding: padding,
          tickValues: tickValues,
          scale: scale,
          ticks: ticks,
          orient: orient,
          size: [width, height],
          footer: footer,
          tickSize: tickSize
        });
        axisTickLines = React.createElement(
          "g",
          { className: "axis " + className },
          axisLines({ axisParts: axisParts, orient: orient, tickLineGenerator: tickLineGenerator })
        );
      }
      if (axisParts.length === 0) {
        return null;
      }

      var hoverWidth = 50;
      var hoverHeight = height;
      var hoverX = -50;
      var hoverY = 0;
      var baselineX = 0;
      var baselineY = 0;
      var baselineX2 = 0;
      var baselineY2 = height;

      var hoverFunction = function hoverFunction(e) {
        return _this2.setState({ hoverAnnotation: e.nativeEvent.offsetY });
      };
      var circleX = 25;
      var textX = -25;
      var textY = 18;
      var lineWidth = width + 25;
      var lineHeight = 0;
      var circleY = this.state.hoverAnnotation;
      var annotationOffset = 0;
      var annotationType = "y";

      switch (orient) {
        case "right":
          position = [position[0], position[1]];
          hoverX = width;
          baselineX2 = baselineX = width;
          annotationOffset = margin.top;
          lineWidth = -width - 25;
          textX = 5;
          hoverFunction = function hoverFunction(e) {
            return _this2.setState({
              hoverAnnotation: e.nativeEvent.offsetY - annotationOffset
            });
          };
          break;
        case "top":
          position = [position[0], 0];
          hoverWidth = width;
          hoverHeight = 50;
          hoverY = -50;
          hoverX = 0;
          annotationOffset = margin.left;
          annotationType = "x";
          baselineX2 = width;
          baselineY2 = 0;
          hoverFunction = function hoverFunction(e) {
            return _this2.setState({
              hoverAnnotation: e.nativeEvent.offsetX - annotationOffset
            });
          };
          circleX = this.state.hoverAnnotation;
          circleY = 25;
          textX = 0;
          textY = -10;
          lineWidth = 0;
          lineHeight = height + 25;
          break;
        case "bottom":
          position = [position[0], position[1]];
          position = [position[0], 0];
          hoverWidth = width;
          hoverHeight = 50;
          baselineY = baselineY2 = hoverY = height;
          baselineX = hoverX = 0;
          baselineX2 = width;
          annotationOffset = margin.left;

          hoverFunction = function hoverFunction(e) {
            return _this2.setState({
              hoverAnnotation: e.nativeEvent.offsetX - annotationOffset
            });
          };
          circleX = this.state.hoverAnnotation;
          circleY = 25;
          textX = 0;
          textY = 15;
          lineWidth = 0;
          lineHeight = -height - 25;
          annotationType = "x";
          break;
        default:
          position = [position[0], position[1]];
          annotationOffset = margin.top;
          hoverFunction = function hoverFunction(e) {
            return _this2.setState({
              hoverAnnotation: e.nativeEvent.offsetY - annotationOffset
            });
          };
      }

      var annotationBrush = void 0;

      if (this.props.annotationFunction) {
        var formattedValue = formatValue(this.props.scale.invert(this.state.hoverAnnotation), this.props);
        var hoverGlyph = this.props.glyphFunction ? this.props.glyphFunction({
          lineHeight: lineHeight,
          lineWidth: lineWidth,
          value: this.props.scale.invert(this.state.hoverAnnotation)
        }) : React.createElement(
          "g",
          null,
          React.isValidElement(formattedValue) ? React.createElement(
            "g",
            { transform: "translate(" + textX + "," + textY + ")" },
            formattedValue
          ) : React.createElement(
            "text",
            { x: textX, y: textY },
            formattedValue
          ),
          React.createElement("circle", { r: 5 }),
          React.createElement("line", { x1: lineWidth, y1: lineHeight, style: { stroke: "black" } })
        );
        var annotationSymbol = this.state.hoverAnnotation ? React.createElement(
          "g",
          {
            style: { pointerEvents: "none" },
            transform: "translate(" + circleX + "," + circleY + ")"
          },
          hoverGlyph
        ) : null;

        annotationBrush = React.createElement(
          "g",
          {
            className: "annotation-brush",
            transform: "translate(" + hoverX + "," + hoverY + ")"
          },
          React.createElement("rect", {
            style: { fillOpacity: 0 },
            height: hoverHeight,
            width: hoverWidth,
            onMouseMove: hoverFunction,
            onClick: function onClick() {
              return _this2.props.annotationFunction({
                className: "dynamic-axis-annotation",
                type: annotationType,
                value: _this2.props.scale.invert(_this2.state.hoverAnnotation)
              });
            },
            onMouseOut: function onMouseOut() {
              return _this2.setState({ hoverAnnotation: undefined });
            }
          }),
          annotationSymbol
        );
      }

      var axisTitle = void 0;

      var axisTickLabels = axisLabels({
        tickFormat: tickFormat,
        axisParts: axisParts,
        orient: orient,
        rotate: rotate
      });
      if (label) {
        var labelName = label.name || label;
        var labelPosition = label.position || {};
        var locationMod = labelPosition.location || "outside";
        var anchorMod = labelPosition.anchor || "middle";
        var distance = label.locationDistance;

        var rotateHash = {
          left: -90,
          right: 90,
          top: 0,
          bottom: 0
        };

        var rotation = labelPosition.rotation || rotateHash[orient];

        var positionHash = {
          left: {
            start: [0, size[1]],
            middle: [0, size[1] / 2],
            end: [0, 0],
            inside: [distance || 15, 0],
            outside: [-(distance || 45), 0]
          },
          right: {
            start: [size[0] + 0, size[1]],
            middle: [size[0] + 0, size[1] / 2],
            end: [size[0] + 0, 0],
            inside: [-(distance || 15), 0],
            outside: [distance || 45, 0]
          },
          top: {
            start: [0, 0],
            middle: [0 + size[0] / 2, 0],
            end: [0 + size[0], 0],
            inside: [0, distance || 15],
            outside: [0, -(distance || 40)]
          },
          bottom: {
            start: [0, size[1]],
            middle: [0 + size[0] / 2, size[1]],
            end: [0 + size[0], size[1]],
            inside: [0, -(distance || 5)],
            outside: [0, distance || 50]
          }
        };

        var translation = positionHash[orient][anchorMod];
        var location = positionHash[orient][locationMod];

        translation[0] = translation[0] + location[0];
        translation[1] = translation[1] + location[1];

        if (anchorMod === "start" && orient === "right") {
          anchorMod = "end";
        } else if (anchorMod === "end" && orient === "right") {
          anchorMod = "start";
        }

        axisTitle = React.createElement(
          "g",
          {
            className: "axis-title",
            transform: "translate(" + [translation[0] + position[0], translation[1] + position[1]] + ") rotate(" + rotation + ")"
          },
          React.isValidElement(labelName) ? labelName : React.createElement(
            "text",
            { textAnchor: anchorMod },
            labelName
          )
        );
      }

      return React.createElement(
        "g",
        { className: className },
        annotationBrush,
        axisTickLabels,
        axisTickLines,
        baseline ? React.createElement("line", {
          key: "baseline",
          className: "axis-baseline",
          stroke: "black",
          strokeLinecap: "square",
          x1: baselineX,
          x2: baselineX2,
          y1: baselineY,
          y2: baselineY2
        }) : null,
        axisTitle
      );
    }
  }]);
  return Axis;
}(React.Component);

Axis.propTypes = {
  name: propTypes.string,
  className: propTypes.string,
  orient: propTypes.string,
  position: propTypes.array,
  size: propTypes.array.isRequired,
  rotate: propTypes.number,
  scale: propTypes.func.isRequired,
  annotationFunction: propTypes.func,
  format: propTypes.string,
  tickFormat: propTypes.func,
  tickValues: propTypes.array,
  padding: propTypes.number,
  baseline: propTypes.bool,
  ticks: propTypes.oneOfType([propTypes.array, propTypes.number]),
  label: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.object])
};

/*
The MIT License (MIT)

Copyright (c) 2016 CoderPuppy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
var _endianness;
function endianness() {
  if (typeof _endianness === 'undefined') {
    var a = new ArrayBuffer(2);
    var b = new Uint8Array(a);
    var c = new Uint16Array(a);
    b[0] = 1;
    b[1] = 2;
    if (c[0] === 258) {
      _endianness = 'BE';
    } else if (c[0] === 513) {
      _endianness = 'LE';
    } else {
      throw new Error('unable to figure out endianess');
    }
  }
  return _endianness;
}

function hostname() {
  if (typeof global.location !== 'undefined') {
    return global.location.hostname;
  } else return '';
}

function loadavg() {
  return [];
}

function uptime() {
  return 0;
}

function freemem() {
  return Number.MAX_VALUE;
}

function totalmem() {
  return Number.MAX_VALUE;
}

function cpus() {
  return [];
}

function type() {
  return 'Browser';
}

function release() {
  if (typeof global.navigator !== 'undefined') {
    return global.navigator.appVersion;
  }
  return '';
}

function networkInterfaces() {}
function getNetworkInterfaces() {}

function arch() {
  return 'javascript';
}

function platform() {
  return 'browser';
}

function tmpDir() {
  return '/tmp';
}
var tmpdir = tmpDir;

var EOL = '\n';
var os = {
  EOL: EOL,
  tmpdir: tmpdir,
  tmpDir: tmpDir,
  networkInterfaces: networkInterfaces,
  getNetworkInterfaces: getNetworkInterfaces,
  release: release,
  type: type,
  cpus: cpus,
  totalmem: totalmem,
  freemem: freemem,
  uptime: uptime,
  loadavg: loadavg,
  hostname: hostname,
  endianness: endianness
};

var os$1 = Object.freeze({
	endianness: endianness,
	hostname: hostname,
	loadavg: loadavg,
	uptime: uptime,
	freemem: freemem,
	totalmem: totalmem,
	cpus: cpus,
	type: type,
	release: release,
	networkInterfaces: networkInterfaces,
	getNetworkInterfaces: getNetworkInterfaces,
	arch: arch,
	platform: platform,
	tmpDir: tmpDir,
	tmpdir: tmpdir,
	EOL: EOL,
	default: os
});

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var reLeadingDot = /^\./;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$2 = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;
var funcProto = Function.prototype;
var objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root$2['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var _Symbol = root$2.Symbol;
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map$2 = getNative(root$2, 'Map');
var nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$2 || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function (string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get$3(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var lodash_get = get$3;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';
var funcTag$1 = '[object Function]';
var genTag$1 = '[object GeneratorFunction]';

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$1 = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$3 = freeGlobal$1 || freeSelf$1 || Function('return this')();

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$1.toString;

/** Built-in value references. */
var _Symbol$1 = root$3.Symbol;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var spreadableSymbol = _Symbol$1 ? _Symbol$1.isConcatSpreadable : undefined;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array ? array.length : 0;
  return length ? baseFlatten(array, 1) : [];
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty$2.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString$1.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike$1(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$1(value) ? objectToString$1.call(value) : '';
  return tag == funcTag$1 || tag == genTag$1;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

var lodash_flatten = flatten;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/** `Object#toString` result references. */
var funcTag$2 = '[object Function]';
var genTag$2 = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal$2 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$2 = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$4 = freeGlobal$2 || freeSelf$2 || Function('return this')();

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject$1(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set$$1) {
  var index = -1,
      result = Array(set$$1.size);

  set$$1.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype;
var funcProto$1 = Function.prototype;
var objectProto$2 = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$4['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$1 = function () {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$2.toString;

/** Used to detect if a method is native. */
var reIsNative$1 = RegExp('^' + funcToString$1.call(hasOwnProperty$3).replace(reRegExpChar$1, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var splice$1 = arrayProto$1.splice;

/* Built-in method references that are verified to be native. */
var Map$3 = getNative$1(root$4, 'Map');
var Set$2 = getNative$1(root$4, 'Set');
var nativeCreate$1 = getNative$1(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$1(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

// Add methods to `Hash`.
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype['delete'] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$1() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype['delete'] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.__data__ = {
    'hash': new Hash$1(),
    'map': new (Map$3 || ListCache$1)(),
    'string': new Hash$1()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  return getMapData$1(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  getMapData$1(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype['delete'] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache$1();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$1);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$2(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$2(value) || isHostObject$1(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set$$1 = iteratee ? null : createSet(array);
    if (set$$1) {
      return setToArray(set$$1);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = comparator || value !== 0 ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY$1) ? noop$3 : function (values) {
  return new Set$2(values);
};

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$1(map, key) {
  var data = map.__data__;
  return isKeyable$1(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$1(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$2(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$2(value) ? objectToString$2.call(value) : '';
  return tag == funcTag$2 || tag == genTag$2;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$2(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop$3() {
  // No operation performed.
}

var lodash_uniq = uniq;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0;
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** `Object#toString` result references. */
var funcTag$3 = '[object Function]';
var genTag$3 = '[object GeneratorFunction]';
var symbolTag$1 = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp$1 = /^\w*$/;
var reLeadingDot$1 = /^\./;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar$1 = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal$3 = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$3 = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$5 = freeGlobal$3 || freeSelf$3 || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$2(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject$2(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype;
var funcProto$2 = Function.prototype;
var objectProto$3 = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData$2 = root$5['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$2 = function () {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$3.toString;

/** Used to detect if a method is native. */
var reIsNative$2 = RegExp('^' + funcToString$2.call(hasOwnProperty$4).replace(reRegExpChar$2, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var _Symbol$2 = root$5.Symbol;
var splice$2 = arrayProto$2.splice;

/* Built-in method references that are verified to be native. */
var Map$4 = getNative$2(root$5, 'Map');
var nativeCreate$2 = getNative$2(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol$2 ? _Symbol$2.prototype : undefined;
var symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$2() {
  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$2(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== undefined : hasOwnProperty$4.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$2(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate$2 && value === undefined ? HASH_UNDEFINED$2 : value;
  return this;
}

// Add methods to `Hash`.
Hash$2.prototype.clear = hashClear$2;
Hash$2.prototype['delete'] = hashDelete$2;
Hash$2.prototype.get = hashGet$2;
Hash$2.prototype.has = hashHas$2;
Hash$2.prototype.set = hashSet$2;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$2() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$2(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$2(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$2(key, value) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache$2.prototype.clear = listCacheClear$2;
ListCache$2.prototype['delete'] = listCacheDelete$2;
ListCache$2.prototype.get = listCacheGet$2;
ListCache$2.prototype.has = listCacheHas$2;
ListCache$2.prototype.set = listCacheSet$2;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$2() {
  this.__data__ = {
    'hash': new Hash$2(),
    'map': new (Map$4 || ListCache$2)(),
    'string': new Hash$2()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$2(key) {
  return getMapData$2(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$2(key) {
  return getMapData$2(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$2(key, value) {
  getMapData$2(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache$2.prototype.clear = mapCacheClear$2;
MapCache$2.prototype['delete'] = mapCacheDelete$2;
MapCache$2.prototype.get = mapCacheGet$2;
MapCache$2.prototype.has = mapCacheHas$2;
MapCache$2.prototype.set = mapCacheSet$2;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$4.call(object, key) && eq$2(objValue, value)) || value === undefined && !(key in object)) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$2(value) {
  if (!isObject$3(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = isFunction$3(value) || isHostObject$2(value) ? reIsNative$2 : reIsHostCtor$2;
  return pattern.test(toSource$2(value));
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject$3(object)) {
    return object;
  }
  path = isKey$1(path, object) ? [path] : castPath$1(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey$1(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject$3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol$1(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$1(value) {
  return isArray$2(value) ? value : stringToPath$1(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$2(map, key) {
  var data = map.__data__;
  return isKeyable$2(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$2(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative$2(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$1(value, object) {
  if (isArray$2(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$2(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$2(func) {
  return !!maskSrcKey$2 && maskSrcKey$2 in func;
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$1 = memoize$1(function (string) {
  string = toString$1(string);

  var result = [];
  if (reLeadingDot$1.test(string)) {
    result.push('');
  }
  string.replace(rePropName$1, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar$1, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$1(value) {
  if (typeof value == 'string' || isSymbol$1(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2)();
  return memoized;
}

// Assign cache to `_.memoize`.
memoize$1.Cache = MapCache$2;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$2 = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$3(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$3(value) ? objectToString$3.call(value) : '';
  return tag == funcTag$3 || tag == genTag$3;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$3(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$2(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike$2(value) && objectToString$3.call(value) == symbolTag$1;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : baseToString$1(value);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set$5(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

var lodash_set = set$5;

var lodash_clonedeep = createCommonjsModule(function (module, exports) {
  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  /** Detect free variable `self`. */
  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }

  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
  function addSetEntry(set$$1, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set$$1.add(value);
    return set$$1;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set$$1) {
    var index = -1,
        result = Array(set$$1.size);

    set$$1.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined,
      _Symbol = root.Symbol,
      Uint8Array = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView'),
      Map = getNative(root, 'Map'),
      Promise = getNative(root, 'Promise'),
      Set = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache();
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    return this.__data__['delete'](key);
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];

    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {boolean} [isFull] Specify a clone including symbols.
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    return objectToString.call(value);
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `map`.
   *
   * @private
   * @param {Object} map The map to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned map.
   */
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of `set`.
   *
   * @private
   * @param {Object} set The set to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned set.
   */
  function cloneSet(set$$1, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set$$1), true) : setToArray(set$$1);
    return arrayReduce(array, addSetEntry, new set$$1.constructor());
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  }

  /**
   * Copies own symbol properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11,
  // for data views in Edge < 14, and promises in Node.js.
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag:case float64Tag:
      case int8Tag:case int16Tag:case int32Tag:
      case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return cloneSet(object, isDeep, cloneFunc);

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

    return value === proto;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  module.exports = cloneDeep;
});

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function isBuffer_1(obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

var flat_1 = createCommonjsModule(function (module) {
  var flat = module.exports = flatten;
  flatten.flatten = flatten;
  flatten.unflatten = unflatten;

  function flatten(target, opts) {
    opts = opts || {};

    var delimiter = opts.delimiter || '.';
    var maxDepth = opts.maxDepth;
    var output = {};

    function step(object, prev, currentDepth) {
      currentDepth = currentDepth ? currentDepth : 1;
      Object.keys(object).forEach(function (key) {
        var value = object[key];
        var isarray = opts.safe && Array.isArray(value);
        var type = Object.prototype.toString.call(value);
        var isbuffer = isBuffer_1(value);
        var isobject = type === "[object Object]" || type === "[object Array]";

        var newKey = prev ? prev + delimiter + key : key;

        if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
          return step(value, newKey, currentDepth + 1);
        }

        output[newKey] = value;
      });
    }

    step(target);

    return output;
  }

  function unflatten(target, opts) {
    opts = opts || {};

    var delimiter = opts.delimiter || '.';
    var overwrite = opts.overwrite || false;
    var result = {};

    var isbuffer = isBuffer_1(target);
    if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {
      return target;
    }

    // safely ensure that the key is
    // an integer.
    function getkey(key) {
      var parsedKey = Number(key);

      return isNaN(parsedKey) || key.indexOf('.') !== -1 ? key : parsedKey;
    }

    Object.keys(target).forEach(function (key) {
      var split = key.split(delimiter);
      var key1 = getkey(split.shift());
      var key2 = getkey(split[0]);
      var recipient = result;

      while (key2 !== undefined) {
        var type = Object.prototype.toString.call(recipient[key1]);
        var isobject = type === "[object Object]" || type === "[object Array]";

        // do not write over falsey, non-undefined values if overwrite is false
        if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {
          return;
        }

        if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
          recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {};
        }

        recipient = recipient[key1];
        if (split.length > 0) {
          key1 = getkey(split.shift());
          key2 = getkey(split[0]);
        }
      }

      // unflatten again for 'messy objects'
      recipient[key1] = unflatten(target[key], opts);
    });

    return result;
  }
});

var os$2 = ( os$1 && os ) || os$1;

/**
 * Module dependencies.
 */

/**
 * @name Json2CsvParams
 * @typedef {Object}
 * @property {Array} data - array of JSON objects
 * @property {Array} [fields] - see documentation for details
 * @property {String[]} [fieldNames] - names for fields at the same indexes. Must be same length as fields array
 *                                   (Optional. Maintained for backwards compatibility. Use fields config object for more features)
 * @property {String} [del=","] - delimiter of columns
 * @property {String} [defaultValue="<empty>"] - default value to use when missing data
 * @property {String} [quotes='"'] - quotes around cell values and column names
 * @property {String} [doubleQuotes='"""'] - the value to replace double quotes in strings
 * @property {Boolean} [hasCSVColumnTitle=true] - determines whether or not CSV file will contain a title column
 * @property {String} [eol=''] - it gets added to each row of data
 * @property {String} [newLine] - overrides the default OS line ending (\n on Unix \r\n on Windows)
 * @property {Boolean} [flatten=false] - flattens nested JSON using flat (https://www.npmjs.com/package/flat)
 * @property {String} [unwindPath] - similar to MongoDB's $unwind, Deconstructs an array field from the input JSON to output a row for each element
 * @property {Boolean} [excelStrings] - converts string data into normalized Excel style data
 * @property {Boolean} [includeEmptyRows=false] - includes empty rows
 */

/**
 * Main function that converts json to csv.
 *
 * @param {Json2CsvParams} params Function parameters containing data, fields,
 * delimiter (default is ','), hasCSVColumnTitle (default is true)
 * and default value (default is '')
 * @param {Function} [callback] Callback function
 *   if error, returning error in call back.
 *   if csv is created successfully, returning csv output to callback.
 */
var json2csv = function json2csv(params, callback) {
  var hasCallback = typeof callback === 'function';
  try {
    checkParams(params);
  } catch (err) {
    if (hasCallback) {
      return process.nextTick(function () {
        callback(err);
      });
    } else {
      throw err;
    }
  }

  var titles = createColumnTitles(params);
  var csv = createColumnContent(params, titles);

  if (hasCallback) {
    return process.nextTick(function () {
      callback(null, csv);
    });
  } else {
    return csv;
  }
};

/**
 * Check passing params.
 *
 * Note that this modifies params.
 *
 * @param {Json2CsvParams} params Function parameters containing data, fields,
 * delimiter, default value, mark quotes and hasCSVColumnTitle
 */
function checkParams(params) {
  params.data = params.data || [];

  // if data is an Object, not in array [{}], then just create 1 item array.
  // So from now all data in array of object format.
  if (!Array.isArray(params.data)) {
    params.data = [params.data];
  }

  if (params.flatten) {
    params.data = params.data.map(flat_1);
  }

  // Set params.fields default to first data element's keys
  if (!params.fields && (params.data.length === 0 || _typeof(params.data[0]) !== 'object')) {
    throw new Error('params should include "fields" and/or non-empty "data" array of objects');
  }

  if (!params.fields) {
    var dataFields = params.data.map(function (item) {
      return Object.keys(item);
    });

    dataFields = lodash_flatten(dataFields);
    params.fields = lodash_uniq(dataFields);
  }

  //#check fieldNames
  if (params.fieldNames && params.fieldNames.length !== params.fields.length) {
    throw new Error('fieldNames and fields should be of the same length, if fieldNames is provided.');
  }

  // Get fieldNames from fields
  params.fieldNames = params.fields.map(function (field, i) {
    if (params.fieldNames && typeof field === 'string') {
      return params.fieldNames[i];
    }
    return typeof field === 'string' ? field : field.label || field.value;
  });

  //#check delimiter
  params.del = params.del || ',';

  //#check end of line character
  params.eol = params.eol || '';

  //#check quotation mark
  params.quotes = typeof params.quotes === 'string' ? params.quotes : '"';

  //#check double quotes
  params.doubleQuotes = typeof params.doubleQuotes === 'string' ? params.doubleQuotes : Array(3).join(params.quotes);

  //#check default value
  params.defaultValue = params.defaultValue;

  //#check hasCSVColumnTitle, if it is not explicitly set to false then true.
  params.hasCSVColumnTitle = params.hasCSVColumnTitle !== false;

  //#check include empty rows, defaults to false
  params.includeEmptyRows = params.includeEmptyRows || false;
}

/**
 * Create the title row with all the provided fields as column headings
 *
 * @param {Json2CsvParams} params Function parameters containing data, fields and delimiter
 * @returns {String} titles as a string
 */
function createColumnTitles(params) {
  var str = '';

  //if CSV has column title, then create it
  if (params.hasCSVColumnTitle) {
    params.fieldNames.forEach(function (element) {
      if (str !== '') {
        str += params.del;
      }
      str += JSON.stringify(element).replace(/\"/g, params.quotes);
    });
  }

  return str;
}

/**
 * Replace the quotation marks of the field element if needed (can be a not string-like item)
 *
 * @param {string} stringifiedElement The field element after JSON.stringify()
 * @param {string} quotes The params.quotes value. At this point we know that is not equal to double (")
 */
function replaceQuotationMarks(stringifiedElement, quotes) {
  var lastCharIndex = stringifiedElement.length - 1;

  //check if it's an string-like element
  if (stringifiedElement[0] === '"' && stringifiedElement[lastCharIndex] === '"') {
    //split the stringified field element because Strings are immutable
    var splitElement = stringifiedElement.split('');

    //replace the quotation marks
    splitElement[0] = quotes;
    splitElement[lastCharIndex] = quotes;

    //join again
    stringifiedElement = splitElement.join('');
  }

  return stringifiedElement;
}

/**
 * Create the content column by column and row by row below the title
 *
 * @param {Object} params Function parameters containing data, fields and delimiter
 * @param {String} str Title row as a string
 * @returns {String} csv string
 */
function createColumnContent(params, str) {
  var dataRows = createDataRows(params);
  dataRows.forEach(function (dataElement) {
    //if null do nothing, if empty object without includeEmptyRows do nothing
    if (dataElement && (Object.getOwnPropertyNames(dataElement).length > 0 || params.includeEmptyRows)) {
      var line = '';
      var eol = params.newLine || os$2.EOL || '\n';

      params.fields.forEach(function (fieldElement) {
        var val;
        var defaultValue = params.defaultValue;
        if ((typeof fieldElement === 'undefined' ? 'undefined' : _typeof(fieldElement)) === 'object' && 'default' in fieldElement) {
          defaultValue = fieldElement.default;
        }

        if (fieldElement && (typeof fieldElement === 'string' || typeof fieldElement.value === 'string')) {
          var path = typeof fieldElement === 'string' ? fieldElement : fieldElement.value;
          val = lodash_get(dataElement, path, defaultValue);
        } else if (fieldElement && typeof fieldElement.value === 'function') {
          var field = {
            label: fieldElement.label,
            default: fieldElement.default
          };
          val = fieldElement.value(dataElement, field, params.data);
        }

        if (val === null || val === undefined) {
          val = defaultValue;
        }

        if (val !== undefined) {
          var stringifiedElement = JSON.stringify(val);

          if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') stringifiedElement = JSON.stringify(stringifiedElement);

          if (params.quotes !== '"') {
            stringifiedElement = replaceQuotationMarks(stringifiedElement, params.quotes);
          }

          //JSON.stringify('\\') results in a string with two backslash
          //characters in it. I.e. '\\\\'.
          stringifiedElement = stringifiedElement.replace(/\\\\/g, '\\');

          if (params.excelStrings && typeof val === 'string') {
            stringifiedElement = '"="' + stringifiedElement + '""';
          }

          line += stringifiedElement;
        }

        line += params.del;
      });

      //remove last delimeter
      line = line.substring(0, line.length - 1);
      //Replace single quotes with double quotes. Single quotes are preceeded by
      //a backslash. Be careful not to remove backslash content from the string.
      line = line.split('\\\\').map(function (portion) {
        return portion.replace(/\\"/g, params.doubleQuotes);
      }).join('\\\\');
      //Remove the final excess backslashes from the stringified value.
      line = line.replace(/\\\\/g, '\\');
      //If header exists, add it, otherwise, print only content
      if (str !== '') {
        str += eol + line + params.eol;
      } else {
        str = line + params.eol;
      }
    }
  });

  return str;
}

/**
 * Performs the unwind logic if necessary to convert single JSON document into multiple rows
 * @param params
 */
function createDataRows(params) {
  var dataRows = params.data;

  if (params.unwindPath) {
    dataRows = [];
    params.data.forEach(function (dataEl) {
      var unwindArray = lodash_get(dataEl, params.unwindPath);
      var isArr = Array.isArray(unwindArray);

      if (isArr && unwindArray.length) {
        unwindArray.forEach(function (unwindEl) {
          var dataCopy = lodash_clonedeep(dataEl);
          lodash_set(dataCopy, params.unwindPath, unwindEl);
          dataRows.push(dataCopy);
        });
      } else if (isArr && !unwindArray.length) {
        var dataCopy = lodash_clonedeep(dataEl);
        lodash_set(dataCopy, params.unwindPath, undefined);
        dataRows.push(dataCopy);
      } else {
        dataRows.push(dataEl);
      }
    });
  }

  return dataRows;
}

var _this = undefined;

var downloadCSV = function downloadCSV(csvName, data) {
  json2csv(Object.assign({}, { data: data }), function (err, csv) {
    var blob = new Blob([csv], { type: "text/csv" });

    var dlink = document.createElement("a");
    dlink.download = csvName ? csvName.replace(/ /g, "_") + ".csv" : "vis.csv";
    dlink.href = window.URL.createObjectURL(blob);
    dlink.onclick = function () {
      // revokeObjectURL needs a delay to work properly
      var revokeFn = function revokeFn() {
        window.URL.revokeObjectURL(_this.href);
      };
      setTimeout(revokeFn.bind(_this), 1500);
    };

    dlink.click();
    dlink.remove();
  });
};

var DownloadButton = function (_React$Component) {
  inherits(DownloadButton, _React$Component);

  function DownloadButton() {
    classCallCheck(this, DownloadButton);
    return possibleConstructorReturn(this, (DownloadButton.__proto__ || Object.getPrototypeOf(DownloadButton)).apply(this, arguments));
  }

  createClass(DownloadButton, [{
    key: "render",

    /*
      renderBody({ csvName, data }) {
          return <div className='download-div'>
                  <button alt='download' onClick={downloadCSV.bind(this, csvName, data)} className='download-data-button'>
                      <a>Download</a>
                  </button>
              </div>
      }
    */
    value: function render() {
      var _props = this.props,
          csvName = _props.csvName,
          data = _props.data,
          width = _props.width,
          _props$label = _props.label,
          label = _props$label === undefined ? "Download" : _props$label;

      return React.createElement(
        "div",
        { className: "download-div", style: { width: width } },
        React.createElement(
          "button",
          {
            alt: "download",
            onClick: downloadCSV.bind(this, csvName, data),
            className: "download-data-button"
          },
          React.createElement(
            "a",
            null,
            label
          )
        )
      );
    }
  }]);
  return DownloadButton;
}(React.Component);

DownloadButton.propTypes = {
  csvName: propTypes.string,
  data: propTypes.array,
  width: propTypes.number
};

var noevent = function () {
  event.preventDefault();
  event.stopImmediatePropagation();
};

var nodrag = function (view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
};

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant$7 = function (x) {
  return function () {
    return x;
  };
};

var BrushEvent = function (target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
};

function nopropagation$1() {
  event.stopImmediatePropagation();
}

var noevent$1 = function () {
  event.preventDefault();
  event.stopImmediatePropagation();
};

var MODE_DRAG = { name: "drag" };
var MODE_SPACE = { name: "space" };
var MODE_HANDLE = { name: "handle" };
var MODE_CENTER = { name: "center" };

var X = {
  name: "x",
  handles: ["e", "w"].map(type$1),
  input: function input(x, e) {
    return x && [[x[0], e[0][1]], [x[1], e[1][1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type$1),
  input: function input(y, e) {
    return y && [[e[0][0], y[0]], [e[1][0], y[1]]];
  },
  output: function output(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type$1),
  input: function input(xy) {
    return xy;
  },
  output: function output(xy) {
    return xy;
  }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type$1(t) {
  return { type: t };
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local$1(node) {
  while (!node.__brush) {
    if (!(node = node.parentNode)) return;
  }return node.__brush;
}

function empty$1(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}



function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

var brush = function () {
  return brush$1(XY);
};

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type$1("overlay")]);

    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
      var extent = local$1(this).extent;
      select(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
    });

    group.selectAll(".selection").data([type$1("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle").data(dim.handles, function (d) {
      return d.type;
    });

    handle.exit().remove();

    handle.enter().append("rect").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function (d) {
      return cursors[d.type];
    });

    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function (group, selection) {
    if (group.selection) {
      group.on("start.brush", function () {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function () {
        emitter(this, arguments).end();
      }).tween("brush", function () {
        var that = this,
            state = that.__brush,
            emit = emitter(that, arguments),
            selection0 = state.selection,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
            i = interpolate(selection0, selection1);

        function tween(t) {
          state.selection = t === 1 && empty$1(selection1) ? null : i(t);
          redraw.call(that);
          emit.brush();
        }

        return selection0 && selection1 ? tween : tween(1);
      });
    } else {
      group.each(function () {
        var that = this,
            args = arguments,
            state = that.__brush,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
            emit = emitter(that, args).beforestart();

        interrupt(that);
        state.selection = selection1 == null || empty$1(selection1) ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };

  function redraw() {
    var group = select(this),
        selection = local$1(this).selection;

    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle").style("display", null).attr("x", function (d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function (d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function (d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function (d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function beforestart() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function start() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function brush() {
      this.emit("brush");
      return this;
    },
    end: function end() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function emit(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (event.touches) {
      if (event.changedTouches.length < event.touches.length) return noevent$1();
    } else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = event.target.__data__.type,
        mode = (event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : event.altKey ? MODE_CENTER : MODE_HANDLE,
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local$1(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0],
        w0,
        w1,
        N = extent[0][1],
        n0,
        n1,
        E = extent[1][0],
        e0,
        e1,
        S = extent[1][1],
        s0,
        s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && event.shiftKey,
        lockX,
        lockY,
        point0 = mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = select(that).attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);

    if (event.touches) {
      group.on("touchmove.brush", moved, true).on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = select(event.view).on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);

      nodrag(event.view);
    }

    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
      }
      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG:
          {
            if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }
        case MODE_HANDLE:
          {
            if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            break;
          }
        case MODE_CENTER:
          {
            if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
            if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
            break;
          }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation$1();
      if (event.touches) {
        if (event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        yesdrag(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty$1(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            shifting = signX && signY;
            break;
          }
        case 18:
          {
            // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move();
            }
            break;
          }
        case 32:
          {
            // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move();
            }
            break;
          }
        default:
          return;
      }
      noevent$1();
    }

    function keyupped() {
      switch (event.keyCode) {
        case 16:
          {
            // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move();
            }
            break;
          }
        case 18:
          {
            // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move();
            }
            break;
          }
        case 32:
          {
            // SPACE
            if (mode === MODE_SPACE) {
              if (event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }
              overlay.attr("cursor", cursors[type]);
              move();
            }
            break;
          }
        default:
          return;
      }
      noevent$1();
    }
  }

  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
  };

  brush.handleSize = function (_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

var constant$8 = function (x) {
  return function () {
    return x;
  };
};

function x$2(d) {
  return d[0];
}

function y$2(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function insert(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) {
          after = after.L;
        }after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function remove(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) {
      node.C = false;return;
    }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) {
    node = node.L;
  }return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$3 || Math.abs(edge[0][1] - edge[1][1]) > epsilon$3)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) {
        index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      }index.sort(function (i, j) {
        return array[j] - array[i];
      });
      for (j = 0; j < m; ++j) {
        array[j] = halfedges[index[j]];
      }for (j = 0; j < m; ++j) {
        halfedges[j] = array[j];
      }
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon$3 || Math.abs(endY - startY) > epsilon$3) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon$3 && y1 - endY > epsilon$3 ? [x0, Math.abs(startX - x0) < epsilon$3 ? startY : y1] : Math.abs(endY - y1) < epsilon$3 && x1 - endX > epsilon$3 ? [Math.abs(startY - y1) < epsilon$3 ? startX : x1, y1] : Math.abs(endX - x1) < epsilon$3 && endY - y0 > epsilon$3 ? [x1, Math.abs(startX - x1) < epsilon$3 ? startY : y0] : Math.abs(endY - y0) < epsilon$3 && endX - x0 > epsilon$3 ? [Math.abs(startY - y0) < epsilon$3 ? startX : x0, y0] : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx,
        dy,
        d2,
        dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0],
          v01 = [x0, y1],
          v11 = [x1, y1],
          v10 = [x1, y0];
      cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2$1) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle();
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
      if (node.L) node = node.L;else {
        before = node.P;break;
      }
    } else {
      if (node.R) node = node.R;else {
        before = node;break;
      }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle && Math.abs(x - lArc.circle.x) < epsilon$3 && Math.abs(y - lArc.circle.cy) < epsilon$3) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle && Math.abs(x - rArc.circle.x) < epsilon$3 && Math.abs(y - rArc.circle.cy) < epsilon$3) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$3) node = node.L;else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon$3) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$3) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$3) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) {
    // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$3 = 1e-6;
var epsilon2$1 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree();
  circles = new RedBlackTree();

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches = circles = edges = cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function polygons() {
    var edges = this.edges;

    return this.cells.map(function (cell) {
      var polygon = cell.halfedges.map(function (i) {
        return cellHalfedgeStart(cell, edges[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function triangles() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function (cell, i) {
      var site = cell.site,
          halfedges = cell.halfedges,
          j = -1,
          m = halfedges.length,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function links() {
    return this.edges.filter(function (edge) {
      return edge.right;
    }).map(function (edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  }
};

var voronoi = function () {
  var x$$1 = x$2,
      y$$1 = y$2,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function (d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon$3) * epsilon$3, Math.round(y$$1(d, i, data) / epsilon$3) * epsilon$3];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function (data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function (data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function (data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function (_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$8(+_), voronoi) : x$$1;
  };

  voronoi.y = function (_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$8(+_), voronoi) : y$$1;
  };

  voronoi.extent = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
};

// components

var flatten$2 = function flatten(list) {
  return list.reduce(function (a, b) {
    return a.concat(Array.isArray(b) ? flatten(b) : b);
  }, []);
};

function flatShortArray(array) {
  if (!Array.isArray(array)) return "not-array";
  var flat = flatten$2(array);
  var stringifiedFlattened = flat.map(function (d) {
    return d instanceof Date && d.toString() || d && d.toFixed && d.toFixed(2) || "empty";
  }).toString();
  return stringifiedFlattened;
}

var Brush = function (_React$Component) {
  inherits(Brush, _React$Component);

  function Brush(props) {
    classCallCheck(this, Brush);

    var _this = possibleConstructorReturn(this, (Brush.__proto__ || Object.getPrototypeOf(Brush)).call(this, props));

    _this.createBrush = _this.createBrush.bind(_this);
    return _this;
  }

  createClass(Brush, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.createBrush();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(lastProps) {
      if (lastProps.extent && this.props.extent && flatShortArray(lastProps.extent) !== flatShortArray(this.props.extent) || lastProps.selectedExtent && this.props.selectedExtent && flatShortArray(lastProps.selectedExtent) !== flatShortArray(this.props.selectedExtent) || !lastProps.selectedExtent && this.props.selectedExtent || lastProps.selectedExtent && !this.props.selectedExtent) {
        this.createBrush();
      }
    }
  }, {
    key: "createBrush",
    value: function createBrush() {
      var node = this.node;
      var brush = this.props.svgBrush;
      select(node).call(brush);
      if (this.props.selectedExtent) {
        select(node).call(brush.move, this.props.selectedExtent);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return React.createElement("g", {
        ref: function ref(node) {
          return _this2.node = node;
        },
        transform: "translate(" + (this.props.position || [0, 0]) + ")",
        className: "xybrush"
      });
    }
  }]);
  return Brush;
}(React.Component);

Brush.propTypes = {
  size: propTypes.array,
  position: propTypes.array,
  selectedExtent: propTypes.array,
  svgBrush: propTypes.func
};

// components
var InteractionLayer = function (_React$Component) {
  inherits(InteractionLayer, _React$Component);

  function InteractionLayer(props) {
    classCallCheck(this, InteractionLayer);

    var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this, props));

    _this.createBrush = _this.createBrush.bind(_this);
    _this.createColumnsBrush = _this.createColumnsBrush.bind(_this);
    _this.brushStart = _this.brushStart.bind(_this);
    _this.brush = _this.brush.bind(_this);
    _this.brushEnd = _this.brushEnd.bind(_this);
    _this.changeVoronoi = _this.changeVoronoi.bind(_this);
    _this.doubleclickVoronoi = _this.doubleclickVoronoi.bind(_this);
    _this.clickVoronoi = _this.clickVoronoi.bind(_this);
    _this.calculateOverlay = _this.calculateOverlay.bind(_this);

    var initialOverlay = _this.calculateOverlay(props);

    _this.state = {
      overlayRegions: initialOverlay
    };
    return _this;
  }

  createClass(InteractionLayer, [{
    key: "changeVoronoi",
    value: function changeVoronoi(d, customHoverTypes) {
      //Until semiotic 2
      var dataObject = d && d.data ? _extends({}, d.data, d) : d;
      if (this.props.customHoverBehavior) this.props.customHoverBehavior(dataObject);

      if (!d) this.props.voronoiHover(null);else if (customHoverTypes === true) {
        var vorD = Object.assign({}, dataObject);
        vorD.type = vorD.type === "column-hover" ? "column-hover" : "frame-hover";
        this.props.voronoiHover(vorD);
      } else {
        var arrayWrappedHoverTypes = Array.isArray(customHoverTypes) ? customHoverTypes : [customHoverTypes];
        var mappedHoverTypes = arrayWrappedHoverTypes.map(function (c) {
          var finalC = typeof c === "function" ? c(dataObject) : c;
          return Object.assign({}, dataObject, finalC);
        });
        this.props.voronoiHover(mappedHoverTypes);
      }
    }
  }, {
    key: "clickVoronoi",
    value: function clickVoronoi(d) {
      //Until semiotic 2
      var dataObject = d.data ? _extends({}, d.data, d) : d;

      if (this.props.customClickBehavior) this.props.customClickBehavior(dataObject);
    }
  }, {
    key: "doubleclickVoronoi",
    value: function doubleclickVoronoi(d) {
      //Until semiotic 2
      var dataObject = d.data ? _extends({}, d.data, d) : d;

      if (this.props.customDoubleClickBehavior) this.props.customClickBehavior(dataObject);
    }
  }, {
    key: "brushStart",
    value: function brushStart(e, c) {
      if (this.props.interaction.start) this.props.interaction.start(e, c);
    }
  }, {
    key: "brush",
    value: function brush(e, c) {
      if (this.props.interaction.during) this.props.interaction.during(e, c);
    }
  }, {
    key: "brushEnd",
    value: function brushEnd(e, c) {
      if (this.props.interaction.end) this.props.interaction.end(e, c);
    }
  }, {
    key: "createBrush",
    value: function createBrush() {
      var _this2 = this;

      var semioticBrush = void 0,
          mappingFn = void 0,
          selectedExtent = void 0;

      var _props = this.props,
          interaction = _props.interaction,
          xScale = _props.xScale,
          yScale = _props.yScale,
          size = _props.size;
      var _interaction$extent = interaction.extent,
          extent = _interaction$extent === undefined ? interaction.brush === "xyBrush" ? [[xScale.invert(0), yScale.invert(0)], [xScale.invert(size[0]), yScale.invert(size[1])]] : interaction.brush === "xBrush" ? [xScale.invert(0), xScale.invert(size[0])] : [yScale.invert(0), yScale.invert(size[1])] : _interaction$extent;


      if (extent.indexOf(undefined) !== -1) {
        return React.createElement("g", null);
      }

      if (interaction.brush === "xBrush") {
        if (extent.indexOf(undefined) !== -1) {
          return React.createElement("g", null);
        }

        mappingFn = function mappingFn(d) {
          return !d ? null : [xScale.invert(d[0]), xScale.invert(d[1])];
        };
        semioticBrush = brushX();
        selectedExtent = extent.map(function (d) {
          return xScale(d);
        });
      } else if (interaction.brush === "yBrush") {
        if (extent.indexOf(undefined) !== -1) {
          return React.createElement("g", null);
        }

        mappingFn = function mappingFn(d) {
          return !d ? null : [yScale.invert(d[0]), yScale.invert(d[1])];
        };
        semioticBrush = brushY();
        selectedExtent = extent.map(function (d) {
          return yScale(d);
        });
      } else {
        if (extent.indexOf(undefined) !== -1 || extent[0].indexOf(undefined) !== -1 || extent[1].indexOf(undefined) !== -1) {
          return React.createElement("g", null);
        }

        semioticBrush = brush();
        mappingFn = function mappingFn(d) {
          return !d ? null : [[xScale.invert(d[0][0]), yScale.invert(d[0][1])], [xScale.invert(d[1][0]), yScale.invert(d[1][1])]];
        };
        selectedExtent = extent.map(function (d) {
          return [xScale(d[0]), yScale(d[1])];
        });
      }

      semioticBrush.extent([[0, 0], [this.props.size[0], this.props.size[1]]]).on("start", function () {
        _this2.brushStart(mappingFn(event.selection));
      }).on("brush", function () {
        _this2.brush(mappingFn(event.selection));
      }).on("end", function () {
        _this2.brushEnd(mappingFn(event.selection));
      });

      return React.createElement(
        "g",
        { className: "brush" },
        React.createElement(Brush, {
          type: interaction.brush,
          selectedExtent: selectedExtent,
          extent: extent,
          svgBrush: semioticBrush,
          size: size
        })
      );
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.setState({ overlayRegions: this.calculateOverlay(nextProps) });
    }
  }, {
    key: "calculateOverlay",
    value: function calculateOverlay(props) {
      var _this3 = this;

      var voronoiPaths = [];
      var xScale = props.xScale,
          yScale = props.yScale,
          points = props.points,
          projectedX = props.projectedX,
          projectedY = props.projectedY,
          projectedYMiddle = props.projectedYMiddle,
          size = props.size,
          overlay = props.overlay,
          _props$interactionOve = props.interactionOverflow,
          interactionOverflow = _props$interactionOve === undefined ? { top: 0, bottom: 0, left: 0, right: 0 } : _props$interactionOve;


      if (points && props.hoverAnnotation && !overlay) {
        var voronoiDataset = [];
        var voronoiUniqueHash = {};

        points.forEach(function (d) {
          var xValue = parseInt(xScale(d[projectedX]), 10);
          var yValue = parseInt(yScale(d[projectedYMiddle] || d[projectedY]), 10);
          if (xValue >= 0 && xValue <= size[0] && yValue >= 0 && yValue <= size[1] && xValue !== undefined && yValue !== undefined && isNaN(xValue) === false && isNaN(yValue) === false) {
            var pointKey = xValue + "," + yValue;
            if (!voronoiUniqueHash[pointKey]) {
              var voronoiPoint = Object.assign({}, d, {
                coincidentPoints: [d],
                voronoiX: xValue,
                voronoiY: yValue
              });
              voronoiDataset.push(voronoiPoint);
              voronoiUniqueHash[pointKey] = voronoiPoint;
            } else voronoiUniqueHash[pointKey].coincidentPoints.push(d);
          }
        });

        var voronoiXExtent = extent(voronoiDataset.map(function (d) {
          return d.voronoiX;
        }));
        var voronoiYExtent = extent(voronoiDataset.map(function (d) {
          return d.voronoiY;
        }));

        var voronoiExtent = [[Math.min(voronoiXExtent[0], -interactionOverflow.left), Math.min(voronoiYExtent[0], -interactionOverflow.top)], [Math.max(voronoiXExtent[1], size[0] + interactionOverflow.right), Math.max(voronoiYExtent[1], size[1] + interactionOverflow.bottom)]];

        var voronoiDiagram = voronoi().extent(voronoiExtent).x(function (d) {
          return d.voronoiX;
        }).y(function (d) {
          return d.voronoiY;
        });

        var voronoiData = voronoiDiagram.polygons(voronoiDataset);
        var voronoiLinks = voronoiDiagram.links(voronoiDataset);

        //create neighbors
        voronoiLinks.forEach(function (v) {
          if (!v.source.neighbors) v.source.neighbors = [];

          v.source.neighbors.push(v.target);
        });

        voronoiPaths = voronoiData.map(function (d, i) {
          return React.createElement("path", {
            onClick: function onClick() {
              _this3.clickVoronoi(voronoiDataset[i]);
            },
            onDoubleClick: function onDoubleClick() {
              _this3.doubleclickVoronoi(voronoiDataset[i]);
            },
            onMouseEnter: function onMouseEnter() {
              _this3.changeVoronoi(voronoiDataset[i], props.hoverAnnotation);
            },
            onMouseLeave: function onMouseLeave() {
              _this3.changeVoronoi();
            },
            key: "interactionVoronoi" + i,
            d: "M" + d.join("L") + "Z",
            style: { fillOpacity: 0 }
          });
        }, this);
        return voronoiPaths;
      } else if (overlay) {
        var renderedOverlay = overlay.map(function (overlayRegion, i) {
          return React.createElement(lib_2$1, _extends({
            key: "overlay-" + i,
            forceUpdate: true
          }, overlayRegion, {
            onClick: function onClick() {
              _this3.clickVoronoi(overlayRegion.onClick());
            },
            onDoubleClick: function onDoubleClick() {
              _this3.doubleclickVoronoi(overlayRegion.onDoubleClick());
            },
            onMouseEnter: function onMouseEnter() {
              _this3.changeVoronoi(overlayRegion.onMouseEnter(), props.hoverAnnotation);
            },
            onMouseLeave: function onMouseLeave() {
              _this3.changeVoronoi();
            }
          }));
        });

        return renderedOverlay;
      }
    }
  }, {
    key: "createColumnsBrush",
    value: function createColumnsBrush() {
      var _this4 = this;

      var _props2 = this.props,
          projection = _props2.projection,
          rScale = _props2.rScale,
          interaction = _props2.interaction,
          size = _props2.size,
          oColumns = _props2.oColumns;


      var semioticBrush = void 0,
          mappingFn = void 0;

      var max = rScale.domain()[1];

      var type = "yBrush";

      if (projection && projection === "horizontal") {
        type = "xBrush";
        mappingFn = function mappingFn(d) {
          return !d ? null : [rScale.invert(d[0]), rScale.invert(d[1])];
        };
      } else mappingFn = function mappingFn(d) {
        return !d ? null : [Math.abs(rScale.invert(d[1]) - max), Math.abs(rScale.invert(d[0]) - max)];
      };

      var rRange = rScale.range();

      var columnHash = oColumns;
      var brushPosition = void 0,
          selectedExtent = void 0;
      var brushes = Object.keys(columnHash).map(function (c) {
        if (projection && projection === "horizontal") {
          selectedExtent = interaction.extent[c] ? interaction.extent[c].map(function (d) {
            return rScale(d);
          }) : rRange;
          brushPosition = [0, columnHash[c].x];
          semioticBrush = brushX();
          semioticBrush.extent([[rRange[0], 0], [rRange[1], columnHash[c].width]]).on("start", function () {
            _this4.brushStart(mappingFn(event.selection), c);
          }).on("brush", function () {
            _this4.brush(mappingFn(event.selection), c);
          }).on("end", function () {
            _this4.brushEnd(mappingFn(event.selection), c);
          });
        } else {
          selectedExtent = interaction.extent[c] ? interaction.extent[c].map(function (d) {
            return rRange[1] - rScale(d);
          }).reverse() : rRange;
          brushPosition = [columnHash[c].x, 0];
          semioticBrush = brushY();
          semioticBrush.extent([[0, rRange[0]], [columnHash[c].width, rRange[1]]]).on("start", function () {
            _this4.brushStart(mappingFn(event.selection), c);
          }).on("brush", function () {
            _this4.brush(mappingFn(event.selection), c);
          }).on("end", function () {
            _this4.brushEnd(mappingFn(event.selection), c);
          });
        }

        return React.createElement(
          "g",
          { key: "column-brush-" + c, className: "brush" },
          React.createElement(Brush, {
            type: type,
            position: brushPosition,
            key: "orbrush" + c,
            selectedExtent: selectedExtent,
            svgBrush: semioticBrush,
            size: size
          })
        );
      });
      return brushes;
    }
  }, {
    key: "render",
    value: function render() {
      var semioticBrush = null;
      var _props3 = this.props,
          interaction = _props3.interaction,
          svgSize = _props3.svgSize,
          margin = _props3.margin,
          useSpans = _props3.useSpans;
      var overlayRegions = this.state.overlayRegions;
      var enabled = this.props.enabled;


      if (interaction && interaction.brush) {
        enabled = true;
        semioticBrush = this.createBrush();
      }
      if (interaction && interaction.columnsBrush) {
        enabled = true;
        semioticBrush = this.createColumnsBrush();
      }

      if (!overlayRegions && !semioticBrush) {
        return null;
      }

      return React.createElement(
        SpanOrDiv,
        {
          span: useSpans,
          className: "interaction-layer",
          style: {
            position: "absolute",
            background: "none",
            pointerEvents: "none"
          }
        },
        React.createElement(
          "svg",
          {
            height: svgSize[1],
            width: svgSize[0],
            style: { background: "none", pointerEvents: "none" }
          },
          React.createElement(
            "g",
            {
              className: "interaction-overlay",
              transform: "translate(" + margin.left + "," + margin.top + ")",
              style: { pointerEvents: enabled ? "all" : "none" }
            },
            React.createElement(
              "g",
              { className: "interaction-regions" },
              overlayRegions
            ),
            semioticBrush
          )
        )
      );
    }
  }]);
  return InteractionLayer;
}(React.Component);

InteractionLayer.propTypes = {
  name: propTypes.string,
  interaction: propTypes.object,
  overlay: propTypes.oneOfType([propTypes.array, propTypes.object]),
  oColumns: propTypes.object,
  xScale: propTypes.func,
  yScale: propTypes.func,
  rScale: propTypes.func,
  svgSize: propTypes.array
};

var twoPI = Math.PI * 2;

var drawAreaConnector = function drawAreaConnector(_ref) {
  var x1 = _ref.x1,
      x2 = _ref.x2,
      y1 = _ref.y1,
      y2 = _ref.y2,
      sizeX1 = _ref.sizeX1,
      sizeY1 = _ref.sizeY1,
      sizeX2 = _ref.sizeX2,
      sizeY2 = _ref.sizeY2;

  return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "L" + (x2 + sizeX2) + "," + (y2 + sizeY2) + "L" + (x1 + sizeX1) + "," + (y1 + sizeY1) + "Z";
};



var hexToRgb = function hexToRgb(hex) {
  if (hex.substr(0, 1).toLowerCase() === "r") {
    return hex.split("(")[1].split(")")[0].split(",");
  }
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0, 0, 0];
};

var groupBarMark = function groupBarMark(_ref2) {
  var bins = _ref2.bins,
      binMax = _ref2.binMax,
      relativeBuckets = _ref2.relativeBuckets,
      columnWidth = _ref2.columnWidth,
      projection = _ref2.projection,
      adjustedSize = _ref2.adjustedSize,
      summaryI = _ref2.summaryI,
      summary = _ref2.summary,
      renderValue = _ref2.renderValue,
      summaryStyle = _ref2.summaryStyle,
      type = _ref2.type,
      baseMarkProps = _ref2.baseMarkProps;

  var xProp = -columnWidth / 2;

  var mappedBins = [];
  var mappedPoints = [];
  var actualMax = relativeBuckets && relativeBuckets[summary.name] || binMax;

  bins.forEach(function (d, i) {
    var opacity = d.value / actualMax;
    var finalStyle = type.type === "heatmap" ? { opacity: opacity, fill: summaryStyle.fill } : summaryStyle;
    var finalColumnWidth = type.type === "heatmap" ? columnWidth : columnWidth * opacity;
    var yProp = d.y;
    var height = d.y1;
    var width = finalColumnWidth;
    var xOffset = type.type === "heatmap" ? finalColumnWidth / 2 : finalColumnWidth;
    var yOffset = d.y1 / 2;

    if (projection === "horizontal") {
      yProp = type.type === "heatmap" ? -columnWidth / 2 : columnWidth / 2 - finalColumnWidth;
      xProp = d.y - d.y1;
      height = finalColumnWidth;
      width = d.y1;
      yOffset = type.type === "heatmap" ? finalColumnWidth / 2 : finalColumnWidth;
      xOffset = d.y1 / 2;
    } else if (projection === "radial") {
      var arcGenerator = arc().innerRadius(d.y / 2).outerRadius((d.y + d.y1) / 2);

      var angle = summary.pct - summary.pct_padding;
      var startAngle = summary.pct_middle - summary.pct_padding;

      var endAngle = type.type === "heatmap" ? startAngle + angle : startAngle + angle * opacity;
      startAngle *= twoPI;
      endAngle *= twoPI;

      var arcAdjustX = adjustedSize[0] / 2;
      var arcAdjustY = adjustedSize[1] / 2;

      var arcTranslate = "translate(" + arcAdjustX + "," + arcAdjustY + ")";
      var arcCenter = arcGenerator.centroid({ startAngle: startAngle, endAngle: endAngle });
      mappedPoints.push({
        key: summary.name,
        value: d.value,
        pieces: d.pieces.map(function (p) {
          return p.piece;
        }),
        label: "Heatmap",
        x: arcCenter[0] + arcAdjustX,
        y: arcCenter[1] + arcAdjustY
      });
      mappedBins.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
        markType: "path",
        transform: arcTranslate,
        renderMode: renderValue,
        key: "groupIcon-" + summaryI + "-" + i,
        d: arcGenerator({ startAngle: startAngle, endAngle: endAngle }),
        style: finalStyle
      })));
    }
    if (projection !== "radial") {
      mappedPoints.push({
        key: summary.name,
        value: d.value,
        pieces: d.pieces.map(function (p) {
          return p.piece;
        }),
        label: "Heatmap",
        x: xProp + xOffset,
        y: yProp + yOffset
      });

      mappedBins.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
        markType: "rect",
        renderMode: renderValue,
        key: "groupIcon-" + summaryI + "-" + i,
        x: xProp,
        y: yProp,
        height: height,
        width: width,
        style: finalStyle
      })));
    }
  });

  return { marks: mappedBins, points: mappedPoints };
};

// FROM d3-svg-ribbon
function linearRibbon() {
  var _lineConstructor = line();
  var _xAccessor = function _xAccessor(d) {
    return d.x;
  };
  var _yAccessor = function _yAccessor(d) {
    return d.y;
  };
  var _rAccessor = function _rAccessor(d) {
    return d.r;
  };
  var _interpolator = curveLinearClosed;

  function _ribbon(pathData) {
    var bothPoints = buildRibbon(pathData);

    return _lineConstructor.x(_xAccessor).y(_yAccessor).curve(_interpolator)(bothPoints);
  }

  _ribbon.x = function (_value) {
    if (!arguments.length) return _xAccessor;

    _xAccessor = _value;
    return _ribbon;
  };

  _ribbon.y = function (_value) {
    if (!arguments.length) return _yAccessor;

    _yAccessor = _value;
    return _ribbon;
  };

  _ribbon.r = function (_value) {
    if (!arguments.length) return _rAccessor;

    _rAccessor = _value;
    return _ribbon;
  };

  _ribbon.interpolate = function (_value) {
    if (!arguments.length) return _interpolator;

    _interpolator = _value;
    return _ribbon;
  };

  return _ribbon;

  function offsetEdge(d) {
    var diffX = _yAccessor(d.target) - _yAccessor(d.source);
    var diffY = _xAccessor(d.target) - _xAccessor(d.source);

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 + Math.PI * 0.5;
    var angle2 = angle0 + Math.PI * 0.5;

    var x1 = _xAccessor(d.source) + _rAccessor(d.source) * Math.cos(angle1);
    var y1 = _yAccessor(d.source) - _rAccessor(d.source) * Math.sin(angle1);
    var x2 = _xAccessor(d.target) + _rAccessor(d.target) * Math.cos(angle2);
    var y2 = _yAccessor(d.target) - _rAccessor(d.target) * Math.sin(angle2);

    return { x1: x1, y1: y1, x2: x2, y2: y2 };
  }

  function buildRibbon(points) {
    var bothCode = [];
    var x = 0;
    var transformedPoints = {};

    while (x < points.length) {
      if (x !== points.length - 1) {
        transformedPoints = offsetEdge({
          source: points[x],
          target: points[x + 1]
        });
        var p1 = { x: transformedPoints.x1, y: transformedPoints.y1 };
        var p2 = { x: transformedPoints.x2, y: transformedPoints.y2 };
        bothCode.push(p1, p2);
        if (bothCode.length > 3) {
          var l = bothCode.length - 1;
          var lineA = { a: bothCode[l - 3], b: bothCode[l - 2] };
          var lineB = { a: bothCode[l - 1], b: bothCode[l] };
          var intersect = findIntersect(lineA.a.x, lineA.a.y, lineA.b.x, lineA.b.y, lineB.a.x, lineB.a.y, lineB.b.x, lineB.b.y);
          if (intersect.found === true) {
            lineA.b.x = intersect.x;
            lineA.b.y = intersect.y;
            lineB.a.x = intersect.x;
            lineB.a.y = intersect.y;
          }
        }
      }

      x++;
    }
    x--;
    //Back
    while (x >= 0) {
      if (x !== 0) {
        transformedPoints = offsetEdge({
          source: points[x],
          target: points[x - 1]
        });
        var _p = { x: transformedPoints.x1, y: transformedPoints.y1 };
        var _p2 = { x: transformedPoints.x2, y: transformedPoints.y2 };
        bothCode.push(_p, _p2);
        if (bothCode.length > 3) {
          var _l = bothCode.length - 1;
          var _lineA = { a: bothCode[_l - 3], b: bothCode[_l - 2] };
          var _lineB = { a: bothCode[_l - 1], b: bothCode[_l] };
          var _intersect = findIntersect(_lineA.a.x, _lineA.a.y, _lineA.b.x, _lineA.b.y, _lineB.a.x, _lineB.a.y, _lineB.b.x, _lineB.b.y);
          if (_intersect.found === true) {
            _lineA.b.x = _intersect.x;
            _lineA.b.y = _intersect.y;
            _lineB.a.x = _intersect.x;
            _lineB.a.y = _intersect.y;
          }
        }
      }

      x--;
    }

    return bothCode;
  }

  function findIntersect(l1x1, l1y1, l1x2, l1y2, l2x1, l2y1, l2x2, l2y2) {
    var a = void 0,
        b = void 0;

    var result = {
      x: null,
      y: null,
      found: false
    };

    var d = (l2y2 - l2y1) * (l1x2 - l1x1) - (l2x2 - l2x1) * (l1y2 - l1y1);
    if (d === 0) {
      return result;
    }
    a = l1y1 - l2y1;
    b = l1x1 - l2x1;
    var n1 = (l2x2 - l2x1) * a - (l2y2 - l2y1) * b;
    var n2 = (l1x2 - l1x1) * a - (l1y2 - l1y1) * b;
    a = n1 / d;
    b = n2 / d;

    result.x = l1x1 + a * (l1x2 - l1x1);
    result.y = l1y1 + a * (l1y2 - l1y1);

    if (a > 0 && a < 1 && b > 0 && b < 1) {
      result.found = true;
    }

    return result;
  }
}

var chuckCloseCanvasTransform = function chuckCloseCanvasTransform(canvas, context, size) {
  var pixelSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;

  var _size = slicedToArray(size, 2),
      baseWidth = _size[0],
      baseHeight = _size[1];

  var height = baseHeight + (baseHeight % pixelSize === 0 ? 0 : pixelSize - baseHeight % pixelSize);

  var width = baseWidth + (baseWidth % pixelSize === 0 ? 0 : pixelSize - baseWidth % pixelSize);

  var rgbStep = 4 * pixelSize;

  var imageData = context.getImageData(0, 0, width, height);
  var rgbaArray = [];
  var imageArray = imageData.data;

  var rgbWidth = width * 4;
  var halfPixelSize = pixelSize / 2;

  for (var i = 0; i < imageArray.length; i += rgbStep) {
    var pixelPoint = {};
    if (pixelSize === 1) {
      pixelPoint = {
        r: imageArray[i],
        g: imageArray[i + 1],
        b: imageArray[i + 2],
        a: imageArray[i + 3],
        x: i / 4 % width,
        y: Math.floor(i / 4 / width)
      };
    } else {
      var rgbHash = {};
      var totalHash = 0;

      for (var p = 0; p < pixelSize * 4; p += pixelSize * 4) {
        for (var q = 0; q < pixelSize * rgbWidth; q += rgbWidth) {
          if (imageArray[p + i + q + 3] !== -1) {
            var hashVal = "rgba(" + imageArray[p + i + q] + "," + imageArray[p + i + q + 1] + "," + imageArray[p + i + q + 2] + "," + imageArray[p + i + q + 3] + ")";
            rgbHash[hashVal] = rgbHash[hashVal] ? rgbHash[hashVal] + 1 : 1;
            totalHash += 1;
          }
        }
      }
      pixelPoint = {
        rgbEntries: Object.entries(rgbHash).sort(function (a, b) {
          return b[1] - a[1];
        }),
        totalEntries: totalHash,
        x: i / 4 % width,
        y: Math.floor(i / 4 / width),
        rmod: pixelSize
      };
    }

    rgbaArray.push(pixelPoint);
    if (pixelSize !== 1 && (i + rgbStep) % rgbWidth === 0) {
      i += rgbWidth * (pixelSize - 1);
    }
  }

  var scale = 1;
  var r = scale / 2;
  context.clearRect(0, 0, width, height);
  var circleArc = 2 * Math.PI;
  rgbaArray.forEach(function (point) {
    var currentR = r * pixelSize;
    var rStep = currentR / point.totalEntries;
    var baseX = point.x * scale + halfPixelSize;
    var baseY = point.y * scale + halfPixelSize;
    point.rgbEntries.forEach(function (e) {
      context.fillStyle = e[0];
      context.beginPath();
      context.arc(baseX, baseY, currentR, 0, circleArc);
      context.fill();
      currentR -= e[1] * rStep;
    });
  });
};

//import ReactDOM from 'react-dom'

//import MarkContext from './MarkContext'
//import Rx from 'rxjs/Rx'

var VisualizationLayer = function (_React$PureComponent) {
  inherits(VisualizationLayer, _React$PureComponent);

  function VisualizationLayer(props) {
    classCallCheck(this, VisualizationLayer);

    var _this = possibleConstructorReturn(this, (VisualizationLayer.__proto__ || Object.getPrototypeOf(VisualizationLayer)).call(this, props));

    _this.canvasDrawing = [];
    _this.state = {
      canvasDrawing: [],
      dataVersion: "",
      renderedElements: []
    };

    _this.updateVisualizationLayer = _this.updateVisualizationLayer.bind(_this);
    return _this;
  }

  createClass(VisualizationLayer, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      if (this.props.disableContext || !this.props.canvasContext || !this.canvasDrawing) return;

      var size = [this.props.size[0] + this.props.margin.left + this.props.margin.right, this.props.size[1] + this.props.margin.top + this.props.margin.bottom];

      var context = this.props.canvasContext.getContext("2d");
      context.setTransform(1, 0, 0, 1, this.props.margin.left, this.props.margin.top);
      context.clearRect(0, 0, size[0], size[1]);

      this.canvasDrawing.forEach(function (piece) {
        var style = piece.styleFn ? piece.styleFn(piece.d, piece.i) : { fill: "black", stroke: "black" };
        var fill = style.fill ? style.fill : "black";
        var stroke = style.stroke ? style.stroke : "black";
        fill = !style.fillOpacity ? fill : "rgba(" + [].concat(toConsumableArray(hexToRgb(fill)), [style.fillOpacity]) + ")";
        stroke = !style.strokeOpacity ? stroke : "rgba(" + [].concat(toConsumableArray(hexToRgb(stroke)), [style.strokeOpacity]) + ")";
        context.setTransform(1, 0, 0, 1, _this2.props.margin.left, _this2.props.margin.top);
        context.translate.apply(context, toConsumableArray(_this2.props.position));
        context.translate(piece.tx, piece.ty);
        context.fillStyle = fill;
        context.strokeStyle = stroke;
        context.lineWidth = style.strokeWidth ? style.strokeWidth : "black";

        if (piece.markProps.markType === "circle" || piece.markProps.markType === "rect" && piece.markProps.rx > 0) {
          var vizX = 0,
              vizY = 0,
              r = piece.markProps.r;
          if (piece.markProps.width) {
            var halfWidth = piece.markProps.width / 2;
            vizX = piece.markProps.x + halfWidth;
            vizY = piece.markProps.y + halfWidth;
            r = halfWidth;
          }
          context.beginPath();
          context.arc(vizX, vizY, r, 0, 2 * Math.PI);
          context.fill();
          context.stroke();
        } else if (piece.markProps.markType === "rect") {
          context.fillRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
          context.strokeRect(piece.markProps.x, piece.markProps.y, piece.markProps.width, piece.markProps.height);
        } else if (piece.markProps.markType === "path") {
          var p = new Path2D(piece.markProps.d);
          context.stroke(p);
          context.fill(p);
        } else {
          console.error("CURRENTLY UNSUPPORTED MARKTYPE FOR CANVAS RENDERING");
        }
      });
      context.setTransform(1, 0, 0, 1, 0, 0);

      if (this.props.canvasPostProcess === "chuckClose") {
        chuckCloseCanvasTransform(this.props.canvasContext, context, size);
      } else if (typeof this.props.canvasPostProcess === "function") {
        this.props.canvasPostProcess(this.props.canvasContext, context, size);
      }
    }
  }, {
    key: "updateVisualizationLayer",
    value: function updateVisualizationLayer(props) {
      var xScale = props.xScale,
          yScale = props.yScale,
          dataVersion = props.dataVersion,
          projectedCoordinateNames = props.projectedCoordinateNames,
          renderKeyFn = props.renderKeyFn,
          _props$renderPipeline = props.renderPipeline,
          renderPipeline = _props$renderPipeline === undefined ? {} : _props$renderPipeline,
          _props$baseMarkProps = props.baseMarkProps,
          baseMarkProps = _props$baseMarkProps === undefined ? {} : _props$baseMarkProps;

      this.canvasDrawing = [];
      var canvasDrawing = this.canvasDrawing;

      var renderedElements = [];
      Object.keys(renderPipeline).forEach(function (k) {
        var pipe = renderPipeline[k];
        if (pipe.data && _typeof(pipe.data) === "object" && !Array.isArray(pipe.data) || pipe.data && pipe.data.length > 0) {
          var renderedPipe = pipe.behavior(_extends({
            xScale: xScale,
            yScale: yScale,
            canvasDrawing: canvasDrawing,
            projectedCoordinateNames: projectedCoordinateNames,
            renderKeyFn: renderKeyFn,
            baseMarkProps: baseMarkProps
          }, pipe));

          if (renderedPipe && renderedPipe.length > 0) {
            renderedElements.push(React.createElement(
              "g",
              { key: k, className: k },
              renderedPipe
            ));
          }
        }
      });

      this.setState({
        renderedElements: renderedElements,
        dataVersion: dataVersion
      });
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.updateVisualizationLayer(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(np) {
      var lp = this.props;
      var propKeys = Object.keys(np);

      var update = false;
      propKeys.forEach(function (key) {
        if (lp[key] !== np[key]) {
          update = true;
        }
      });

      if (update === true || np.dataVersion && np.dataVersion !== this.state.dataVersion) {
        this.updateVisualizationLayer(np);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var props = this.props;
      var matte = props.matte,
          matteClip = props.matteClip,
          axes = props.axes,
          axesTickLines = props.axesTickLines,
          frameKey = props.frameKey,
          margin = props.margin;
      var renderedElements = this.state.renderedElements;


      var renderedAxes = axes && React.createElement(
        "g",
        { key: "visualization-axis-labels", className: "axis axis-labels" },
        axes
      );
      var renderedAxesTickLines = axesTickLines && React.createElement(
        "g",
        { key: "visualization-tick-lines", className: "axis axis-tick-lines" },
        axesTickLines
      );
      var renderedDataVisualization = (renderedAxes || renderedAxesTickLines || renderedElements && renderedElements.length > 0) && React.createElement(
        "g",
        {
          className: "data-visualization",
          key: "visualization-clip-path",
          clipPath: matteClip && matte ? "url(#matte-clip" + frameKey + ")" : undefined,
          transform: "translate(" + margin.left + "," + margin.top + ")"
        },
        renderedAxesTickLines,
        renderedElements,
        matte,
        renderedAxes
      ) || null;

      return renderedDataVisualization;
    }
  }]);
  return VisualizationLayer;
}(React.PureComponent);

VisualizationLayer.defaultProps = {
  position: [0, 0],
  margin: { left: 0, top: 0, right: 0, bottom: 0 }
};


VisualizationLayer.propTypes = {
  axes: propTypes.oneOfType([propTypes.array, propTypes.object]),
  frameKey: propTypes.string,
  xScale: propTypes.func,
  yScale: propTypes.func,
  pointData: propTypes.array,
  lineData: propTypes.array,
  areaData: propTypes.array,
  dataVersion: propTypes.string,
  canvasContext: propTypes.object,
  size: propTypes.array.isRequired,
  margin: propTypes.object
};

var defaultZeroMargin = { top: 0, bottom: 0, left: 0, right: 0 };

var Frame = function (_React$Component) {
  inherits(Frame, _React$Component);

  function Frame(props) {
    classCallCheck(this, Frame);

    var _this = possibleConstructorReturn(this, (Frame.__proto__ || Object.getPrototypeOf(Frame)).call(this, props));

    _this.state = {
      canvasContext: null,
      voronoiHover: undefined
    };
    return _this;
  }

  createClass(Frame, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.setState({ canvasContext: this.canvasContext });
    }
  }, {
    key: "getChildContext",
    value: function getChildContext() {
      return { canvas: this.canvasContext };
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          axes = _props.axes,
          axesTickLines = _props.axesTickLines,
          className = _props.className,
          extent = _props.extent,
          matte = _props.matte,
          name = _props.name,
          projectedCoordinateNames = _props.projectedCoordinateNames,
          renderPipeline = _props.renderPipeline,
          size = _props.size,
          _props$adjustedSize = _props.adjustedSize,
          adjustedSize = _props$adjustedSize === undefined ? size : _props$adjustedSize,
          title = _props.title,
          xScale = _props.xScale,
          yScale = _props.yScale,
          finalFilterDefs = _props.finalFilterDefs,
          frameKey = _props.frameKey,
          dataVersion = _props.dataVersion,
          annotations = _props.annotations,
          hoverAnnotation = _props.hoverAnnotation,
          projectedYMiddle = _props.projectedYMiddle,
          interaction = _props.interaction,
          customClickBehavior = _props.customClickBehavior,
          customHoverBehavior = _props.customHoverBehavior,
          customDoubleClickBehavior = _props.customDoubleClickBehavior,
          points = _props.points,
          _props$margin = _props.margin,
          margin = _props$margin === undefined ? defaultZeroMargin : _props$margin,
          backgroundGraphics = _props.backgroundGraphics,
          foregroundGraphics = _props.foregroundGraphics,
          beforeElements = _props.beforeElements,
          afterElements = _props.afterElements,
          downloadButton = _props.downloadButton,
          defaultSVGRule = _props.defaultSVGRule,
          defaultHTMLRule = _props.defaultHTMLRule,
          adjustedPosition = _props.adjustedPosition,
          legendSettings = _props.legendSettings,
          annotationSettings = _props.annotationSettings,
          overlay = _props.overlay,
          columns = _props.columns,
          rScale = _props.rScale,
          projection = _props.projection,
          interactionOverflow = _props.interactionOverflow,
          canvasPostProcess = _props.canvasPostProcess,
          baseMarkProps = _props.baseMarkProps,
          useSpans = _props.useSpans;
      var voronoiHover = this.state.voronoiHover;


      var areaAnnotations = [];

      var totalAnnotations = annotations ? [].concat(toConsumableArray(annotations), areaAnnotations) : areaAnnotations;

      if (voronoiHover) {
        if (Array.isArray(voronoiHover)) {
          totalAnnotations.push.apply(totalAnnotations, toConsumableArray(voronoiHover));
        } else {
          totalAnnotations.push(voronoiHover);
        }
      }

      var annotationLayer = (totalAnnotations || legendSettings) && React.createElement(AnnotationLayer, {
        legendSettings: legendSettings,
        margin: margin,
        axes: axes,
        annotationHandling: annotationSettings.layout,
        pointSizeFunction: annotationSettings.pointSizeFunction,
        labelSizeFunction: annotationSettings.labelSizeFunction,
        annotations: totalAnnotations,
        svgAnnotationRule: function svgAnnotationRule(d, i, thisALayer) {
          return defaultSVGRule(_extends({
            d: d,
            i: i,
            annotationLayer: thisALayer
          }, renderPipeline));
        },
        htmlAnnotationRule: function htmlAnnotationRule(d, i, thisALayer) {
          return defaultHTMLRule(_extends({
            d: d,
            i: i,
            annotationLayer: thisALayer
          }, renderPipeline));
        },
        useSpans: useSpans,
        size: adjustedSize,
        position: [adjustedPosition[0] + margin.left, adjustedPosition[1] + margin.top]
      });

      return React.createElement(
        SpanOrDiv,
        {
          span: useSpans,
          className: className + " frame " + name,
          style: {
            background: "none"
          }
        },
        beforeElements && React.createElement(
          SpanOrDiv,
          {
            span: useSpans,
            className: name + " frame-before-elements"
          },
          beforeElements
        ),
        React.createElement(
          SpanOrDiv,
          {
            span: useSpans,
            className: "frame-elements",
            style: { height: size[1] + "px" }
          },
          React.createElement(
            SpanOrDiv,
            {
              span: useSpans,
              className: "visualization-layer",
              style: { position: "absolute" }
            },
            React.createElement("canvas", {
              className: "frame-canvas",
              ref: function ref(canvasContext) {
                return _this2.canvasContext = canvasContext;
              },
              style: {
                position: "absolute",
                left: "0px",
                top: "0px"
              },
              width: size[0],
              height: size[1]
            }),
            React.createElement(
              "svg",
              {
                className: "visualization-layer",
                style: { position: "absolute" },
                width: size[0],
                height: size[1]
              },
              finalFilterDefs,
              backgroundGraphics && React.createElement(
                "g",
                { className: "background-graphics" },
                backgroundGraphics
              ),
              React.createElement(VisualizationLayer, {
                disableContext: this.props.disableContext,
                renderPipeline: renderPipeline,
                position: adjustedPosition,
                size: adjustedSize,
                extent: extent,
                projectedCoordinateNames: projectedCoordinateNames,
                xScale: xScale,
                yScale: yScale,
                axes: axes,
                axesTickLines: axesTickLines,
                title: title,
                frameKey: frameKey,
                canvasContext: this.state.canvasContext,
                dataVersion: dataVersion,
                matte: matte,
                margin: margin,
                canvasPostProcess: canvasPostProcess,
                baseMarkProps: baseMarkProps
              }),
              title && React.createElement(
                "g",
                { className: "frame-title" },
                title
              ),
              foregroundGraphics && React.createElement(
                "g",
                { className: "foreground-graphics" },
                foregroundGraphics
              )
            )
          ),
          React.createElement(InteractionLayer, {
            useSpans: useSpans,
            hoverAnnotation: hoverAnnotation,
            projectedX: projectedCoordinateNames.x,
            projectedY: projectedCoordinateNames.y,
            projectedYMiddle: projectedYMiddle,
            interaction: interaction,
            voronoiHover: function voronoiHover(d) {
              return _this2.setState({ voronoiHover: d });
            },
            customClickBehavior: customClickBehavior,
            customHoverBehavior: customHoverBehavior,
            customDoubleClickBehavior: customDoubleClickBehavior,
            points: points,
            position: adjustedPosition,
            margin: margin,
            size: adjustedSize,
            svgSize: size,
            xScale: xScale,
            yScale: yScale,
            enabled: true,
            overlay: overlay,
            oColumns: columns,
            rScale: rScale,
            projection: projection,
            interactionOverflow: interactionOverflow
          }),
          annotationLayer
        ),
        (downloadButton || afterElements) && React.createElement(
          SpanOrDiv,
          { span: useSpans, className: name + " frame-after-elements" },
          downloadButton,
          afterElements
        )
      );
    }
  }]);
  return Frame;
}(React.Component);

Frame.defaultProps = {
  annotationSettings: {},
  adjustedPosition: [0, 0],
  projectedCoordinateNames: { x: "x", y: "y" }
};


Frame.propTypes = {
  name: propTypes.string,
  title: propTypes.oneOfType([propTypes.string, propTypes.object]),
  margin: propTypes.oneOfType([propTypes.number, propTypes.object]),
  size: propTypes.array.isRequired,
  annotationSettings: propTypes.object,
  position: propTypes.array,
  annotations: propTypes.array,
  customHoverBehavior: propTypes.func,
  customClickBehavior: propTypes.func,
  customDoubleClickBehavior: propTypes.func,
  htmlAnnotationRules: propTypes.func,
  tooltipContent: propTypes.func,
  className: propTypes.string,
  additionalDefs: propTypes.oneOfType([propTypes.array, propTypes.object]),
  interaction: propTypes.object,
  renderFn: propTypes.oneOfType([propTypes.string, propTypes.func]),
  hoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool]),
  backgroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array]),
  foregroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array]),
  interactionOverflow: propTypes.object
};

Frame.childContextTypes = {
  canvas: propTypes.object
};

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) {
    node = children[0];
  }return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) {
    node = children[children.length - 1];
  }return node;
}

var cluster = function () {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function (node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };

  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };

  return cluster;
};

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) {
    sum += children[i].value;
  }node.value = sum;
}

var node_count = function () {
  return this.eachAfter(count);
};

var node_each = function (callback) {
  var node = this,
      current,
      next = [node],
      children,
      i,
      n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
};

var node_eachBefore = function (callback) {
  var node = this,
      nodes = [node],
      children,
      i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
};

var node_eachAfter = function (callback) {
  var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

var node_sum = function (value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) {
      sum += children[i].value;
    }node.value = sum;
  });
};

var node_sort = function (compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
};

var node_path = function (end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
};

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

var node_ancestors = function () {
  var node = this,
      nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
};

var node_descendants = function () {
  var nodes = [];
  this.each(function (node) {
    nodes.push(node);
  });
  return nodes;
};

var node_leaves = function () {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
};

var node_links = function () {
  var root = this,
      links = [];
  root.each(function (node) {
    if (node !== root) {
      // Don’t include the root’s parent, if any.
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
};

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do {
    node.height = height;
  } while ((node = node.parent) && node.height < ++height);
}

function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

function Node$2(value) {
  this._ = value;
  this.next = null;
}

var shuffle$1 = function (array) {
  var i,
      n = (array = array.slice()).length,
      head = null,
      node = head;

  while (n) {
    var next = new Node$2(array[n - 1]);
    if (node) node = node.next = next;else node = head = next;
    array[i] = array[--n];
  }

  return {
    head: head,
    tail: node
  };
};

var packEnclose$1 = function (circles) {
  return encloseN(shuffle$1(circles), []);
};

function encloses(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r - b.r;
  return dr * dr + 1e-6 > dx * dx + dy * dy;
}

// Returns the smallest circle that contains circles L and intersects circles B.
function encloseN(L, B) {
  var circle,
      l0 = null,
      l1 = L.head,
      l2,
      p1;

  switch (B.length) {
    case 1:
      circle = enclose1(B[0]);break;
    case 2:
      circle = enclose2(B[0], B[1]);break;
    case 3:
      circle = enclose3(B[0], B[1], B[2]);break;
  }

  while (l1) {
    p1 = l1._, l2 = l1.next;
    if (!circle || !encloses(circle, p1)) {

      // Temporarily truncate L before l1.
      if (l0) L.tail = l0, l0.next = null;else L.head = L.tail = null;

      B.push(p1);
      circle = encloseN(L, B); // Note: reorders L!
      B.pop();

      // Move l1 to the front of L and reconnect the truncated list L.
      if (L.head) l1.next = L.head, L.head = l1;else l1.next = null, L.head = L.tail = l1;
      l0 = L.tail, l0.next = l2;
    } else {
      l0 = l1;
    }
    l1 = l2;
  }

  L.tail = l0;
  return circle;
}

function enclose1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function enclose2(a, b) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x21 = x2 - x1,
      y21 = y2 - y1,
      r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function enclose3(a, b, c) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x3 = c.x,
      y3 = c.y,
      r3 = c.r,
      a2 = 2 * (x1 - x2),
      b2 = 2 * (y1 - y2),
      c2 = 2 * (r2 - r1),
      d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,
      a3 = 2 * (x1 - x3),
      b3 = 2 * (y1 - y3),
      c3 = 2 * (r3 - r1),
      d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / ab - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / ab - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (xa * xb + ya * yb + r1),
      C = xa * xa + ya * ya - r1 * r1,
      r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);
  return {
    x: xa + xb * r + x1,
    y: ya + yb * r + y1,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function distance1(a, b) {
  var l = a._.r;
  while (a !== b) {
    l += 2 * (a = a.next)._.r;
  }return l - b._.r;
}

function distance2(node, x, y) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab - x,
      dy = (a.y * b.r + b.y * a.r) / ab - y;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the weighted centroid.
  var aa = a.r * a.r,
      ba = b.r * b.r,
      ca = c.r * c.r,
      oa = aa + ba + ca,
      ox = aa * a.x + ba * b.x + ca * c.x,
      oy = aa * a.y + ba * b.y + ca * c.y,
      cx,
      cy,
      i,
      j,
      k,
      sj,
      sk;

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          if (sj + a._.r + b._.r > distance1(j, b)) a = j;else b = j;
          a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          if (distance1(a, k) > sk + a._.r + b._.r) a = k;else b = k;
          a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Update the weighted centroid.
    oa += ca = c._.r * c._.r;
    ox += ca * c._.x;
    oy += ca * c._.y;

    // Compute the new closest circle pair to the centroid.
    aa = distance2(a, cx = ox / oa, cy = oy / oa);
    while ((c = c.next) !== b) {
      if ((ca = distance2(c, cx, cy)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b;while ((c = c.next) !== b) {
    a.push(c._);
  }c = packEnclose$1(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) {
    a = circles[i], a.x -= c.x, a.y -= c.y;
  }return c.r;
}

var packSiblings = function (circles) {
  packEnclose(circles);
  return circles;
};

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

function constantZero() {
  return 0;
}

var constant$9 = function (x) {
  return function () {
    return x;
  };
};

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

var pack$1 = function () {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function (x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$9(+x), pack) : padding;
  };

  return pack;
};

function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) {
        children[i].r += r;
      }e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) {
        children[i].r -= r;
      }node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

var roundNode = function (node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
};

var treemapDice = function (parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
};

var partition = function () {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
};

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
var tree = function () {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function (node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function (node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };

  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };

  return tree;
};

var treemapSlice = function (parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
};

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;break;
      }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

var treemap = function () {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function (x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$9(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$9(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$9(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$9(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$9(+x), treemap) : paddingLeft;
  };

  return treemap;
};

var circleEnclosure = function circleEnclosure(_ref) {
  var d = _ref.d,
      i = _ref.i,
      circle = _ref.circle;

  var noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    coordinates: undefined,
    x: circle.x,
    y: circle.y,
    type: lib_8,
    subject: {
      radius: circle.r,
      radiusPadding: d.radiusPadding || 2
    }
  });

  if (noteData.rp) {
    switch (noteData.rp) {
      case "top":
        noteData.dx = 0;
        noteData.dy = -circle.r - noteData.rd;
        break;
      case "bottom":
        noteData.dx = 0;
        noteData.dy = circle.r + noteData.rd;
        break;
      case "left":
        noteData.dx = -circle.r - noteData.rd;
        noteData.dy = 0;
        break;
      default:
        noteData.dx = circle.r + noteData.rd;
        noteData.dy = 0;
    }
  }
  //TODO: Support .ra (setting angle)

  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var rectangleEnclosure = function rectangleEnclosure(_ref2) {
  var bboxNodes = _ref2.bboxNodes,
      d = _ref2.d,
      i = _ref2.i;
  var _d$padding = d.padding,
      padding = _d$padding === undefined ? 0 : _d$padding;

  var bbox = [[Math.min.apply(Math, toConsumableArray(bboxNodes.map(function (p) {
    return p.x0;
  }))) - padding, Math.min.apply(Math, toConsumableArray(bboxNodes.map(function (p) {
    return p.y0;
  }))) - padding], [Math.max.apply(Math, toConsumableArray(bboxNodes.map(function (p) {
    return p.x1;
  }))) + padding, Math.max.apply(Math, toConsumableArray(bboxNodes.map(function (p) {
    return p.y1;
  }))) + padding]];

  var noteData = Object.assign({
    dx: d.dx || -25,
    dy: d.dy || -25,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_5,
    x: bbox[0][0],
    y: bbox[0][1],
    subject: {
      width: bbox[1][0] - bbox[0][0],
      height: bbox[1][1] - bbox[0][1]
    }
  });

  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var pointsAlong = function pointsAlong(along) {
  return function (_ref) {
    var d = _ref.d,
        lines = _ref.lines,
        points = _ref.points,
        xScale = _ref.xScale,
        yScale = _ref.yScale,
        pointStyle = _ref.pointStyle;

    var alongScale = along === "x" ? xScale : yScale;
    along = along === "yTop" && d.yMiddle ? "yMiddle" : along;
    if (d && d[along]) {
      var _d$threshold = d.threshold,
          threshold = _d$threshold === undefined ? 1 : _d$threshold,
          _d$r = d.r,
          r = _d$r === undefined ? function () {
        return 4;
      } : _d$r,
          _d$styleFn = d.styleFn,
          styleFn = _d$styleFn === undefined ? pointStyle : _d$styleFn;

      var foundPoints = [];

      var halfThreshold = threshold / 2;

      if (lines && lines.length > 0) {
        lines.forEach(function (linedata) {
          var linePoints = linedata.data.filter(function (p) {
            var pAlong = alongScale(p[along]);
            var dAlong = alongScale(d[along]);

            return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
          });
          foundPoints.push.apply(foundPoints, toConsumableArray(linePoints));
        });
      }

      if (points && points.length > 0) {
        var pointPoints = points.filter(function (p) {
          var pAlong = alongScale(p[along]);
          var dAlong = alongScale(d[along]);

          return pAlong <= dAlong + halfThreshold && pAlong >= dAlong - halfThreshold;
        });
        foundPoints.push.apply(foundPoints, toConsumableArray(pointPoints));
      }

      return foundPoints.map(function (p, i) {
        return React.createElement("circle", {
          key: "found-circle-" + i,
          r: r(p, i),
          style: styleFn(p, i),
          cx: xScale(p.x),
          cy: yScale(p.yMiddle || p.yTop)
        });
      });
    }
    return null;
  };
};

var svgHorizontalPointsAnnotation = pointsAlong("yTop");
var svgVerticalPointsAnnotation = pointsAlong("x");

var svgHighlight = function svgHighlight(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      _ref2$points = _ref2.points,
      points = _ref2$points === undefined ? { data: [] } : _ref2$points,
      _ref2$lines = _ref2.lines,
      lines = _ref2$lines === undefined ? { data: [] } : _ref2$lines,
      _ref2$areas = _ref2.areas,
      areas = _ref2$areas === undefined ? { data: [] } : _ref2$areas,
      idAccessor = _ref2.idAccessor,
      screenCoordinates = _ref2.screenCoordinates,
      xScale = _ref2.xScale,
      yScale = _ref2.yScale;

  var dID = void 0;
  var baseID = idAccessor(_extends({}, d, d.data), i);
  if (baseID !== undefined) {
    dID = baseID;
  } else if (d.parentLine && idAccessor(d.parentLine, i) !== undefined) {
    dID = idAccessor(d.parentLine, i);
  } else if (d.parentArea && idAccessor(d.parentArea, i) !== undefined) {
    dID = idAccessor(d.parentArea, i);
  }

  var foundPoints = points.data.filter(function (p, q) {
    return idAccessor(_extends({}, p, p.data), q) === dID;
  }).map(function (p, q) {
    return React.createElement("circle", {
      key: "highlight-point-" + q,
      cx: xScale(p.x),
      cy: yScale(p.y),
      r: 5,
      fill: "none",
      stroke: "black",
      strokeWidth: 2,
      style: typeof d.style === "function" ? d.style(p.data, q) : d.style,
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p.data, q) || d.class && d.class || "")
    });
  });

  var lineGenerator = area().x(function (d) {
    return xScale(d.x);
  }).y0(function (d) {
    return yScale(d.yBottom);
  }).y1(function (d) {
    return yScale(d.yTop);
  });

  if (lines.type.interpolator) {
    lineGenerator.curve(lines.type.interpolator);
  }

  var foundLines = lines.data.filter(function (p, q) {
    return idAccessor(p, q) === dID;
  }).map(function (p, q) {
    return React.createElement("path", {
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p, q) || d.class && d.class || ""),
      key: "highlight-area-" + q,
      d: lineGenerator(p.data),
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: typeof d.style === "function" ? d.style(p, q) : d.style
    });
  });

  var foundAreas = areas.data.filter(function (p, q) {
    return idAccessor(p, q) === dID;
  }).map(function (p, q) {
    return React.createElement("path", {
      className: "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p, q) || d.class && d.class || ""),
      key: "highlight-area-" + q,
      d: "M" + p.coordinates.join("L"),
      fill: "none",
      stroke: "black",
      strokeWidth: 1,
      style: typeof d.style === "function" ? d.style(p, q) : d.style
    });
  });

  return [].concat(toConsumableArray(foundAreas), toConsumableArray(foundLines), toConsumableArray(foundPoints));
};

var svgXYAnnotation = function svgXYAnnotation(_ref3) {
  var screenCoordinates = _ref3.screenCoordinates,
      i = _ref3.i,
      d = _ref3.d;

  var laLine = React.createElement(lib_2$1, {
    className: "annotation " + d.type + " " + (d.className || "") + " ",
    key: "annotationpoint" + i,
    markType: "circle",
    cx: screenCoordinates[0],
    cy: screenCoordinates[1],
    forceUpdate: true,
    r: 5
  });
  var laLabel = void 0;
  if (d.type === "xy") {
    laLabel = React.createElement(
      lib_2$1,
      {
        markType: "text",
        key: d.label + "annotationtext" + i,
        forceUpdate: true,
        x: screenCoordinates[0],
        y: 10 + screenCoordinates[1],
        className: "annotation annotation-xy-label " + (d.className || "") + " "
      },
      d.label
    );
  }

  return [laLine, laLabel];
};

var basicReactAnnotation = function basicReactAnnotation(_ref4) {
  var screenCoordinates = _ref4.screenCoordinates,
      d = _ref4.d,
      i = _ref4.i;

  var noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: d.type,
    screenCoordinates: screenCoordinates
  });

  noteData.x = noteData.fixedX ? noteData.fixedX : screenCoordinates[0];
  noteData.y = noteData.fixedY ? noteData.fixedY : screenCoordinates[1];

  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgXAnnotation = function svgXAnnotation(_ref5) {
  var screenCoordinates = _ref5.screenCoordinates,
      d = _ref5.d,
      i = _ref5.i,
      adjustedSize = _ref5.adjustedSize;

  var noteData = Object.assign({
    dx: 50,
    dy: 20,
    y: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_4,
    x: screenCoordinates[0],
    subject: {
      x: screenCoordinates[0],
      y1: 0,
      y2: adjustedSize[1]
    }
  });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgYAnnotation = function svgYAnnotation(_ref6) {
  var screenCoordinates = _ref6.screenCoordinates,
      d = _ref6.d,
      i = _ref6.i,
      adjustedSize = _ref6.adjustedSize,
      adjustedPosition = _ref6.adjustedPosition;

  var xPosition = i * 25;

  var noteData = Object.assign({
    dx: 50,
    dy: -20,
    x: xPosition,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_4,
    y: screenCoordinates[1],
    subject: {
      y: screenCoordinates[1],
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    }
  });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgBoundsAnnotation = function svgBoundsAnnotation(_ref7) {
  var d = _ref7.d,
      i = _ref7.i,
      adjustedSize = _ref7.adjustedSize,
      xAccessor = _ref7.xAccessor,
      yAccessor = _ref7.yAccessor,
      xScale = _ref7.xScale,
      yScale = _ref7.yScale;

  var startXValue = xAccessor(d.bounds[0]);
  var startYValue = yAccessor(d.bounds[0]);
  var endXValue = xAccessor(d.bounds[1]);
  var endYValue = yAccessor(d.bounds[1]);

  var x0Position = startXValue ? xScale(startXValue) : 0;
  var y0Position = startYValue ? yScale(startYValue) : adjustedSize[1];
  var x1Position = endXValue ? xScale(endXValue) : adjustedSize[0];
  var y1Position = endYValue ? yScale(endYValue) : 0;

  var noteData = Object.assign({
    dx: 250,
    dy: -20,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_5,
    x: Math.min(x0Position, x1Position),
    y: Math.min(y0Position, y1Position),
    subject: {
      width: Math.abs(x1Position - x0Position),
      height: Math.abs(y0Position - y1Position)
    }
  });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgLineAnnotation = function svgLineAnnotation(_ref8) {
  var d = _ref8.d,
      i = _ref8.i,
      screenCoordinates = _ref8.screenCoordinates;

  var lineGenerator = line().x(function (p) {
    return p[0];
  }).y(function (p) {
    return p[1];
  });
  var lineD = lineGenerator(screenCoordinates);
  var laLine = React.createElement(lib_2$1, {
    key: d.label + "annotationline" + i,
    markType: "path",
    d: lineD,
    className: "annotation annotation-line " + (d.className || "") + " "
  });

  var laLabel = React.createElement(
    lib_2$1,
    {
      markType: "text",
      key: d.label + "annotationlinetext" + i,
      x: (screenCoordinates[0][0] + screenCoordinates[1][0]) / 2,
      y: (screenCoordinates[0][1] + screenCoordinates[1][1]) / 2,
      className: "annotation annotation-line-label " + (d.className || "") + " "
    },
    d.label
  );

  return [laLine, laLabel];
};

var svgAreaAnnotation = function svgAreaAnnotation(_ref9) {
  var d = _ref9.d,
      i = _ref9.i,
      xScale = _ref9.xScale,
      xAccessor = _ref9.xAccessor,
      yScale = _ref9.yScale,
      yAccessor = _ref9.yAccessor,
      annotationLayer = _ref9.annotationLayer;

  var mappedCoordinates = "M" + d.coordinates.map(function (p) {
    return [xScale(xAccessor(p)), yScale(yAccessor(p))];
  }).join("L") + "Z";
  var xBounds = extent(d.coordinates.map(function (p) {
    return xScale(xAccessor(p));
  }));
  var yBounds = extent(d.coordinates.map(function (p) {
    return yScale(yAccessor(p));
  }));
  var xCenter = (xBounds[0] + xBounds[1]) / 2;
  var yCenter = (yBounds[0] + yBounds[1]) / 2;

  var laLine = React.createElement(lib_2$1, {
    key: d.label + "-annotationarea-" + i,
    markType: "path",
    transform: "translate(" + annotationLayer.position + ")",
    d: mappedCoordinates,
    className: "annotation annotation-area " + (d.className || "") + " "
  });

  var laLabel = React.createElement(
    lib_2$1,
    {
      markType: "text",
      key: d.label + "-annotationtext-" + i,
      forceUpdate: true,
      x: xCenter,
      y: yCenter,
      transform: "translate(" + annotationLayer.position + ")",
      className: "annotation annotation-area-label " + (d.className || "") + " ",
      style: { textAnchor: "middle" }
    },
    d.label
  );

  return [laLine, laLabel];
};

var htmlTooltipAnnotation = function htmlTooltipAnnotation(_ref10) {
  var content = _ref10.content,
      screenCoordinates = _ref10.screenCoordinates,
      i = _ref10.i,
      d = _ref10.d;

  //To string because React gives a DOM error if it gets a date

  return React.createElement(
    "div",
    {
      key: "xylabel-" + i,
      className: "annotation annotation-xy-label " + (d.className || "") + " ",
      style: {
        position: "absolute",
        top: screenCoordinates[1] + "px",
        left: screenCoordinates[0] + "px"
      }
    },
    content
  );
};

var svgRectEncloseRule = function svgRectEncloseRule(_ref11) {
  var d = _ref11.d,
      i = _ref11.i,
      screenCoordinates = _ref11.screenCoordinates;

  var bboxNodes = screenCoordinates.map(function (p) {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });

  return rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};

var svgEncloseAnnotation = function svgEncloseAnnotation(_ref12) {
  var screenCoordinates = _ref12.screenCoordinates,
      d = _ref12.d;

  var circle = packEnclose$1(screenCoordinates.map(function (p) {
    return { x: p[0], y: p[1], r: 2 };
  }));

  return circleEnclosure({ d: d, circle: circle });
};

var array$3 = Array.prototype;

var slice$4 = array$3.slice;

var ascending$4 = function (a, b) {
  return a - b;
};

var area$2 = function (ring) {
  var i = 0,
      n = ring.length,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) {
    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  }return area;
};

var constant$10 = function (x) {
  return function () {
    return x;
  };
};

var contains = function (ring, hole) {
  var i = -1,
      n = hole.length,
      c;
  while (++i < n) {
    if (c = ringContains(ring, hole[i])) return c;
  }return 0;
};

function ringContains(ring, point) {
  var x = point[0],
      y = point[1],
      contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i;return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

var noop$4 = function () {};

var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 0.5], [0.5, 1]], [[1, 1.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 1.5]], [[1.5, 1], [1, 0.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];

var contours = function () {
  var dx = 1,
      dy = 1,
      threshold = thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = extent(values),
          start = domain[0],
          stop = domain[1];
      tz = tickStep(start, stop, tz);
      tz = range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending$4);
    }

    // Accumulate, smooth contour rings, assign holes to exterior rings.
    // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
    var layers = tz.map(function (value) {
      var polygons = [],
          holes = [];

      isorings(values, value, function (ring) {
        smooth(ring, values, value);
        if (area$2(ring) > 0) polygons.push([ring]);else holes.push(ring);
      });

      holes.forEach(function (hole) {
        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
          if (contains((polygon = polygons[i])[0], hole) !== -1) {
            polygon.push(hole);
            return;
          }
        }
      });

      return polygons;
    });

    return layers.map(function (polygons, i) {
      return {
        type: "MultiPolygon",
        value: tz[i],
        coordinates: polygons
      };
    });
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array(),
        fragmentByEnd = new Array(),
        x,
        y,
        t0,
        t1,
        t2,
        t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f,
          g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start, end] };
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function (point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]),
        _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$10(slice$4.call(_)) : constant$10(_), contours) : threshold;
  };

  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop$4, contours) : smooth === smoothLinear;
  };

  return contours;
};

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

var contourDensity = function () {
  var x = defaultX,
      y = defaultY,
      dx = 960,
      dy = 500,
      r = 20,
      // blur radius
  k = 2,
      // log2(grid cell size)
  o = r * 3,
      // grid offset, to pad for blur
  n = dx + o * 2 >> k,
      // grid width
  m = dy + o * 2 >> k,
      // grid height
  threshold = constant$10(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function (d, i, data) {
      var xi = x(d, i, data) + o >> k,
          yi = y(d, i, data) + o >> k;
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        ++values0[xi + yi * n];
      }
    });

    // TODO Optimize.
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = max(values0);
      tz = tickStep(0, stop, tz);
      tz = range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours().thresholds(tz).size([n, m])(values0).map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k;
    m = dy + o * 2 >> k;
    return density;
  }

  density.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$10(+_), density) : x;
  };

  density.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$10(+_), density) : y;
  };

  density.size = function (_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]),
        _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$10(slice$4.call(_)) : constant$10(_), density) : threshold;
  };

  density.bandwidth = function (_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
};

var tinyqueue = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
        for (var i = this.length >> 1; i >= 0; i--) {
            this._down(i);
        }
    }
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function push(item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;
        if (this.length > 0) {
            this.data[0] = this.data[this.length];
            this._down(0);
        }
        this.data.pop();
        return top;
    },

    peek: function peek() {
        return this.data[0];
    },

    _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) break;
            data[pos] = current;
            pos = parent;
        }

        data[pos] = item;
    },

    _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var len = this.length;
        var halfLen = len >> 1;
        var item = data[pos];

        while (pos < halfLen) {
            var left = (pos << 1) + 1;
            var right = left + 1;
            var best = data[left];

            if (right < len && compare(data[right], best) < 0) {
                left = right;
                best = data[right];
            }
            if (compare(best, item) >= 0) break;

            data[pos] = best;
            pos = left;
        }

        data[pos] = item;
    }
};

var polylabel_1 = polylabel;
var default_1 = polylabel;

function polylabel(polygon, precision, debug) {
    precision = precision || 1.0;

    // find the bounding box of the outer ring
    var minX, minY, maxX, maxY;
    for (var i = 0; i < polygon[0].length; i++) {
        var p = polygon[0][i];
        if (!i || p[0] < minX) minX = p[0];
        if (!i || p[1] < minY) minY = p[1];
        if (!i || p[0] > maxX) maxX = p[0];
        if (!i || p[1] > maxY) maxY = p[1];
    }

    var width = maxX - minX;
    var height = maxY - minY;
    var cellSize = Math.min(width, height);
    var h = cellSize / 2;

    // a priority queue of cells in order of their "potential" (max distance to polygon)
    var cellQueue = new tinyqueue(null, compareMax);

    if (cellSize === 0) return [minX, minY];

    // cover polygon with initial cells
    for (var x = minX; x < maxX; x += cellSize) {
        for (var y = minY; y < maxY; y += cellSize) {
            cellQueue.push(new Cell(x + h, y + h, h, polygon));
        }
    }

    // take centroid as the first best guess
    var bestCell = getCentroidCell(polygon);

    // special case for rectangular polygons
    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
    if (bboxCell.d > bestCell.d) bestCell = bboxCell;

    var numProbes = cellQueue.length;

    while (cellQueue.length) {
        // pick the most promising cell from the queue
        var cell = cellQueue.pop();

        // update the best cell if we found a better one
        if (cell.d > bestCell.d) {
            bestCell = cell;
            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
        }

        // do not drill down further if there's no chance of a better solution
        if (cell.max - bestCell.d <= precision) continue;

        // split the cell into four cells
        h = cell.h / 2;
        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
        numProbes += 4;
    }

    if (debug) {
        console.log('num probes: ' + numProbes);
        console.log('best distance: ' + bestCell.d);
    }

    return [bestCell.x, bestCell.y];
}

function compareMax(a, b) {
    return b.max - a.max;
}

function Cell(x, y, h, polygon) {
    this.x = x; // cell center x
    this.y = y; // cell center y
    this.h = h; // half the cell size
    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
}

// signed distance from point to polygon outline (negative if point is outside)
function pointToPolygonDist(x, y, polygon) {
    var inside = false;
    var minDistSq = Infinity;

    for (var k = 0; k < polygon.length; k++) {
        var ring = polygon[k];

        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            var a = ring[i];
            var b = ring[j];

            if (a[1] > y !== b[1] > y && x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;

            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
        }
    }

    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

// get polygon centroid
function getCentroidCell(polygon) {
    var area = 0;
    var x = 0;
    var y = 0;
    var points = polygon[0];

    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        var a = points[i];
        var b = points[j];
        var f = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * f;
        y += (a[1] + b[1]) * f;
        area += f * 3;
    }
    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
    return new Cell(x / area, y / area, 0, polygon);
}

// get squared distance from a point to a segment
function getSegDistSq(px, py, a, b) {

    var x = a[0];
    var y = a[1];
    var dx = b[0] - x;
    var dy = b[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = b[0];
            y = b[1];
        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

polylabel_1.default = default_1;

function contouring(_ref) {
  var areaType = _ref.areaType,
      data = _ref.data,
      finalXExtent = _ref.finalXExtent,
      finalYExtent = _ref.finalYExtent;

  var projectedAreas = [];
  if (!areaType.type) {
    areaType = { type: areaType };
  }

  var _areaType = areaType,
      _areaType$resolution = _areaType.resolution,
      resolution = _areaType$resolution === undefined ? 500 : _areaType$resolution,
      _areaType$thresholds = _areaType.thresholds,
      thresholds = _areaType$thresholds === undefined ? 10 : _areaType$thresholds,
      _areaType$bandwidth = _areaType.bandwidth,
      bandwidth = _areaType$bandwidth === undefined ? 20 : _areaType$bandwidth,
      neighborhood = _areaType.neighborhood;


  var xScale = linear$2().domain(finalXExtent).rangeRound([0, resolution]).nice();
  var yScale = linear$2().domain(finalYExtent).rangeRound([resolution, 0]).nice();

  data.forEach(function (contourData) {
    var contourProjectedAreas = contourDensity().size([resolution, resolution]).x(function (d) {
      return xScale(d[0]);
    }).y(function (d) {
      return yScale(d[1]);
    }).thresholds(thresholds).bandwidth(bandwidth)(contourData._xyfCoordinates);

    if (neighborhood) {
      contourProjectedAreas = [contourProjectedAreas[0]];
    }

    contourProjectedAreas.forEach(function (area) {
      area.parentArea = contourData;
      area.bounds = [];
      area.coordinates.forEach(function (poly) {
        poly.forEach(function (subpoly, i) {
          poly[i] = subpoly.map(function (coordpair) {
            coordpair = [xScale.invert(coordpair[0]), yScale.invert(coordpair[1])];
            return coordpair;
          });
          //Only push bounds for the main poly, not its interior rings, otherwise you end up labeling interior cutouts
          if (i === 0) {
            area.bounds.push(shapeBounds(poly[i]));
          }
        });
      });
    });
    projectedAreas = [].concat(toConsumableArray(projectedAreas), toConsumableArray(contourProjectedAreas));
  });

  return projectedAreas;
}

function shapeBounds(coordinates) {
  var left = [Infinity, 0];
  var right = [-Infinity, 0];
  var top = [0, Infinity];
  var bottom = [0, -Infinity];
  coordinates.forEach(function (d) {
    left = d[0] < left[0] ? d : left;
    right = d[0] > right[0] ? d : right;
    bottom = d[1] > bottom[1] ? d : bottom;
    top = d[1] < top[1] ? d : top;
  });

  return { center: polylabel_1([coordinates]), top: top, left: left, right: right, bottom: bottom };
}

function lineGeneratorDecorator(_ref) {
  var generator = _ref.generator,
      projectedCoordinateNames = _ref.projectedCoordinateNames,
      defined = _ref.defined,
      xScale = _ref.xScale,
      yScale = _ref.yScale,
      interpolator = _ref.interpolator,
      simpleLine = _ref.simpleLine;
  var x = projectedCoordinateNames.x,
      y = projectedCoordinateNames.y,
      yTop = projectedCoordinateNames.yTop,
      yBottom = projectedCoordinateNames.yBottom;


  generator.x(function (d) {
    return xScale(d[x]);
  }).curve(interpolator);

  if (simpleLine) {
    generator.y(function (d) {
      return yScale(d[y]);
    });
  } else {
    generator.y0(function (d) {
      return yScale(d[yBottom]);
    }).y1(function (d) {
      return yScale(d[yTop]);
    });
  }

  if (defined) {
    generator.defined(function (p, q) {
      return defined(p, q);
    });
  } else {
    generator.defined(function (p) {
      return !p._xyFrameUndefined;
    });
  }
}

function createPoints(_ref2) {
  var xScale = _ref2.xScale,
      yScale = _ref2.yScale,
      canvasDrawing = _ref2.canvasDrawing,
      data = _ref2.data,
      projectedCoordinateNames = _ref2.projectedCoordinateNames,
      customMark = _ref2.customMark,
      canvasRender = _ref2.canvasRender,
      styleFn = _ref2.styleFn,
      classFn = _ref2.classFn,
      renderKeyFn = _ref2.renderKeyFn,
      renderMode = _ref2.renderMode,
      baseMarkProps = _ref2.baseMarkProps;
  var y = projectedCoordinateNames.y,
      x = projectedCoordinateNames.x;

  var mappedPoints = [];
  data.forEach(function (d, i) {
    var dX = xScale(d[x]);
    var dY = yScale(d[y]);
    var renderedCustomMark = customMark && customMark({ d: d.data, i: i, xScale: xScale, yScale: yScale });
    var markProps = customMark ? Object.assign(baseMarkProps, renderedCustomMark.props) : _extends({}, baseMarkProps, { key: "piece-" + i, markType: "circle", r: 2 });

    if (renderedCustomMark && !renderedCustomMark.props.markType && (!canvasRender || canvasRender(d.data, i) !== true)) {
      mappedPoints.push(React.createElement(
        "g",
        {
          transform: "translate(" + dX + "," + dY + ")",
          key: renderKeyFn ? renderKeyFn(d.data, i) : "custom-point-mark-" + i,
          style: styleFn ? styleFn(d.data, i) : {},
          className: classFn ? classFn(d.data, i) : ""
        },
        renderedCustomMark
      ));
    } else {
      if (canvasRender && canvasRender(d.data, i) === true) {
        var canvasPoint = {
          type: "point",
          baseClass: "frame-piece",
          tx: dX,
          ty: dY,
          d: d,
          i: i,
          markProps: markProps,
          styleFn: styleFn,
          renderFn: renderMode,
          classFn: classFn
        };
        canvasDrawing.push(canvasPoint);
      } else {
        mappedPoints.push(clonedAppliedElement({
          baseClass: "frame-piece",
          tx: dX,
          ty: dY,
          d: d.data || d,
          i: i,
          markProps: markProps,
          styleFn: styleFn,
          renderFn: renderMode,
          renderKeyFn: renderKeyFn,
          classFn: classFn
        }));
      }
    }
  });
  return mappedPoints;
}

function createLines(_ref3) {
  var xScale = _ref3.xScale,
      yScale = _ref3.yScale,
      canvasDrawing = _ref3.canvasDrawing,
      data = _ref3.data,
      projectedCoordinateNames = _ref3.projectedCoordinateNames,
      customMark = _ref3.customMark,
      canvasRender = _ref3.canvasRender,
      styleFn = _ref3.styleFn,
      classFn = _ref3.classFn,
      renderMode = _ref3.renderMode,
      renderKeyFn = _ref3.renderKeyFn,
      type = _ref3.type,
      defined = _ref3.defined,
      baseMarkProps = _ref3.baseMarkProps;

  var customLine = (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" ? type : { type: type };
  var interpolator = customLine.interpolator ? customLine.interpolator : curveLinear;
  var lineGenerator = area();

  lineGeneratorDecorator({
    projectedCoordinateNames: projectedCoordinateNames,
    defined: defined,
    interpolator: interpolator,
    generator: lineGenerator,
    xScale: xScale,
    yScale: yScale,
    simpleLine: customLine.simpleLine
  });

  var mappedLines = [];
  data.forEach(function (d, i) {
    if (customMark && typeof customMark === "function") {
      //shim to make customLineMark work until Semiotic 2
      var compatibleData = _extends({}, d, {
        data: d.data.map(function (p) {
          return _extends({}, p.data, p);
        })
      });
      mappedLines.push(customMark({ d: compatibleData, i: i, xScale: xScale, yScale: yScale, canvasDrawing: canvasDrawing }));
    } else {
      var markProps = _extends({}, baseMarkProps, {
        markType: "path",
        d: lineGenerator(d.data.map(function (p) {
          return Object.assign({}, p.data, p);
        }))
      });
      if (canvasRender && canvasRender(d, i) === true) {
        var canvasLine = {
          type: "line",
          baseClass: "xyframe-line",
          tx: 0,
          ty: 0,
          d: d,
          i: i,
          markProps: markProps,
          styleFn: styleFn,
          renderFn: renderMode,
          classFn: classFn
        };
        canvasDrawing.push(canvasLine);
      } else {
        mappedLines.push(clonedAppliedElement({
          baseClass: "xyframe-line",
          d: d,
          i: i,
          markProps: markProps,
          styleFn: styleFn,
          renderFn: renderMode,
          renderKeyFn: renderKeyFn,
          classFn: classFn
        }));
      }
    }
  });

  if (customLine.type === "difference" && data.length === 2) {
    //Create the overlay line for the difference chart

    var diffdataA = data[0].data.map(function (basedata, baseI) {
      var linePoint = basedata.yTop > data[1].data[baseI].yTop ? basedata.yTop : basedata.yBottom;
      return {
        x: basedata.x,
        y: linePoint,
        yBottom: linePoint,
        yTop: linePoint
      };
    });

    var diffdataB = data[0].data.map(function (basedata, baseI) {
      var linePoint = data[1].data[baseI].yTop > basedata.yTop ? data[1].data[baseI].yTop : data[1].data[baseI].yBottom;
      return {
        x: basedata.x,
        y: linePoint,
        yBottom: linePoint,
        yTop: linePoint
      };
    });

    var doClassname = classFn ? "xyframe-line " + classFn(diffdataA) : "xyframe-line";

    var overLine = line();

    lineGeneratorDecorator({
      projectedCoordinateNames: projectedCoordinateNames,
      defined: defined,
      interpolator: interpolator,
      generator: overLine,
      xScale: xScale,
      yScale: yScale,
      simpleLine: true
    });

    //      let baseStyle = props.lineStyle ? props.lineStyle(diffdata, 0) : {}
    var diffOverlayA = React.createElement(lib_2$1, {
      key: "xyline-diff-a",
      className: doClassname + " difference-overlay-a",
      markType: "path",
      d: overLine(diffdataA),
      style: { fill: "none", pointerEvents: "none" }
    });
    mappedLines.push(diffOverlayA);

    var diffOverlayB = React.createElement(lib_2$1, {
      key: "xyline-diff-b",
      className: doClassname + " difference-overlay-b",
      markType: "path",
      d: overLine(diffdataB),
      style: { fill: "none", pointerEvents: "none" }
    });
    mappedLines.push(diffOverlayB);
  }

  return mappedLines;
}

function createAreas(_ref4) {
  var xScale = _ref4.xScale,
      yScale = _ref4.yScale,
      canvasDrawing = _ref4.canvasDrawing,
      data = _ref4.data,
      canvasRender = _ref4.canvasRender,
      styleFn = _ref4.styleFn,
      classFn = _ref4.classFn,
      renderKeyFn = _ref4.renderKeyFn,
      renderMode = _ref4.renderMode,
      baseMarkProps = _ref4.baseMarkProps,
      customMark = _ref4.customMark,
      type = _ref4.type;

  var areaClass = classFn || function () {
    return "";
  };
  var areaStyle = styleFn || function () {
    return {};
  };

  var renderFn = renderMode;

  if (!Array.isArray(data)) {
    data = [data];
  }

  var renderedAreas = [];

  data.forEach(function (d, i) {
    var className = "xyframe-area";
    if (areaClass) {
      className = "xyframe-area " + areaClass(d);
    }
    var drawD = "";
    if (d.type === "MultiPolygon") {
      d.coordinates.forEach(function (coord) {
        coord.forEach(function (c) {
          drawD += "M" + c.map(function (p) {
            return xScale(p[0]) + "," + yScale(p[1]);
          }).join("L") + "Z ";
        });
      });
    } else if (customMark) {
      var projectedCoordinates = d._xyfCoordinates.map(function (d) {
        return [xScale(d[0]), yScale(d[1])];
      });
      drawD = customMark({
        d: d,
        projectedCoordinates: projectedCoordinates,
        xScale: xScale,
        yScale: yScale,
        bounds: shapeBounds(projectedCoordinates)
      });
    } else {
      drawD = "M" + d._xyfCoordinates.map(function (p) {
        return xScale(p[0]) + "," + yScale(p[1]);
      }).join("L") + "Z";
    }

    var renderKey = renderKeyFn ? renderKeyFn(d, i) : "area-" + i;

    if (React.isValidElement(drawD)) {
      renderedAreas.push(drawD);
    } else if (canvasRender && canvasRender(d, i) === true) {
      var canvasArea = {
        type: "area",
        baseClass: "xyframe-area",
        tx: 0,
        ty: 0,
        d: d,
        i: i,
        markProps: { markType: "path", d: drawD },
        styleFn: areaStyle,
        renderFn: renderFn,
        classFn: function classFn() {
          return className;
        }
      };
      canvasDrawing.push(canvasArea);
    } else {
      renderedAreas.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
        key: renderKey,
        forceUpdate: true,
        renderMode: renderFn ? renderFn(d, i) : undefined,
        className: className,
        markType: "path",
        d: drawD,
        style: areaStyle(d, i)
      })));
    }
  });
  return renderedAreas;
}

function clonedAppliedElement(_ref5) {
  var tx = _ref5.tx,
      ty = _ref5.ty,
      d = _ref5.d,
      i = _ref5.i,
      markProps = _ref5.markProps,
      styleFn = _ref5.styleFn,
      renderFn = _ref5.renderFn,
      classFn = _ref5.classFn,
      renderKeyFn = _ref5.renderKeyFn,
      baseClass = _ref5.baseClass;

  markProps.style = styleFn ? styleFn(d, i) : {};

  markProps.className = baseClass;

  markProps.key = renderKeyFn ? renderKeyFn(d, i) : baseClass + "-" + (d.key === undefined ? i : d.key);

  if (tx || ty) {
    markProps.transform = "translate(" + (tx || 0) + "," + (ty || 0) + ")";
  }

  if (classFn) {
    markProps.className = baseClass + " " + classFn(d, i);
  }

  if (!markProps.markType) {
    return React.createElement("markProps", null);
  }

  markProps.renderMode = renderFn ? renderFn(d, i) : undefined;

  return React.createElement(lib_2$1, markProps);
}

function pointOnArcAtAngle(center, angle, distance) {
  var radians = Math.PI * (angle + 0.75) * 2;

  var xPosition = center[0] + distance * Math.cos(radians);
  var yPosition = center[1] + distance * Math.sin(radians);

  return [xPosition, yPosition];
}

var renderLaidOutPieces = function renderLaidOutPieces(_ref) {
  var data = _ref.data,
      shouldRender = _ref.shouldRender,
      canvasRender = _ref.canvasRender,
      canvasDrawing = _ref.canvasDrawing,
      styleFn = _ref.styleFn,
      classFn = _ref.classFn,
      baseMarkProps = _ref.baseMarkProps,
      renderKeyFn = _ref.renderKeyFn;

  if (!shouldRender) return null;
  var renderedPieces = [];
  data.forEach(function (d, i) {
    if (canvasRender && canvasRender(d) === true) {
      var canvasPiece = {
        baseClass: "orframe-piece",
        tx: d.renderElement.tx || 0,
        ty: d.renderElement.ty || 0,
        d: d.piece,
        i: i,
        markProps: d.renderElement || d,
        styleFn: styleFn,
        classFn: classFn
      };
      canvasDrawing.push(canvasPiece);
    } else {
      if (React.isValidElement(d.renderElement || d)) {
        renderedPieces.push(d.renderElement || d);
      } else {
        renderedPieces.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d.piece) : d.renderKey || "piece-render-" + i
        }, d.renderElement || d)));
      }
    }
  });

  return renderedPieces;
};

var contourMap = function contourMap(d) {
  return [d.xy.x, d.xy.y];
};

var verticalXYSorting = function verticalXYSorting(a, b) {
  return a.xy.y - b.xy.y;
};
var horizontalXYSorting = function horizontalXYSorting(a, b) {
  return b.xy.x - a.xy.x;
};
var emptyObjectReturnFn = function emptyObjectReturnFn() {
  return {};
};

function boxplotRenderFn(_ref) {
  var data = _ref.data,
      type = _ref.type,
      renderMode = _ref.renderMode,
      eventListenersGenerator = _ref.eventListenersGenerator,
      styleFn = _ref.styleFn,
      classFn = _ref.classFn,
      _ref$positionFn = _ref.positionFn,
      positionFn = _ref$positionFn === undefined ? function (position) {
    return position;
  } : _ref$positionFn,
      projection = _ref.projection,
      adjustedSize = _ref.adjustedSize,
      baseMarkProps = _ref.baseMarkProps;

  var summaryElementStylingFn = type.elementStyleFn || emptyObjectReturnFn;

  var keys = Object.keys(data);
  var renderedSummaryMarks = [];
  var summaryXYCoords = [];
  keys.forEach(function (key, summaryI) {
    var summary = data[key];
    var eventListeners = eventListenersGenerator(summary, summaryI);

    var columnWidth = summary.width;

    var thisSummaryData = summary.pieceData;

    var calculatedSummaryStyle = styleFn(thisSummaryData[0].data, summaryI);
    var calculatedSummaryClass = classFn(thisSummaryData[0].data, summaryI);

    var summaryPositionNest = void 0,
        summaryValueNest = void 0,
        translate = void 0,
        extentlineX1 = void 0,
        extentlineX2 = void 0,
        extentlineY1 = void 0,
        extentlineY2 = void 0,
        topLineX1 = void 0,
        topLineX2 = void 0,
        midLineX1 = void 0,
        midLineX2 = void 0,
        bottomLineX1 = void 0,
        bottomLineX2 = void 0,
        rectTopWidth = void 0,
        rectTopHeight = void 0,
        rectTopY = void 0,
        rectTopX = void 0,
        rectBottomWidth = void 0,
        rectBottomHeight = void 0,
        rectBottomY = void 0,
        rectBottomX = void 0,
        rectWholeWidth = void 0,
        rectWholeHeight = void 0,
        rectWholeY = void 0,
        rectWholeX = void 0,
        topLineY1 = void 0,
        topLineY2 = void 0,
        bottomLineY1 = void 0,
        bottomLineY2 = void 0,
        midLineY1 = void 0,
        midLineY2 = void 0;

    var renderValue = renderMode ? renderMode(summary, summaryI) : undefined;

    summaryValueNest = thisSummaryData.map(function (p) {
      return p.value;
    }).sort(function (a, b) {
      return a - b;
    });

    summaryValueNest = [quantile(summaryValueNest, 0.0), quantile(summaryValueNest, 0.25), quantile(summaryValueNest, 0.5), quantile(summaryValueNest, 0.75), quantile(summaryValueNest, 1.0)];

    if (projection === "vertical") {
      summaryPositionNest = thisSummaryData.map(function (p) {
        return p.scaledVerticalValue;
      }).sort(function (a, b) {
        return b - a;
      });

      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];

      var xPosition = positionFn(summary.middle, key, summaryI);

      translate = "translate(" + xPosition + ",0)";
      extentlineX1 = 0;
      extentlineX2 = 0;
      extentlineY1 = summaryPositionNest[0];
      extentlineY2 = summaryPositionNest[4];
      topLineX1 = -columnWidth / 2;
      topLineX2 = columnWidth / 2;
      midLineX1 = -columnWidth / 2;
      midLineX2 = columnWidth / 2;
      bottomLineX1 = -columnWidth / 2;
      bottomLineX2 = columnWidth / 2;
      rectBottomWidth = columnWidth;
      rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[2];
      rectBottomY = summaryPositionNest[2];
      rectBottomX = -columnWidth / 2;
      rectTopWidth = columnWidth;
      rectTopHeight = summaryPositionNest[2] - summaryPositionNest[3];
      rectWholeWidth = columnWidth;
      rectWholeHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectWholeY = summaryPositionNest[3];
      rectWholeX = -columnWidth / 2;
      rectTopY = summaryPositionNest[3];
      rectTopX = -columnWidth / 2;
      topLineY1 = summaryPositionNest[0];
      topLineY2 = summaryPositionNest[0];
      bottomLineY1 = summaryPositionNest[4];
      bottomLineY2 = summaryPositionNest[4];
      midLineY1 = summaryPositionNest[2];
      midLineY2 = summaryPositionNest[2];

      summaryXYCoords.push({
        label: "Maximum",
        key: key,
        summaryPieceName: "max",
        x: xPosition,
        y: summaryPositionNest[4],
        value: summaryValueNest[4]
      }, {
        label: "3rd Quartile",
        key: key,
        summaryPieceName: "q3area",
        x: xPosition,
        y: summaryPositionNest[3],
        value: summaryValueNest[3]
      }, {
        label: "Median",
        key: key,
        summaryPieceName: "median",
        x: xPosition,
        y: summaryPositionNest[2],
        value: summaryValueNest[2]
      }, {
        label: "1st Quartile",
        key: key,
        summaryPieceName: "q1area",
        x: xPosition,
        y: summaryPositionNest[1],
        value: summaryValueNest[1]
      }, {
        label: "Minimum",
        key: key,
        summaryPieceName: "min",
        x: xPosition,
        y: summaryPositionNest[0],
        value: summaryValueNest[0]
      });
    } else if (projection === "horizontal") {
      summaryPositionNest = thisSummaryData.map(function (p) {
        return p.scaledValue;
      }).sort(function (a, b) {
        return a - b;
      });

      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];

      var yPosition = positionFn(summary.middle, key, summaryI);

      translate = "translate(0," + yPosition + ")";
      extentlineY1 = 0;
      extentlineY2 = 0;
      extentlineX1 = summaryPositionNest[0];
      extentlineX2 = summaryPositionNest[4];
      topLineY1 = -columnWidth / 2;
      topLineY2 = columnWidth / 2;
      midLineY1 = -columnWidth / 2;
      midLineY2 = columnWidth / 2;
      bottomLineY1 = -columnWidth / 2;
      bottomLineY2 = columnWidth / 2;
      rectTopHeight = columnWidth;
      rectTopWidth = summaryPositionNest[3] - summaryPositionNest[2];
      rectTopX = summaryPositionNest[2];
      rectTopY = -columnWidth / 2;
      rectBottomHeight = columnWidth;
      rectBottomWidth = summaryPositionNest[2] - summaryPositionNest[1];
      rectBottomX = summaryPositionNest[1];
      rectBottomY = -columnWidth / 2;
      rectWholeHeight = columnWidth;
      rectWholeWidth = summaryPositionNest[3] - summaryPositionNest[1];
      rectWholeX = summaryPositionNest[1];
      rectWholeY = -columnWidth / 2;
      topLineX1 = summaryPositionNest[0];
      topLineX2 = summaryPositionNest[0];
      bottomLineX1 = summaryPositionNest[4];
      bottomLineX2 = summaryPositionNest[4];
      midLineX1 = summaryPositionNest[2];
      midLineX2 = summaryPositionNest[2];

      summaryXYCoords.push({
        label: "Maximum",
        key: key,
        summaryPieceName: "max",
        x: summaryPositionNest[4],
        y: yPosition,
        value: summaryValueNest[4]
      }, {
        label: "3rd Quartile",
        key: key,
        summaryPieceName: "q3area",
        x: summaryPositionNest[3],
        y: yPosition,
        value: summaryValueNest[3]
      }, {
        label: "Median",
        key: key,
        summaryPieceName: "median",
        x: summaryPositionNest[2],
        y: yPosition,
        value: summaryValueNest[2]
      }, {
        label: "1st Quartile",
        key: key,
        summaryPieceName: "q1area",
        x: summaryPositionNest[1],
        y: yPosition,
        value: summaryValueNest[1]
      }, {
        label: "Minimum",
        key: key,
        summaryPieceName: "min",
        x: summaryPositionNest[0],
        y: yPosition,
        value: summaryValueNest[0]
      });
    }

    if (projection === "radial") {
      summaryPositionNest = thisSummaryData.map(function (p) {
        return p.scaledValue;
      }).sort(function (a, b) {
        return a - b;
      });

      summaryPositionNest = [quantile(summaryPositionNest, 0.0), quantile(summaryPositionNest, 0.25), quantile(summaryPositionNest, 0.5), quantile(summaryPositionNest, 0.75), quantile(summaryPositionNest, 1.0)];

      extentlineX1 = 0;
      extentlineX2 = 0;
      extentlineY1 = summaryPositionNest[0];
      extentlineY2 = summaryPositionNest[4];
      topLineX1 = -columnWidth / 2;
      topLineX2 = columnWidth / 2;
      midLineX1 = -columnWidth / 2;
      midLineX2 = columnWidth / 2;
      bottomLineX1 = -columnWidth / 2;
      bottomLineX2 = columnWidth / 2;
      rectTopWidth = columnWidth;
      rectTopHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectTopY = summaryPositionNest[3];
      rectTopX = -columnWidth / 2;
      rectBottomWidth = columnWidth;
      rectBottomHeight = summaryPositionNest[1] - summaryPositionNest[3];
      rectBottomY = summaryPositionNest[3];
      rectBottomX = -columnWidth / 2;
      topLineY1 = summaryPositionNest[0];
      topLineY2 = summaryPositionNest[0];
      bottomLineY1 = summaryPositionNest[4];
      bottomLineY2 = summaryPositionNest[4];
      midLineY1 = summaryPositionNest[2];
      midLineY2 = summaryPositionNest[2];

      var twoPI = Math.PI * 2;

      var bottomLineArcGenerator = arc().innerRadius(bottomLineY1 / 2).outerRadius(bottomLineY1 / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var topLineArcGenerator = arc().innerRadius(topLineY1 / 2).outerRadius(topLineY1 / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var midLineArcGenerator = arc().innerRadius(midLineY1 / 2).outerRadius(midLineY1 / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var bodyArcTopGenerator = arc().innerRadius(summaryPositionNest[1] / 2).outerRadius(midLineY1 / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var bodyArcBottomGenerator = arc().innerRadius(midLineY1 / 2).outerRadius(summaryPositionNest[3] / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var bodyArcWholeGenerator = arc().innerRadius(summaryPositionNest[1] / 2).outerRadius(summaryPositionNest[3] / 2);
      //        .padAngle(summary.pct_padding * twoPI);

      var startAngle = summary.pct_start + summary.pct_padding / 2;
      var endAngle = summary.pct + summary.pct_start - summary.pct_padding / 2;
      var midAngle = summary.pct / 2 + summary.pct_start;
      startAngle *= twoPI;
      endAngle *= twoPI;

      var radialAdjustX = adjustedSize[0] / 2;

      var radialAdjustY = adjustedSize[1] / 2;

      //        const bottomPoint = bottomLineArcGenerator.centroid({ startAngle, endAngle })
      //        const topPoint = topLineArcGenerator.centroid({ startAngle, endAngle })
      var bottomPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[4] / 2);
      var topPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[0] / 2);
      var thirdPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[3] / 2);
      var midPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[2] / 2);
      var firstPoint = pointOnArcAtAngle([0, 0], midAngle, summaryPositionNest[1] / 2);

      summaryXYCoords.push({
        label: "Minimum",
        key: key,
        summaryPieceName: "min",
        x: topPoint[0] + radialAdjustX,
        y: topPoint[1] + radialAdjustY,
        value: summaryValueNest[0]
      }, {
        label: "1st Quartile",
        key: key,
        summaryPieceName: "q3area",
        x: firstPoint[0] + radialAdjustX,
        y: firstPoint[1] + radialAdjustY,
        value: summaryValueNest[1]
      }, {
        label: "Median",
        key: key,
        summaryPieceName: "median",
        x: midPoint[0] + radialAdjustX,
        y: midPoint[1] + radialAdjustY,
        value: summaryValueNest[2]
      }, {
        label: "3rd Quartile",
        key: key,
        summaryPieceName: "q1area",
        x: thirdPoint[0] + radialAdjustX,
        y: thirdPoint[1] + radialAdjustY,
        value: summaryValueNest[3]
      }, {
        label: "Maximum",
        key: key,
        summaryPieceName: "max",
        x: bottomPoint[0] + radialAdjustX,
        y: bottomPoint[1] + radialAdjustY,
        value: summaryValueNest[4]
      });
      translate = "translate(" + radialAdjustX + "," + radialAdjustY + ")";

      renderedSummaryMarks.push(React.createElement(
        "g",
        _extends({}, eventListeners, {
          className: calculatedSummaryClass,
          transform: translate,
          key: "summaryPiece-" + summaryI
        }),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "line",
          x1: bottomPoint[0],
          x2: topPoint[0],
          y1: bottomPoint[1],
          y2: topPoint[1],
          style: Object.assign({ strokeWidth: 2 }, calculatedSummaryStyle, summaryElementStylingFn("whisker"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: topLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("max"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: midLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("median"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: bottomLineArcGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, { fill: "none" }, summaryElementStylingFn("min"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: bodyArcWholeGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({ strokeWidth: 4 }, calculatedSummaryStyle, summaryElementStylingFn("iqrarea"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: bodyArcTopGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q3area"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "path",
          d: bodyArcBottomGenerator({ startAngle: startAngle, endAngle: endAngle }),
          style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q1area"))
        }))
      ));
    } else {
      renderedSummaryMarks.push(React.createElement(
        "g",
        _extends({}, eventListeners, {
          className: calculatedSummaryClass,
          transform: translate,
          key: "summaryPiece-" + summaryI
        }),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "line",
          x1: extentlineX1,
          x2: extentlineX2,
          y1: extentlineY1,
          y2: extentlineY2,
          style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("whisker"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "line",
          x1: topLineX1,
          x2: topLineX2,
          y1: topLineY1,
          y2: topLineY2,
          style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("min"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "line",
          x1: bottomLineX1,
          x2: bottomLineX2,
          y1: bottomLineY1,
          y2: bottomLineY2,
          style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("max"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "rect",
          x: rectWholeX,
          width: rectWholeWidth,
          y: rectWholeY,
          height: rectWholeHeight,
          style: Object.assign({ strokeWidth: "1px" }, calculatedSummaryStyle, summaryElementStylingFn("iqrarea"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "rect",
          x: rectTopX,
          width: rectTopWidth,
          y: rectTopY,
          height: rectTopHeight,
          style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q3area"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "rect",
          x: rectBottomX,
          width: rectBottomWidth,
          y: rectBottomY,
          height: rectBottomHeight,
          style: Object.assign({}, calculatedSummaryStyle, { fill: "none", stroke: "none" }, summaryElementStylingFn("q1area"))
        })),
        React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          renderMode: renderValue,
          markType: "line",
          x1: midLineX1,
          x2: midLineX2,
          y1: midLineY1,
          y2: midLineY2,
          style: Object.assign({ strokeWidth: "2px" }, calculatedSummaryStyle, summaryElementStylingFn("median"))
        }))
      ));
    }
  });

  return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}

function contourRenderFn(_ref2) {
  var data = _ref2.data,
      type = _ref2.type,
      renderMode = _ref2.renderMode,
      eventListenersGenerator = _ref2.eventListenersGenerator,
      styleFn = _ref2.styleFn,
      classFn = _ref2.classFn,
      adjustedSize = _ref2.adjustedSize,
      baseMarkProps = _ref2.baseMarkProps;

  var keys = Object.keys(data);
  var renderedSummaryMarks = [];
  var summaryXYCoords = [];

  keys.forEach(function (key, ordsetI) {
    var ordset = data[key];
    var renderValue = renderMode && renderMode(ordset, ordsetI);
    type.thresholds = type.thresholds || 8;
    type.bandwidth = type.bandwidth || 12;
    type.resolution = type.resolution || 1000;

    var projectedOrd = [{ id: ordset, _xyfCoordinates: ordset.xyData.map(contourMap) }];

    var oContours = contouring({
      areaType: type,
      data: projectedOrd,
      projectedX: "x",
      projectedY: "y",
      finalXExtent: [0, adjustedSize[0]],
      finalYExtent: [0, adjustedSize[1]]
    });
    var contourMarks = [];
    oContours.forEach(function (d, i) {
      d.coordinates.forEach(function (coords, ii) {
        var eventListeners = eventListenersGenerator(d, i);
        contourMarks.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, eventListeners, {
          renderMode: renderValue,
          simpleInterpolate: true,
          key: i + "-" + ii,
          style: styleFn(ordset.pieceData[0].data, ordsetI),
          className: classFn(ordset.pieceData[0].data, ordsetI),
          markType: "path",
          d: "M" + d.coordinates[0].map(function (p) {
            return p.join(",");
          }).join("L") + "Z"
        })));
      });
    });

    renderedSummaryMarks.push(React.createElement(
      "g",
      { key: "contour-container-" + ordsetI },
      contourMarks
    ));
  });
  return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}

function axisGenerator(axisProps, i, axisScale) {
  return React.createElement(Axis, {
    label: axisProps.label,
    key: axisProps.key || "orframe-summary-axis-" + i,
    orient: axisProps.orient,
    size: axisProps.size,
    ticks: axisProps.ticks,
    tickSize: axisProps.tickSize,
    tickFormat: axisProps.tickFormat,
    tickValues: axisProps.tickValues,
    format: axisProps.format,
    rotate: axisProps.rotate,
    scale: axisScale,
    className: axisProps.className,
    name: axisProps.name
  });
}

function bucketizedRenderingFn(_ref3) {
  var data = _ref3.data,
      type = _ref3.type,
      renderMode = _ref3.renderMode,
      eventListenersGenerator = _ref3.eventListenersGenerator,
      styleFn = _ref3.styleFn,
      classFn = _ref3.classFn,
      projection = _ref3.projection,
      adjustedSize = _ref3.adjustedSize,
      chartSize = _ref3.chartSize,
      baseMarkProps = _ref3.baseMarkProps;

  var renderedSummaryMarks = [];
  var summaryXYCoords = [];

  var buckets = type.bins || 25;
  var relativeBuckets = type.relative ? {} : false;
  var summaryValueAccessor = type.binValue || function (d) {
    return d.length;
  };
  var axisCreator = void 0;
  if (type.axis) {
    type.axis.orient = projection === "horizontal" && ["left", "right"].indexOf(type.axis.orient) === -1 ? "left" : type.axis.orient;
    type.axis.orient = projection === "vertical" && ["bottom", "top"].indexOf(type.axis.orient) === -1 ? "bottom" : type.axis.orient;
    axisCreator = axisGenerator;
    if (projection === "radial") {
      console.error("Summary axes cannot be drawn for radial histograms");
      axisCreator = function axisCreator() {
        return null;
      };
    }
  }

  var bucketSize = chartSize / buckets;

  var keys = Object.keys(data);
  var binMax = 0;
  var calculatedBins = keys.map(function (key, summaryI) {
    var summary = data[key];

    var thisSummaryData = summary.xyData;

    var xySorting = projection === "vertical" ? verticalXYSorting : horizontalXYSorting;

    var summaryPositionNest = thisSummaryData.sort(xySorting);

    var violinHist = histogram();
    var binDomain = projection === "vertical" ? [0, chartSize] : [0, chartSize];

    var binOffset = 0;
    var binBuckets = [];

    for (var x = 0; x < buckets; x++) {
      binBuckets.push(binDomain[0] + x / buckets * (chartSize - binOffset));
    }
    //    binBuckets.push(binDomain[1]);

    var xyValue = projection === "vertical" ? function (p) {
      return p.piece.scaledVerticalValue;
    } : function (p) {
      return p.piece.scaledValue;
    };

    var keyBins = void 0;
    if (type.useBins === false) {
      var calculatedValues = summaryPositionNest.map(function (value) {
        return xyValue(value);
      });
      keyBins = summaryPositionNest.map(function (value, i) {
        var bucketArray = [];
        bucketArray.x0 = calculatedValues[i] - 1;
        bucketArray.x1 = calculatedValues[i] + 1;
        bucketArray.push(value);
        return bucketArray;
      }).sort(function (a, b) {
        return a.x0 - b.x0;
      });
      bucketSize = 2;
    } else {
      keyBins = violinHist.domain(binDomain).thresholds(binBuckets).value(xyValue)(summaryPositionNest);
    }

    keyBins = keyBins.map(function (d) {
      return {
        y: d.x0,
        y1: d.x1 - d.x0,
        pieces: d,
        value: summaryValueAccessor(d.map(function (p) {
          return p.piece.data;
        }))
      };
    });

    if (type.type === "histogram" || type.type === "heatmap") {
      keyBins = keyBins.filter(function (d) {
        return d.value !== 0;
      });
    }

    var relativeMax = keyBins.length === 0 ? 0 : max(keyBins.map(function (d) {
      return d.value;
    }));
    if (relativeBuckets) {
      relativeBuckets[key] = relativeMax;
    }

    binMax = Math.max(binMax, relativeMax);

    return { bins: keyBins, summary: summary, summaryI: summaryI, thisSummaryData: thisSummaryData };
  });
  calculatedBins.forEach(function (_ref4) {
    var bins = _ref4.bins,
        summary = _ref4.summary,
        summaryI = _ref4.summaryI,
        thisSummaryData = _ref4.thisSummaryData;

    var eventListeners = eventListenersGenerator(summary, summaryI);
    var columnWidth = summary.width;
    var renderValue = renderMode && renderMode(summary, summaryI);

    var calculatedSummaryStyle = thisSummaryData[0] ? styleFn(thisSummaryData[0].piece.data, summaryI) : {};
    var calculatedSummaryClass = thisSummaryData[0] ? classFn(thisSummaryData[0].piece.data, summaryI) : "";

    var translate = [summary.middle, 0];
    if (projection === "horizontal") {
      translate = [bucketSize, summary.middle];
    } else if (projection === "radial") {
      translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
    }

    var actualMax = relativeBuckets && relativeBuckets[summary.name] || binMax;

    if (type.type === "heatmap" || type.type === "histogram") {
      var mappedBars = groupBarMark({
        bins: bins,
        binMax: binMax,
        relativeBuckets: relativeBuckets,
        columnWidth: columnWidth,
        bucketSize: bucketSize,
        projection: projection,
        adjustedSize: adjustedSize,
        chartSize: chartSize,
        summaryI: summaryI,
        data: data,
        summary: summary,
        renderValue: renderValue,
        summaryStyle: calculatedSummaryStyle,
        type: type,
        baseMarkProps: baseMarkProps
      });
      var tiles = mappedBars.marks;
      if (projection === "radial") {
        translate = [0, 0];
      }

      if (type.axis && type.type === "histogram") {
        var axisTranslate = "translate(" + summary.x + ",0)";
        var axisDomain = [0, actualMax];
        if (projection === "horizontal") {
          axisTranslate = "translate(" + bucketSize + "," + summary.x + ")";
          axisDomain = [actualMax, 0];
        } else if (projection === "radial") {
          axisTranslate = translate(0, 0);
        }

        var axisWidth = projection === "horizontal" ? adjustedSize[0] : columnWidth;
        var axisHeight = projection === "vertical" ? adjustedSize[1] : columnWidth;
        type.axis.size = [axisWidth, axisHeight];
        var axisScale = linear$2().domain(axisDomain).range([0, columnWidth]);
        var renderedSummaryAxis = axisCreator(type.axis, summaryI, axisScale);

        renderedSummaryMarks.push(React.createElement(
          "g",
          {
            className: "summary-axis",
            key: "summaryPiece-axis-" + summaryI,
            transform: axisTranslate
          },
          renderedSummaryAxis
        ));
      }
      mappedBars.points.forEach(function (d) {
        d.x += translate[0];
        d.y += translate[1];
      });

      summaryXYCoords.push.apply(summaryXYCoords, toConsumableArray(mappedBars.points));
      renderedSummaryMarks.push(React.createElement(
        "g",
        _extends({}, eventListeners, {
          transform: "translate(" + translate + ")",
          key: "summaryPiece-" + summaryI
        }),
        tiles
      ));
    } else if (type.type === "violin") {
      bins[0].y = bins[0].y - bucketSize / 2;
      bins[bins.length - 1].y = bins[bins.length - 1].y + bucketSize / 2;
      var violinArea = area().curve(type.curve || curveCatmullRom);

      var violinPoints = [];

      if (projection === "horizontal") {
        bins.forEach(function (summaryPoint) {
          var xValue = summaryPoint.y - bucketSize / 2;
          var yValue = summaryPoint.value / actualMax * columnWidth / 2;

          violinPoints.push({
            x: xValue,
            y0: -yValue,
            y1: yValue
          });
          summaryXYCoords.push({
            key: summary.name,
            x: xValue + translate[0],
            y: yValue + translate[1],
            pieces: summaryPoint.pieces.map(function (d) {
              return d.piece;
            }),
            value: summaryPoint.value
          });
        });
        violinArea.x(function (d) {
          return d.x;
        }).y0(function (d) {
          return d.y0;
        }).y1(function (d) {
          return d.y1;
        }).defined(function (d, i) {
          return d.y0 !== 0 || violinPoints[i - 1] && violinPoints[i - 1].y0 !== 0 || violinPoints[i + 1] && violinPoints[i + 1].y0 !== 0;
        });
      } else if (projection === "vertical") {
        bins.forEach(function (summaryPoint) {
          var yValue = summaryPoint.y + bucketSize / 2;
          var xValue = summaryPoint.value / actualMax * columnWidth / 2;

          violinPoints.push({
            y: yValue,
            x0: -xValue,
            x1: xValue
          });

          summaryXYCoords.push({
            key: summary.name,
            x: xValue + translate[0],
            y: yValue + translate[1],
            pieces: summaryPoint.pieces.map(function (d) {
              return d.piece;
            }),
            value: summaryPoint.value
          });
        });
        violinArea.y(function (d) {
          return d.y;
        }).x0(function (d) {
          return d.x0;
        }).x1(function (d) {
          return d.x1;
        }).defined(function (d, i) {
          return d.x0 !== 0 || violinPoints[i - 1] && violinPoints[i - 1].x0 !== 0 || violinPoints[i + 1] && violinPoints[i + 1].x0 !== 0;
        });
      } else if (projection === "radial") {
        var angle = summary.pct - summary.pct_padding / 2;
        var midAngle = summary.pct_middle;
        violinPoints = bins;
        violinArea = function violinArea(inbins) {
          var forward = [];
          var backward = [];
          inbins.forEach(function (bin) {
            var outsidePoint = pointOnArcAtAngle([0, 0], midAngle + angle * bin.value / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2);
            var insidePoint = pointOnArcAtAngle([0, 0], midAngle - angle * bin.value / actualMax / 2, (bin.y + bin.y1 - bucketSize / 2) / 2);

            //Ugh a terrible side effect has appeared
            summaryXYCoords.push({
              key: summary.name,
              x: insidePoint[0] + translate[0],
              y: insidePoint[1] + translate[1],
              pieces: bin.pieces.map(function (d) {
                return d.piece;
              }),
              value: bin.value
            });
            summaryXYCoords.push({
              key: summary.name,
              x: outsidePoint[0] + translate[0],
              y: outsidePoint[1] + translate[1],
              pieces: bin.pieces.map(function (d) {
                return d.piece;
              }),
              value: bin.value
            });

            forward.push(outsidePoint);
            backward.push(insidePoint);
          });
          return "M" + forward.map(function (d) {
            return d.join(",");
          }).join("L") + "L" + backward.reverse().map(function (d) {
            return d.join(",");
          }).join("L") + "Z";
        };
      }

      renderedSummaryMarks.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
        transform: "translate(" + translate + ")",
        key: "summaryPiece-" + summaryI
      }, eventListeners, {
        renderMode: renderValue,
        markType: "path",
        className: calculatedSummaryClass,
        style: calculatedSummaryStyle,
        d: violinArea(violinPoints)
      })));
    } else if (type.type === "joy") {
      var zeroedStart = Object.assign({}, bins[0], { value: 0 });
      var zeroedEnd = Object.assign({}, bins[bins.length - 1], { value: 0 });
      //Joy plots need to visually signify the zero baseline with their start and end position

      zeroedStart.y = zeroedStart.y - bucketSize / 2;
      zeroedEnd.y = zeroedEnd.y + bucketSize / 2;

      var joyBins = [zeroedStart].concat(toConsumableArray(bins), [zeroedEnd]);
      var joyPoints = [];

      var joyArea = line().curve(type.curve || curveCatmullRom).x(function (d) {
        return d.x;
      }).y(function (d) {
        return d.y;
      });

      var joyHeight = type.amplitude || 0;

      if (projection === "horizontal") {
        joyBins.forEach(function (summaryPoint, i) {
          var xValue = summaryPoint.y - bucketSize / 2;
          var yValue = -summaryPoint.value / actualMax * (columnWidth + joyHeight) + columnWidth / 2;

          joyPoints.push({
            y: yValue,
            x: xValue
          });

          //Don't make an interaction point for the first or last
          if (i !== 0 && i !== joyBins.length - 1) {
            summaryXYCoords.push({
              key: summary.name,
              x: xValue + translate[0],
              y: yValue + translate[1],
              pieces: summaryPoint.pieces.map(function (d) {
                return d.piece;
              }),
              value: summaryPoint.value
            });
          }
        });
      } else if (projection === "vertical") {
        joyBins.forEach(function (summaryPoint) {
          var yValue = summaryPoint.y + bucketSize / 2;
          var xValue = -summaryPoint.value / actualMax * (columnWidth + joyHeight) + columnWidth / 2;

          joyPoints.push({
            y: yValue,
            x: xValue
          });

          summaryXYCoords.push({
            key: summary.name,
            x: xValue + translate[0],
            y: yValue + translate[1],
            pieces: summaryPoint.pieces.map(function (d) {
              return d.piece;
            }),
            value: summaryPoint.value
          });
        });
      } else if (projection === "radial") {
        var _angle = summary.pct - summary.pct_padding / 2;
        var _midAngle = summary.pct_start + summary.pct_padding / 2;

        translate = [0, 0];
        joyPoints = joyBins;
        joyArea = function joyArea(inbins) {
          var forward = [];
          inbins.forEach(function (bin) {
            var outsidePoint = pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], _midAngle + _angle * bin.value / actualMax, (bin.y + bin.y1 - bucketSize / 2) / 2);
            //Ugh a terrible side effect has appeared
            summaryXYCoords.push({
              key: summary.name,
              x: outsidePoint[0] + translate[0],
              y: outsidePoint[1] + translate[1],
              pieces: bin.pieces.map(function (d) {
                return d.piece;
              }),
              value: bin.value
            });

            forward.push(outsidePoint);
          });
          return "M" + forward.map(function (d) {
            return d.join(",");
          }).join("L") + "Z";
        };
      }

      renderedSummaryMarks.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
        transform: "translate(" + translate + ")",
        key: "summaryPiece-" + summaryI
      }, eventListeners, {
        renderMode: renderValue,
        markType: "path",
        className: calculatedSummaryClass,
        style: calculatedSummaryStyle,
        d: joyArea(joyPoints)
      })));
    }
  });

  return { marks: renderedSummaryMarks, xyPoints: summaryXYCoords };
}

var drawSummaries = function drawSummaries(_ref5) {
  var data = _ref5.data,
      type = _ref5.type,
      renderMode = _ref5.renderMode,
      eventListenersGenerator = _ref5.eventListenersGenerator,
      styleFn = _ref5.styleFn,
      classFn = _ref5.classFn,
      positionFn = _ref5.positionFn,
      projection = _ref5.projection,
      adjustedSize = _ref5.adjustedSize,
      canvasRender = _ref5.canvasRender,
      canvasDrawing = _ref5.canvasDrawing,
      baseMarkProps = _ref5.baseMarkProps;

  if (!type || !type.type) return;
  type = typeof type === "string" ? { type: type } : type;
  var chartSize = projection === "vertical" ? adjustedSize[1] : adjustedSize[0];
  return orFrameSummaryRenderer({
    data: data,
    type: type,
    renderMode: renderMode,
    eventListenersGenerator: eventListenersGenerator,
    styleFn: styleFn,
    classFn: classFn,
    positionFn: positionFn,
    projection: projection,
    adjustedSize: adjustedSize,
    chartSize: chartSize,
    canvasRender: canvasRender,
    canvasDrawing: canvasDrawing,
    baseMarkProps: baseMarkProps
  });
};

var renderLaidOutSummaries = function renderLaidOutSummaries(_ref6) {
  var data = _ref6.data;

  return data;
};

function roundToTenth(number) {
  return Math.round(number * 10) / 10;
}

var circlePath = function circlePath(cx, cy, r) {
  return ["M", roundToTenth(cx - r), roundToTenth(cy), "a", r, r, 0, 1, 0, r * 2, 0, "a", r, r, 0, 1, 0, -(r * 2), 0].join(" ") + "Z";
};

var drawMarginPath = function drawMarginPath(_ref) {
  var margin = _ref.margin,
      size = _ref.size,
      _ref$inset = _ref.inset,
      inset = _ref$inset === undefined ? 5 : _ref$inset;

  var iSize = [size[0] - inset, size[1] - inset];
  return "M0,0 h" + size[0] + " v" + size[1] + " h-" + size[0] + "Z M" + (margin.left - inset) + "," + (margin.top - inset) + " v" + (size[1] + inset * 2 - margin.top - margin.bottom) + " h" + (iSize[0] + inset * 3 - margin.left - margin.right) + " v-" + (iSize[1] + inset * 3 - margin.top - margin.bottom) + "Z";
};

var trueAxis = function trueAxis(orient, projection) {
  if (projection === "horizontal" && ["top", "bottom"].indexOf(orient) === -1) {
    return "bottom";
  } else if ((!projection || projection === "vertical") && ["left", "right"].indexOf(orient) === -1) {
    return "left";
  } else if (!orient && projection === "horizontal") {
    return "bottom";
  } else if (!orient) {
    return "left";
  }
  return orient;
};

var calculateMargin = function calculateMargin(_ref2) {
  var margin = _ref2.margin,
      axis = _ref2.axis,
      axes = _ref2.axes,
      title = _ref2.title,
      oLabel = _ref2.oLabel,
      projection = _ref2.projection;

  if (margin !== undefined) {
    var tempMargin = margin;
    if ((typeof margin === "undefined" ? "undefined" : _typeof(margin)) !== "object") {
      tempMargin = { top: margin, bottom: margin, left: margin, right: margin };
    }
    return Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, tempMargin);
  }
  var finalMargin = { top: 0, bottom: 0, left: 0, right: 0 };
  if (title && title.length !== 0) {
    finalMargin.top = 30;
  }
  var orient = trueAxis(null, projection);
  if (axis && projection !== "radial") {
    orient = trueAxis(axis.orient, projection);
    finalMargin[orient] += 50;
  }
  if (axes) {
    axes.forEach(function (axisObj) {
      orient = axisObj.orient;
      finalMargin[orient] += 50;
    });
  }
  if (oLabel && projection !== "radial") {
    if (orient === "bottom" || orient === "top") {
      finalMargin.left += 50;
    } else {
      finalMargin.bottom += 50;
    }
  }
  return finalMargin;
};

function objectifyType(type) {
  return (typeof type === "undefined" ? "undefined" : _typeof(type)) === "object" && type !== null ? type : { type: type };
}

function generateOrdinalFrameEventListeners(customHoverBehavior, customClickBehavior) {
  var eventListenersGenerator = function eventListenersGenerator() {
    return {};
  };

  if (customHoverBehavior || customClickBehavior) {
    eventListenersGenerator = function eventListenersGenerator(d, i) {
      return {
        onMouseEnter: customHoverBehavior ? function () {
          return customHoverBehavior(d, i);
        } : undefined,
        onMouseLeave: customHoverBehavior ? function () {
          return customHoverBehavior(undefined);
        } : undefined,
        onClick: customClickBehavior ? function () {
          return customClickBehavior(d, i);
        } : undefined
      };
    };
  }
  return eventListenersGenerator;
}

function keyAndObjectifyBarData(_ref3) {
  var data = _ref3.data,
      _ref3$renderKey = _ref3.renderKey,
      renderKey = _ref3$renderKey === undefined ? function (d, i) {
    return i;
  } : _ref3$renderKey;

  return data ? data.map(function (d, i) {
    var appliedKey = renderKey(d, i);
    if ((typeof d === "undefined" ? "undefined" : _typeof(d)) !== "object") {
      return {
        data: { value: d, renderKey: appliedKey },
        value: d,
        renderKey: appliedKey
      };
    }
    return { renderKey: appliedKey, data: d };
  }) : [];
}

function adjustedPositionSize(_ref4) {
  var _ref4$size = _ref4.size,
      size = _ref4$size === undefined ? [500, 500] : _ref4$size,
      _ref4$position = _ref4.position,
      position = _ref4$position === undefined ? [0, 0] : _ref4$position,
      margin = _ref4.margin,
      axis = _ref4.axis,
      axes = _ref4.axes,
      title = _ref4.title,
      oLabel = _ref4.oLabel,
      projection = _ref4.projection;

  var finalMargin = calculateMargin({
    margin: margin,
    axis: axis,
    axes: axes,
    title: title,
    oLabel: oLabel,
    projection: projection
  });

  var heightAdjust = finalMargin.top + finalMargin.bottom;
  var widthAdjust = finalMargin.left + finalMargin.right;

  var adjustedPosition = [position[0], position[1]];
  var adjustedSize = [size[0] - widthAdjust, size[1] - heightAdjust];
  if (projection === "radial") {
    var minSize = Math.min(adjustedSize[0], adjustedSize[1]);
    adjustedSize = [minSize, minSize];
  }

  return { adjustedPosition: adjustedPosition, adjustedSize: adjustedSize };
}

function generateFrameTitle(_ref5) {
  var title = _ref5.title,
      size = _ref5.size;

  var finalTitle = null;
  if (typeof title === "string" && title.length > 0) {
    finalTitle = React.createElement(
      "text",
      {
        x: size[0] / 2,
        y: 25,
        className: "frame-title",
        style: { textAnchor: "middle", pointerEvents: "none" }
      },
      title
    );
  } else if (title) {
    //assume if defined then its an svg mark of some sort
    finalTitle = title;
  }
  return finalTitle;
}

function orFrameConnectionRenderer(_ref6) {
  var type = _ref6.type,
      data = _ref6.data,
      renderMode = _ref6.renderMode,
      eventListenersGenerator = _ref6.eventListenersGenerator,
      styleFn = _ref6.styleFn,
      classFn = _ref6.classFn,
      projection = _ref6.projection,
      canvasRender = _ref6.canvasRender,
      canvasDrawing = _ref6.canvasDrawing,
      baseMarkProps = _ref6.baseMarkProps;

  if (!type.type) {
    return null;
  }
  var renderedConnectorMarks = [];
  if (typeof type.type === "function") {
    var connectionRule = type.type;
    var keys = Object.keys(data);

    keys.forEach(function (key, pieceArrayI) {
      var pieceArray = data[key];
      var nextColumn = data[keys[pieceArrayI + 1]];
      if (nextColumn) {
        var matchArray = nextColumn.map(function (d, i) {
          return connectionRule(d.piece.data, i);
        });
        pieceArray.forEach(function (piece, pieceI) {
          var thisConnectionPiece = connectionRule(piece.piece.data, pieceI);
          var matchingPieceIndex = matchArray.indexOf(connectionRule(piece.piece.data, pieceI));
          if (thisConnectionPiece !== undefined && thisConnectionPiece !== null && matchingPieceIndex !== -1) {
            var matchingPiece = nextColumn[matchingPieceIndex];
            var markD = void 0;
            var xy = piece.xy;
            var mxy = matchingPiece.xy;
            var x = xy.x,
                y = xy.y,
                _xy$height = xy.height,
                height = _xy$height === undefined ? 1 : _xy$height,
                _xy$width = xy.width,
                width = _xy$width === undefined ? 1 : _xy$width;
            var mx = mxy.x,
                my = mxy.y,
                _mxy$height = mxy.height,
                mheight = _mxy$height === undefined ? 1 : _mxy$height,
                _mxy$width = mxy.width,
                mwidth = _mxy$width === undefined ? 1 : _mxy$width;

            if (projection === "vertical") {
              markD = drawAreaConnector({
                x1: x + width,
                x2: mx,
                y1: y,
                y2: my,
                sizeX1: 0,
                sizeX2: 0,
                sizeY1: height,
                sizeY2: mheight
              });
            } else if (projection === "horizontal") {
              markD = drawAreaConnector({
                x1: x,
                x2: mx,
                y1: y + height,
                y2: my,
                sizeX1: width,
                sizeX2: mwidth,
                sizeY1: 0,
                sizeY2: 0
              });
            } else if (projection === "radial") {
              markD = drawAreaConnector({
                x1: x,
                x2: mx,
                y1: y + height,
                y2: my,
                sizeX1: width,
                sizeX2: mwidth,
                sizeY1: 0,
                sizeY2: 0
              });
            }
            var renderValue = renderMode && renderMode(piece.piece, pieceI);

            var calculatedStyle = styleFn({
              source: piece.piece.data,
              target: matchingPiece.piece
            });

            var eventListeners = eventListenersGenerator({ source: piece.piece.data, target: matchingPiece.piece.data }, pieceI);
            if (canvasRender && canvasRender(piece.piece) === true) {
              var canvasConnector = {
                baseClass: "xyframe-line",
                tx: 0,
                ty: 0,
                d: { source: piece.piece, target: matchingPiece.piece },
                markProps: { d: markD, markType: "path" },
                styleFn: styleFn,
                renderFn: renderMode,
                classFn: classFn
              };
              canvasDrawing.push(canvasConnector);
            } else {
              renderedConnectorMarks.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, eventListeners, {
                renderMode: renderValue,
                markType: "path",
                d: markD,
                className: classFn ? classFn(piece.piece.data, pieceI) : "",
                key: "connector" + piece.piece.renderKey,
                style: calculatedStyle
              })));
            }
          }
        });
      }
    });
  } else if (type.type) {
    console.error("Invalid connectorType - Must be a function that takes a data point and determines if it is connected to a data point in the next column");
  }
  return renderedConnectorMarks;
}

var summaryRenderHash = {
  contour: contourRenderFn,
  boxplot: boxplotRenderFn,
  violin: bucketizedRenderingFn,
  heatmap: bucketizedRenderingFn,
  joy: bucketizedRenderingFn,
  histogram: bucketizedRenderingFn
};

function orFrameSummaryRenderer(_ref7) {
  var data = _ref7.data,
      type = _ref7.type,
      renderMode = _ref7.renderMode,
      eventListenersGenerator = _ref7.eventListenersGenerator,
      styleFn = _ref7.styleFn,
      classFn = _ref7.classFn,
      positionFn = _ref7.positionFn,
      projection = _ref7.projection,
      adjustedSize = _ref7.adjustedSize,
      chartSize = _ref7.chartSize,
      baseMarkProps = _ref7.baseMarkProps;

  var summaryRenderFn = void 0;
  if (typeof type.type === "function") {
    summaryRenderFn = type.type;
  } else if (summaryRenderHash[type.type]) {
    summaryRenderFn = summaryRenderHash[type.type];
  } else {
    console.error("Invalid summary type: " + type.type + " - Must be a function or one of the following strings: " + Object.keys(summaryRenderHash));
    return;
  }
  return summaryRenderFn({
    data: data,
    type: type,
    renderMode: renderMode,
    eventListenersGenerator: eventListenersGenerator,
    styleFn: styleFn,
    classFn: classFn,
    positionFn: positionFn,
    projection: projection,
    adjustedSize: adjustedSize,
    chartSize: chartSize,
    baseMarkProps: baseMarkProps
  });
}

var orFrameAxisGenerator = function orFrameAxisGenerator(_ref8) {
  var projection = _ref8.projection,
      axis = _ref8.axis,
      adjustedSize = _ref8.adjustedSize,
      size = _ref8.size,
      rScale = _ref8.rScale,
      rScaleType = _ref8.rScaleType,
      pieceType = _ref8.pieceType,
      rExtent = _ref8.rExtent,
      data = _ref8.data;

  var generatedAxis = void 0,
      axesTickLines = void 0;
  if (projection !== "radial" && axis) {
    axesTickLines = [];
    var axisPosition = [0, 0];
    var axes = Array.isArray(axis) ? axis : [axis];
    var axisBaseline = false;
    generatedAxis = axes.map(function (d, i) {
      if (axisBaseline) {
        d.axis = d.axis || false;
      }
      axisBaseline = true;

      var axisClassname = d.className || "";
      var tickValues = void 0;
      var axisScale = rScaleType().domain(rScale.domain());

      var orient = trueAxis(d.orient, projection);

      if (orient === "right") {
        axisScale.range([rScale.range()[1], rScale.range()[0]]);
        axisClassname += " right y";
      } else if (orient === "left") {
        axisClassname += " left y";
        axisScale.range([rScale.range()[1], rScale.range()[0]]);
      } else if (orient === "top") {
        axisClassname += " top x";
        axisScale.range(rScale.range());
      } else if (orient === "bottom") {
        axisClassname += " bottom x";
        axisScale.range(rScale.range());
      }

      if (d.tickValues && Array.isArray(d.tickValues)) {
        tickValues = d.tickValues;
      } else if (d.tickValues) {
        //otherwise assume a function
        tickValues = d.tickValues(data, size, rScale);
      }

      var axisParts = axisPieces({
        padding: d.padding,
        tickValues: tickValues,
        scale: axisScale,
        ticks: d.ticks,
        orient: orient,
        size: adjustedSize,
        footer: d.footer,
        tickSize: d.tickSize
      });
      var axisTickLines = axisLines({
        axisParts: axisParts,
        orient: orient,
        tickLineGenerator: d.tickLineGenerator
      });
      axesTickLines.push(axisTickLines);

      return React.createElement(Axis, {
        label: d.label,
        axisParts: axisParts,
        key: d.key || "orframe-axis-" + i,
        orient: orient,
        size: adjustedSize,
        position: axisPosition,
        ticks: d.ticks,
        tickSize: d.tickSize,
        tickFormat: d.tickFormat,
        tickValues: tickValues,
        format: d.format,
        rotate: d.rotate,
        scale: axisScale,
        className: axisClassname,
        name: d.name,
        baseline: d.baseline
      });
    });
  } else if (projection === "radial" && axis) {
    var _pieceType$innerRadiu = pieceType.innerRadius,
        innerRadius = _pieceType$innerRadiu === undefined ? 0 : _pieceType$innerRadiu;
    var _axis$tickValues = axis.tickValues,
        tickValues = _axis$tickValues === undefined ? rScale.ticks(Math.max(2, (adjustedSize[0] / 2 - innerRadius) / 50)) : _axis$tickValues,
        label = axis.label,
        _axis$tickFormat = axis.tickFormat,
        tickFormat = _axis$tickFormat === undefined ? function (d) {
      return d;
    } : _axis$tickFormat;


    var tickScale = rScaleType().domain(rExtent).range([innerRadius, adjustedSize[0] / 2]);
    var ticks = tickValues.map(function (t, i) {
      var tickSize = tickScale(t);
      if (!(innerRadius === 0 && t === 0)) {
        var axisLabel = void 0;
        var ref = "";
        if (label && i === tickValues.length - 1) {
          var labelSettings = typeof label === "string" ? { name: label } : label;
          var _labelSettings$locati = labelSettings.locationDistance,
              locationDistance = _labelSettings$locati === undefined ? 15 : _labelSettings$locati;

          ref = Math.random().toString() + " ";
          axisLabel = React.createElement(
            "g",
            {
              className: "axis-label radial",
              transform: "translate(0," + locationDistance + ")"
            },
            React.createElement(
              "text",
              { textAnchor: "middle" },
              React.createElement(
                "textPath",
                {
                  startOffset: tickSize * Math.PI * 0.5,
                  xlinkHref: "#" + ref
                },
                label.name
              )
            )
          );
        }
        return React.createElement(
          "g",
          {
            key: "orframe-radial-axis-element-" + t,
            className: "axis axis-label axis-tick radial",
            transform: "translate(0,0)"
          },
          React.createElement("path", {
            id: ref,
            d: circlePath(0, 0, tickSize),
            r: tickSize,
            stroke: "gray",
            fill: "none"
          }),
          React.createElement(
            "text",
            { y: -tickSize + 5, textAnchor: "middle" },
            tickFormat(t)
          ),
          axisLabel
        );
      }
      return null;
    });
    generatedAxis = React.createElement(
      "g",
      {
        key: axis.key || "orframe-radial-axis-container",
        transform: "translate(" + adjustedSize[0] / 2 + "," + adjustedSize[1] / 2 + ")"
      },
      ticks
    );
  }
  return { axis: generatedAxis, axesTickLines: axesTickLines };
};

var cleanDates = function cleanDates(value) {
  if (value && value.toJSON) {
    return value.toJSON();
  }
  return value;
};

var xyDownloadMapping = function xyDownloadMapping(_ref) {
  var data = _ref.data,
      xAccessor = _ref.xAccessor,
      yAccessor = _ref.yAccessor,
      _ref$fields = _ref.fields,
      fields = _ref$fields === undefined ? [] : _ref$fields;

  var csvData = [];

  data.forEach(function (datum) {
    if (Array.isArray(datum)) {
      datum.forEach(function (a) {
        var row = {};
        if (xAccessor) {
          row.x = cleanDates(xAccessor(a));
        } else if (a.x) {
          row.x = a.x;
        }

        if (yAccessor) {
          row.y = cleanDates(yAccessor(a));
        } else if (a.y) {
          row.y = a.y;
        }

        if (datum.id !== undefined) row.id = datum.id;

        if (fields && Array.isArray(fields)) {
          fields.forEach(function (f) {
            row[f] = cleanDates(a[f]);
          });
        }

        csvData.push(row);
      });
    } else {
      var row = {};
      if (xAccessor) {
        row.x = cleanDates(xAccessor(datum.data));
      } else if (datum.x) {
        row.x = datum.x;
      }

      if (yAccessor) {
        row.y = cleanDates(yAccessor(datum.data));
      } else if (datum.y) {
        row.y = datum.y;
      }

      if (datum.id !== undefined) {
        row.id = datum.id;
      }

      if (xAccessor || yAccessor) {
        fields.forEach(function (f) {
          row[f] = datum.data[f];
        });
      } else {
        fields.forEach(function (f) {
          row[f] = datum[f];
        });
      }
      csvData.push(row);
    }
  });
  return csvData;
};

var orDownloadMapping = function orDownloadMapping(_ref2) {
  var data = _ref2.data,
      oAccessor = _ref2.oAccessor,
      rAccessor = _ref2.rAccessor,
      _ref2$fields = _ref2.fields,
      fields = _ref2$fields === undefined ? [] : _ref2$fields;

  var dataKeys = Object.keys(data);
  var csvData = [];

  dataKeys.forEach(function (key) {
    data[key].pieceData.forEach(function (piece) {
      var row = {};
      if (oAccessor) {
        row.column = oAccessor(piece.data);
      } else if (piece.x) {
        row.column = piece.x;
      }

      if (rAccessor) {
        row.value = rAccessor(piece.data);
      } else if (piece.renderKey) {
        row.value = piece.renderKey;
      }

      if (piece.id !== undefined) row.id = piece.id;

      fields.forEach(function (f) {
        row[f] = cleanDates(piece.data[f]);
      });

      csvData.push(row);
    });
  });

  return csvData;
};

var networkNodeDownloadMapping = function networkNodeDownloadMapping(_ref3) {
  var data = _ref3.data,
      _ref3$fields = _ref3.fields,
      fields = _ref3$fields === undefined ? [] : _ref3$fields;

  var csvData = [];
  data.forEach(function (d) {
    var row = {};
    row.id = d.id;
    fields.forEach(function (f) {
      row[f] = d[f];
    });
    csvData.push(row);
  });
  return csvData;
};

var networkEdgeDownloadMapping = function networkEdgeDownloadMapping(_ref4) {
  var data = _ref4.data,
      _ref4$fields = _ref4.fields,
      fields = _ref4$fields === undefined ? [] : _ref4$fields;

  var csvData = [];
  data.forEach(function (d) {
    var row = {};
    row.source = d.source.id;
    row.target = d.target.id;
    fields.forEach(function (f) {
      row[f] = d[f];
    });
    csvData.push(row);
  });

  return csvData;
};

var projectedX = "x";
var projectedY = "y";
var projectedYMiddle = "yMiddle";
var projectedYTop = "yTop";
var projectedYBottom = "yBottom";

/*
Use symbols for x/y/offset to avoid conflicts when projecting the dataset
But how to expose those for custom hover rules?
*/

/*
const projectedX = Symbol('x');
const projectedY = Symbol('y');
const projectedYMiddle = Symbol('y-middle');
const projectedOffset = Symbol('offset');
*/

var builtInTransformations = {
  "stackedarea": stackedArea,
  "stackedarea-invert": stackedArea,
  "stackedpercent": stackedArea,
  "stackedpercent-invert": stackedArea,
  "linepercent": stackedArea,
  "difference": differenceLine,
  "bumparea": bumpChart,
  "bumpline": bumpChart,
  "bumparea-invert": bumpChart,
  "line": lineChart
};

var stringToFn = function stringToFn(accessor, defaultAccessor, raw) {
  if (!accessor) {
    return defaultAccessor;
  } else if (typeof accessor !== "function" && raw) {
    return function () {
      return accessor;
    };
  }
  return typeof accessor !== "function" ? function (d) {
    return d[accessor];
  } : accessor;
};

var calculateDataExtent = function calculateDataExtent(_ref) {
  var lineDataAccessor = _ref.lineDataAccessor,
      xAccessor = _ref.xAccessor,
      yAccessor = _ref.yAccessor,
      areas = _ref.areas,
      points = _ref.points,
      lines = _ref.lines,
      lineType = _ref.lineType,
      showLinePoints = _ref.showLinePoints,
      xExtent = _ref.xExtent,
      yExtent = _ref.yExtent,
      invertX = _ref.invertX,
      invertY = _ref.invertY,
      areaDataAccessor = _ref.areaDataAccessor,
      projection = _ref.projection,
      areaType = _ref.areaType,
      _ref$defined = _ref.defined,
      defined = _ref$defined === undefined ? function () {
    return true;
  } : _ref$defined;

  lineDataAccessor = stringToFn(lineDataAccessor, function (d) {
    return d.coordinates;
  });
  xAccessor = stringToFn(xAccessor, function (d) {
    return d[0];
  });
  yAccessor = stringToFn(yAccessor, function (d) {
    return d[1];
  });
  areaDataAccessor = stringToFn(areaDataAccessor, function (d) {
    return d.coordinates;
  });

  var fullDataset = [];
  var initialProjectedLines = [];

  var projectedPoints = [],
      projectedLines = [],
      projectedAreas = [];
  if (points) {
    projectedPoints = points.map(function (d, i) {
      var _ref2;

      var x = xAccessor(d, i);
      var y = yAccessor(d, i);
      return _ref2 = {}, defineProperty(_ref2, projectedX, x), defineProperty(_ref2, projectedY, y), defineProperty(_ref2, "data", d), _ref2;
    });
    fullDataset = projectedPoints;
  }
  if (lines) {
    initialProjectedLines = projectLineData({
      data: lines,
      lineDataAccessor: lineDataAccessor,
      xProp: projectedX,
      yProp: projectedY,
      yPropTop: projectedYTop,
      yPropBottom: projectedYBottom,
      xAccessor: xAccessor,
      yAccessor: yAccessor
    });

    var optionsObject = {
      xProp: projectedX,
      yProp: projectedY,
      yPropMiddle: projectedYMiddle,
      yPropTop: projectedYTop,
      yPropBottom: projectedYBottom
    };

    projectedLines = lineTransformation(lineType, optionsObject)(initialProjectedLines);

    projectedLines.forEach(function (d) {
      fullDataset = [].concat(toConsumableArray(fullDataset), toConsumableArray(d.data.filter(function (p, q) {
        return defined(Object.assign({}, p.data, p), q);
      }).map(function (p) {
        var _mappedP;

        var mappedP = (_mappedP = {
          parentLine: d
        }, defineProperty(_mappedP, projectedY, p[projectedY]), defineProperty(_mappedP, projectedX, p[projectedX]), defineProperty(_mappedP, projectedYTop, p[projectedYTop]), defineProperty(_mappedP, projectedYMiddle, p[projectedYMiddle]), defineProperty(_mappedP, projectedYBottom, p[projectedYBottom]), defineProperty(_mappedP, "data", p.data), _mappedP);
        if (p.percent) {
          mappedP.percent = p.percent;
        }
        return mappedP;
      })));
    });
  }

  if (areas) {
    projectedAreas = projectAreaData({
      data: areas,
      areaDataAccessor: areaDataAccessor,
      projection: projection,
      xProp: projectedX,
      yProp: projectedY,
      yPropTop: projectedYTop,
      yPropBottom: projectedYBottom,
      xAccessor: xAccessor,
      yAccessor: yAccessor
    });
    projectedAreas.forEach(function (d) {
      var baseData = areaDataAccessor(d);
      if (d._xyfCoordinates[0][0][0]) {
        d._xyfCoordinates[0].forEach(function (multi) {
          fullDataset = [].concat(toConsumableArray(fullDataset), toConsumableArray(multi.map(function (p, q) {
            var _Object$assign;

            return Object.assign({ parentArea: d }, baseData[q], (_Object$assign = {}, defineProperty(_Object$assign, projectedX, p[0]), defineProperty(_Object$assign, projectedY, p[1]), _Object$assign));
          })));
        });
      } else {
        fullDataset = [].concat(toConsumableArray(fullDataset), toConsumableArray(d._xyfCoordinates.map(function (p, q) {
          var _Object$assign2;

          return Object.assign({ parentArea: d }, baseData[q], (_Object$assign2 = {}, defineProperty(_Object$assign2, projectedX, p[0]), defineProperty(_Object$assign2, projectedY, p[1]), _Object$assign2));
        })));
      }
    });
  }

  if (showLinePoints) {
    projectedPoints = fullDataset.map(function (d) {
      return _extends({}, d, defineProperty({}, projectedY, d[projectedYTop] || d[projectedYBottom] || d.y));
    });
  }

  var calculatedXExtent = extent(fullDataset.map(function (d) {
    return d[projectedX];
  }));
  var calculatedYExtent = [min(fullDataset.map(function (d) {
    return d[projectedYBottom] === undefined ? d[projectedY] : Math.min(d[projectedYTop], d[projectedYBottom]);
  })), max(fullDataset.map(function (d) {
    return d[projectedYTop] === undefined ? d[projectedY] : Math.max(d[projectedYBottom], d[projectedYTop]);
  }))];

  var xMin = xExtent && xExtent[0] !== undefined ? xExtent[0] : calculatedXExtent[0];
  var xMax = xExtent && xExtent[1] !== undefined ? xExtent[1] : calculatedXExtent[1];

  var yMin = yExtent && yExtent[0] !== undefined ? yExtent[0] : calculatedYExtent[0];
  var yMax = yExtent && yExtent[1] !== undefined ? yExtent[1] : calculatedYExtent[1];

  var finalYExtent = [yMin, yMax];
  var finalXExtent = [xMin, xMax];

  if (invertX) {
    finalXExtent = [finalXExtent[1], finalXExtent[0]];
  }
  if (invertY) {
    finalYExtent = [finalYExtent[1], finalYExtent[0]];
  }

  if (areaType && (areaType === "contour" || areaType.type && areaType.type === "contour")) {
    projectedAreas = contouring({
      areaType: areaType,
      data: projectedAreas,
      projectedX: projectedX,
      projectedY: projectedY,
      finalXExtent: finalXExtent,
      finalYExtent: finalYExtent
    });
  } else if (typeof areaType === "function" || areaType && areaType.type && typeof areaType.type === "function") {
    var areaFunction = areaType.type || areaType;

    projectedAreas = areaFunction({
      xExtent: finalXExtent,
      yExtent: finalYExtent,
      projectedX: projectedX,
      projectedY: projectedY,
      fullDataset: fullDataset,
      projectedAreas: projectedAreas
    });
  }

  return {
    xExtent: finalXExtent,
    yExtent: finalYExtent,
    projectedLines: projectedLines,
    projectedPoints: projectedPoints,
    projectedAreas: projectedAreas,
    fullDataset: fullDataset,
    calculatedXExtent: calculatedXExtent,
    calculatedYExtent: calculatedYExtent
  };
};

function lineTransformation() {
  var lineType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { type: "line" };
  var options = arguments[1];

  var differenceCatch = function differenceCatch(olineType, data) {
    return (lineType === "difference" || lineType.type && lineType.type === "difference") && data.length !== 2 ? "line" : olineType;
  };
  if (builtInTransformations[lineType]) {
    return function (data) {
      return builtInTransformations[differenceCatch(lineType, data)](_extends({
        type: lineType
      }, options, {
        data: data
      }));
    };
  }

  if (builtInTransformations[lineType.type]) {
    return function (data) {
      return builtInTransformations[differenceCatch(lineType.type, data)](_extends({}, lineType, options, {
        data: data
      }));
    };
  }

  //otherwise assume a function
  return function (data) {
    return lineType(_extends({}, options, { data: data }));
  };
}

var filterDefs = function filterDefs(_ref) {
  var matte = _ref.matte,
      key = _ref.key,
      additionalDefs = _ref.additionalDefs;
  return React.createElement(
    "defs",
    null,
    React.createElement(
      "filter",
      { id: "paintyFilterHeavy" },
      React.createElement("feGaussianBlur", {
        id: "gaussblurrer",
        "in": "SourceGraphic",
        stdDeviation: 4,
        colorInterpolationFilters: "sRGB",
        result: "blur"
      }),
      React.createElement("feColorMatrix", {
        "in": "blur",
        mode: "matrix",
        values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7",
        result: "gooey"
      })
    ),
    React.createElement(
      "filter",
      { id: "paintyFilterLight" },
      React.createElement("feGaussianBlur", {
        id: "gaussblurrer",
        "in": "SourceGraphic",
        stdDeviation: 2,
        colorInterpolationFilters: "sRGB",
        result: "blur"
      }),
      React.createElement("feColorMatrix", {
        "in": "blur",
        mode: "matrix",
        values: "1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 34 -7",
        result: "gooey"
      })
    ),
    React.createElement(
      "clipPath",
      { id: "matte-clip-" + key },
      matte
    ),
    additionalDefs
  );
};

//size is a special case and handled checking the actual values in the size array

var xyFrameChangeProps = ["name", "lines", "points", "areas", "title", "margin", "axes", "position", "xScaleType", "yScaleType", "xExtent", "yExtent", "invertX", "invertY", "xAccessor", "yAccessor", "hoverAnnotation", "lineDataAccessor", "areaDataAccessor", "additionalDefs", "lineType", "showLinePoints", "defined", "lineStyle", "pointStyle", "areaStyle", "lineClass", "pointClass", "areaClass", "canvasPoints", "customPointMark", "customLineMark", "lineIDAccessor"];

var orFrameChangeProps = ["data", "name", "orient", "title", "margin", "format", "position", "oScaleType", "rScaleType", "oExtent", "rExtent", "invertO", "invertR", "oAccessor", "rAccessor", "oPadding", "projection", "type", "summaryType", "connectorType", "className", "additionalDefs", "renderKey", "dataAccessor", "rBaseline", "sortO", "dynamicColumnWidth", "renderFn", "style", "connectorStyle", "summaryStyle", "summaryPosition", "oLabel", "axis"];

var networkFrameChangeProps = ["name", "nodes", "edges", "title", "margin", "position", "nodeIDAccessor", "sourceAccessor", "targetAccessor", "nodeSizeAccessor", "customNodeIcon", "nodeLabels", "edgeWidthAccessor", "networkType", "className", "additionalDefs", "renderFn", "nodeStyle", "edgeStyle", "edgeType"];

/*
const xyFrameOtherProps = [
  "matte",
  "tooltipContent",
  "interaction",
  "annotations",
  "svgAnnotationRules",
  "htmlAnnotationRules",
  "customHoverBehavior",
  "customClickBehavior",
  "customDoubleclickBehavior",
  "backgroundGraphics",
  "foregroundGraphics",
  "download",
  "downloadFields"
]

const orFrameOtherProps = [
  "annotations",
  "htmlAnnotationRules",
  "tooltipContent",
  "interaction",
  "customHoverBehavior",
  "customClickBehavior",
  "svgAnnotationRules",
  "hoverAnnotation",
  "backgroundGraphics",
  "foregroundGraphics"
]

const networkFrameOtherProps = [
  "annotations",
  "htmlAnnotationRules",
  "tooltipContent",
  "interaction",
  "customHoverBehavior",
  "customClickBehavior",
  "customDoubleClickBehavior",
  "svgAnnotationRules",
  "hoverAnnotation",
  "backgroundGraphics",
  "foregroundGraphics"
]
*/

// components

var emptyObjectReturnFunction = function emptyObjectReturnFunction() {
  return {};
};
var emptyStringReturnFunction = function emptyStringReturnFunction() {
  return "";
};

var xyframeKey = "";
var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (var i = 32; i > 0; --i) {
  xyframeKey += chars[Math.floor(Math.random() * chars.length)];
}var xyframeSettings = ["margin"];

var projectedCoordinateNames = {
  y: projectedY,
  x: projectedX,
  yMiddle: projectedYMiddle,
  yTop: projectedYTop,
  yBottom: projectedYBottom
};

function mapParentsToPoints(fullDataset) {
  return fullDataset.map(function (d) {
    if (d.parentLine) {
      return Object.assign({}, d.parentLine, d);
    }
    if (d.parentArea) {
      return Object.assign({}, d.parentArea, d);
    }
    return d;
  });
}

var XYFrame = function (_React$Component) {
  inherits(XYFrame, _React$Component);

  function XYFrame(props) {
    classCallCheck(this, XYFrame);

    var _this = possibleConstructorReturn(this, (XYFrame.__proto__ || Object.getPrototypeOf(XYFrame)).call(this, props));

    _this.calculateXYFrame = _this.calculateXYFrame.bind(_this);

    _this.renderBody = _this.renderBody.bind(_this);

    _this.state = {
      lineData: null,
      pointData: null,
      areaData: null,
      projectedLines: null,
      projectedPoints: null,
      projectedAreas: null,
      fullDataset: null,
      adjustedPosition: null,
      adjustedSize: null,
      backgroundGraphics: null,
      foregroundGraphics: null,
      axesData: null,
      axes: null,
      renderNumber: 0,
      margin: { top: 0, bottom: 0, left: 0, right: 0 }
    };

    _this.xAccessor = null;
    _this.yAccessor = null;
    _this.xScale = null;
    _this.yScale = null;

    _this.settingsMap = new Map();
    xyframeSettings.forEach(function (d) {
      _this.settingsMap.set(d, new Map());
    });
    return _this;
  }

  createClass(XYFrame, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      this.calculateXYFrame(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.state.dataVersion && this.state.dataVersion !== nextProps.dataVersion || !this.state.fullDataset) {
        this.calculateXYFrame(nextProps);
      } else if (this.state.size[0] !== nextProps.size[0] || this.state.size[1] !== nextProps.size[1] || !this.state.dataVersion && xyFrameChangeProps.find(function (d) {
        return _this2.props[d] !== nextProps[d];
      })) {
        this.calculateXYFrame(nextProps);
      }
    }
  }, {
    key: "screenScales",
    value: function screenScales(_ref) {
      var xExtent = _ref.xExtent,
          yExtent = _ref.yExtent,
          currentProps = _ref.currentProps,
          adjustedSize = _ref.adjustedSize;

      var xDomain = [0, adjustedSize[0]];
      var yDomain = [adjustedSize[1], 0];

      var xScaleType = currentProps.xScaleType || linear$2();
      var yScaleType = currentProps.yScaleType || linear$2();

      var xScale = xScaleType;
      var yScale = yScaleType;

      if (xScaleType.domain) {
        xScaleType.domain(xExtent);
      }
      if (yScaleType.domain) {
        yScaleType.domain(yExtent);
      }
      xScaleType.range(xDomain);
      yScaleType.range(yDomain);

      return { xScale: xScale, yScale: yScale };
    }
  }, {
    key: "calculateXYFrame",
    value: function calculateXYFrame(currentProps) {
      var margin = calculateMargin(currentProps);

      var _adjustedPositionSize = adjustedPositionSize(currentProps),
          adjustedPosition = _adjustedPositionSize.adjustedPosition,
          adjustedSize = _adjustedPositionSize.adjustedSize;

      var legend = currentProps.legend,
          lines = currentProps.lines,
          lineClass = currentProps.lineClass,
          pointStyle = currentProps.pointStyle,
          pointRenderMode = currentProps.pointRenderMode,
          pointClass = currentProps.pointClass,
          areaClass = currentProps.areaClass,
          canvasLines = currentProps.canvasLines,
          canvasPoints = currentProps.canvasPoints,
          canvasAreas = currentProps.canvasAreas,
          defined = currentProps.defined,
          size = currentProps.size,
          renderKey = currentProps.renderKey,
          lineType = currentProps.lineType,
          customLineMark = currentProps.customLineMark,
          customPointMark = currentProps.customPointMark,
          customAreaMark = currentProps.customAreaMark,
          areaStyle = currentProps.areaStyle,
          areaRenderMode = currentProps.areaRenderMode,
          lineStyle = currentProps.lineStyle,
          lineRenderMode = currentProps.lineRenderMode,
          baseXExtent = currentProps.xExtent,
          baseYExtent = currentProps.yExtent;
      var projectedLines = currentProps.projectedLines,
          projectedPoints = currentProps.projectedPoints,
          projectedAreas = currentProps.projectedAreas,
          fullDataset = currentProps.fullDataset;


      var xExtentSettings = baseXExtent === undefined || Array.isArray(baseXExtent) ? { extent: baseXExtent } : baseXExtent;
      var yExtentSettings = baseYExtent === undefined || Array.isArray(baseYExtent) ? { extent: baseYExtent } : baseYExtent;

      var xExtent = xExtentSettings.extent;
      var yExtent = yExtentSettings.extent;

      var calculatedXExtent = void 0,
          calculatedYExtent = void 0;

      var xAccessor = stringToFn(currentProps.xAccessor);
      var yAccessor = stringToFn(currentProps.yAccessor);
      var lineIDAccessor = stringToFn(currentProps.lineIDAccessor, function (l) {
        return l.semioticLineID;
      });

      if (!currentProps.dataVersion || currentProps.dataVersion && currentProps.dataVersion !== this.state.dataVersion) {
        if (!xExtent || !yExtent || !fullDataset || !projectedLines && !projectedPoints && !projectedAreas) {
          
          var _calculateDataExtent = calculateDataExtent(_extends({}, currentProps, { xExtent: xExtent, yExtent: yExtent }));

          xExtent = _calculateDataExtent.xExtent;
          yExtent = _calculateDataExtent.yExtent;
          projectedLines = _calculateDataExtent.projectedLines;
          projectedPoints = _calculateDataExtent.projectedPoints;
          projectedAreas = _calculateDataExtent.projectedAreas;
          fullDataset = _calculateDataExtent.fullDataset;
          calculatedXExtent = _calculateDataExtent.calculatedXExtent;
          calculatedYExtent = _calculateDataExtent.calculatedYExtent;
        }
      } else {
        var _state = this.state;
        xExtent = _state.xExtent;
        yExtent = _state.yExtent;
        projectedLines = _state.projectedLines;
        projectedPoints = _state.projectedPoints;
        projectedAreas = _state.projectedAreas;
        fullDataset = _state.fullDataset;
        calculatedXExtent = _state.calculatedXExtent;
        calculatedYExtent = _state.calculatedYExtent;
      }

      var _screenScales = this.screenScales({
        xExtent: xExtent,
        yExtent: yExtent,
        currentProps: currentProps,
        margin: margin,
        adjustedSize: adjustedSize
      }),
          xScale = _screenScales.xScale,
          yScale = _screenScales.yScale;

      var canvasDrawing = [];

      var title = generateFrameTitle(currentProps);

      //TODO: blow this shit up
      this.xScale = xScale;
      this.yScale = yScale;
      this.xAccessor = xAccessor;
      this.yAccessor = yAccessor;

      var axes = null;
      var axesTickLines = null;

      var existingBaselines = {};

      if (currentProps.axes) {
        axesTickLines = [];
        axes = currentProps.axes.map(function (d, i) {
          var axisClassname = d.className || "";
          axisClassname += " axis";
          var axisScale = yScale;
          if (existingBaselines[d.orient]) {
            d.baseline = d.baseline || false;
          }
          existingBaselines[d.orient] = true;
          if (d.orient === "top" || d.orient === "bottom") {
            axisClassname += " x";
            axisScale = xScale;
          } else {
            axisClassname += " y";
          }
          axisClassname += " " + d.orient;

          var tickValues = void 0;
          if (d.tickValues && Array.isArray(d.tickValues)) {
            tickValues = d.tickValues;
          } else if (d.tickValues) {
            //otherwise assume a function
            tickValues = d.tickValues(fullDataset, currentProps.size, axisScale);
          }
          var axisSize = [adjustedSize[0], adjustedSize[1]];

          var axisParts = axisPieces({
            padding: d.padding,
            tickValues: tickValues,
            scale: axisScale,
            ticks: d.ticks,
            orient: d.orient,
            size: axisSize,
            margin: margin,
            footer: d.footer,
            tickSize: d.tickSize
          });
          var axisTickLines = React.createElement(
            "g",
            { key: "axes-tick-lines-" + i, className: "axis " + axisClassname },
            axisLines({
              axisParts: axisParts,
              orient: d.orient,
              tickLineGenerator: d.tickLineGenerator
            })
          );
          axesTickLines.push(axisTickLines);
          return React.createElement(Axis, {
            label: d.label,
            axisParts: axisParts,
            key: d.key || "axis-" + i,
            orient: d.orient,
            size: axisSize,
            margin: margin,
            ticks: d.ticks,
            tickSize: d.tickSize,
            tickFormat: d.tickFormat,
            tickValues: tickValues,
            format: d.format,
            scale: axisScale,
            className: axisClassname,
            name: d.name,
            padding: d.padding,
            rotate: d.rotate,
            annotationFunction: d.axisAnnotationFunction,
            glyphFunction: d.glyphFunction,
            baseline: d.baseline
          });
        });
      }

      var marginGraphic = void 0;
      if (currentProps.matte) {
        marginGraphic = React.createElement("path", {
          fill: "white",
          transform: "translate(" + -margin.left + "," + -margin.top + ")",
          d: drawMarginPath({
            margin: margin,
            size: size,
            inset: currentProps.matte.inset
          }),
          className: "xyframe-matte"
        });
      }

      var legendSettings = void 0;

      if (legend) {
        legendSettings = legend === true ? {} : legend;
        if (lines && !legendSettings.legendGroups) {
          var typeString = lineType && lineType.type ? lineType.type : lineType;
          var type = ["stackedarea", "stackedpercent", "bumparea"].indexOf(typeString) === -1 ? "line" : "fill";
          var legendGroups = [{
            styleFn: currentProps.lineStyle,
            type: type,
            items: currentProps.lines.map(function (d) {
              return Object.assign({ label: lineIDAccessor(d) }, d);
            })
          }];
          legendSettings.legendGroups = legendGroups;
        }
      }
      var areaAnnotations = [];
      var areaType = currentProps.areaType;
      if (areaType && areaType.label && projectedAreas) {
        projectedAreas.forEach(function (d, i) {
          if (d.bounds) {
            var bounds = Array.isArray(d.bounds) ? d.bounds : [d.bounds];
            bounds.forEach(function (labelBounds) {
              var label = typeof areaType.label === "function" ? areaType.label(d) : areaType.label;
              if (label && label !== null) {
                var labelPosition = label.position || "center";
                var labelCenter = [xScale(labelBounds[labelPosition][0]), yScale(labelBounds[labelPosition][1])] || [xScale(d._xyfCoordinates[0]), yScale(d._xyfCoordinates[1])];
                var labelContent = label.content || function (p) {
                  return p.value || p.id || i;
                };

                areaAnnotations.push({
                  x: labelCenter[0],
                  y: labelCenter[1],
                  dx: label.dx,
                  dy: label.dy,
                  className: label.className,
                  type: label.type || lib_9,
                  note: label.note || { title: labelContent(d) },
                  subject: label.subject || { text: labelContent(d) },
                  connector: label.connector
                });
              }
            });
          }
        });
      }

      var xyFrameRender = {
        lines: {
          data: projectedLines,
          styleFn: stringToFn(lineStyle, emptyObjectReturnFunction, true),
          classFn: stringToFn(lineClass, emptyStringReturnFunction, true),
          renderMode: stringToFn(lineRenderMode, undefined, true),
          canvasRender: stringToFn(canvasLines, undefined, true),
          customMark: customLineMark,
          type: lineType,
          defined: defined,
          renderKeyFn: stringToFn(renderKey, function (d, i) {
            return "line-" + i;
          }, true),
          behavior: createLines
        },
        areas: {
          data: projectedAreas,
          styleFn: stringToFn(areaStyle, emptyObjectReturnFunction, true),
          classFn: stringToFn(areaClass, emptyStringReturnFunction, true),
          renderMode: stringToFn(areaRenderMode, undefined, true),
          canvasRender: stringToFn(canvasAreas, undefined, true),
          customMark: customAreaMark,
          type: areaType,
          renderKeyFn: stringToFn(renderKey, function (d, i) {
            return "area-" + i;
          }, true),
          behavior: createAreas
        },
        points: {
          data: projectedPoints,
          styleFn: stringToFn(pointStyle, emptyObjectReturnFunction, true),
          classFn: stringToFn(pointClass, emptyStringReturnFunction, true),
          renderMode: stringToFn(pointRenderMode, undefined, true),
          canvasRender: stringToFn(canvasPoints, undefined, true),
          customMark: stringToFn(customPointMark, undefined, true),
          renderKeyFn: stringToFn(renderKey, function (d, i) {
            return "point-" + i;
          }, true),
          behavior: createPoints
        }
      };

      if (xExtentSettings.onChange && (this.state.calculatedXExtent || []).join(",") !== (calculatedXExtent || []).join(",")) {
        xExtentSettings.onChange(calculatedXExtent);
      }
      if (yExtentSettings.onChange && (this.state.calculatedYExtent || []).join(",") !== (calculatedYExtent || []).join(",")) {
        yExtentSettings.onChange(calculatedYExtent);
      }

      this.setState({
        lineData: currentProps.lines,
        pointData: currentProps.points,
        areaData: currentProps.areas,
        dataVersion: currentProps.dataVersion,
        projectedLines: projectedLines,
        projectedPoints: projectedPoints,
        projectedAreas: projectedAreas,
        canvasDrawing: canvasDrawing,
        fullDataset: fullDataset,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        axesData: currentProps.axes,
        axes: axes,
        axesTickLines: axesTickLines,
        title: title,
        updatedFrame: undefined,
        renderNumber: this.state.renderNumber + 1,
        xScale: xScale,
        yScale: yScale,
        xExtent: xExtent,
        yExtent: yExtent,
        calculatedXExtent: calculatedXExtent,
        calculatedYExtent: calculatedYExtent,
        margin: margin,
        legendSettings: legendSettings,
        matte: marginGraphic,
        areaAnnotations: areaAnnotations,
        xyFrameRender: xyFrameRender,
        size: size
      });
    }
  }, {
    key: "defaultXYSVGRule",
    value: function defaultXYSVGRule(_ref2) {
      var d = _ref2.d,
          i = _ref2.i,
          annotationLayer = _ref2.annotationLayer,
          lines = _ref2.lines,
          areas = _ref2.areas,
          points = _ref2.points;

      var xAccessor = this.xAccessor;
      var yAccessor = this.yAccessor;

      var xScale = this.xScale;
      var yScale = this.yScale;

      var screenCoordinates = [];
      var idAccessor = stringToFn(this.props.lineIDAccessor, function (l) {
        return l.semioticLineID;
      });

      var _adjustedPositionSize2 = adjustedPositionSize(this.props),
          adjustedPosition = _adjustedPositionSize2.adjustedPosition,
          adjustedSize = _adjustedPositionSize2.adjustedSize;

      if (!d.coordinates) {
        var xCoord = d[projectedX] || xAccessor(d);
        screenCoordinates = [xScale(xCoord), relativeY({
          point: d,
          lines: lines,
          projectedYMiddle: projectedYMiddle,
          projectedY: projectedY,
          projectedX: projectedX,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          yScale: yScale,
          xScale: xScale,
          idAccessor: idAccessor
        })];

        if (d.type !== "highlight" && (screenCoordinates[0] === undefined || screenCoordinates[1] === undefined || screenCoordinates[0] === null || screenCoordinates[1] === null)) {
          //NO ANNOTATION IF INVALID SCREEN COORDINATES
          return null;
        }
      } else if (!d.bounds) {
        screenCoordinates = d.coordinates.map(function (p) {
          return [xScale(xAccessor(p)) + adjustedPosition[0], relativeY({
            point: p,
            lines: lines,
            projectedYMiddle: projectedYMiddle,
            projectedY: projectedY,
            projectedX: projectedX,
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            yScale: yScale,
            xScale: xScale,
            idAccessor: idAccessor
          }) + adjustedPosition[1]];
        });
      }

      var margin = calculateMargin(this.props);

      //point xy
      //y
      //area

      //TODO: Process your rules first
      if (this.props.svgAnnotationRules && this.props.svgAnnotationRules({
        d: d,
        i: i,
        screenCoordinates: screenCoordinates,
        xScale: xScale,
        yScale: yScale,
        xAccessor: xAccessor,
        yAccessor: yAccessor,
        xyFrameProps: this.props,
        xyFrameState: this.state,
        areas: areas,
        points: points,
        lines: lines
      }) !== null) {
        return this.props.svgAnnotationRules({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          xScale: xScale,
          yScale: yScale,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          xyFrameProps: this.props,
          xyFrameState: this.state,
          areas: areas,
          points: points,
          lines: lines
        });
      } else if (d.type === "xy" || d.type === "frame-hover") {
        return svgXYAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "highlight") {
        return svgHighlight({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          idAccessor: idAccessor,
          lines: lines,
          areas: areas,
          points: points,
          xScale: xScale,
          yScale: yScale
        });
      } else if (d.type === "react-annotation" || typeof d.type === "function") {
        return basicReactAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "enclose") {
        return svgEncloseAnnotation({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "enclose-rect") {
        return svgRectEncloseRule({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "x") {
        return svgXAnnotation({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          annotationLayer: annotationLayer,
          adjustedSize: adjustedSize,
          margin: margin
        });
      } else if (d.type === "y") {
        return svgYAnnotation({
          d: d,
          screenCoordinates: screenCoordinates,
          i: i,
          annotationLayer: annotationLayer,
          adjustedSize: adjustedSize,
          adjustedPosition: adjustedPosition,
          margin: margin
        });
      } else if (d.type === "bounds") {
        return svgBoundsAnnotation({
          screenCoordinates: screenCoordinates,
          d: d,
          i: i,
          adjustedSize: adjustedSize,
          adjustedPosition: adjustedPosition,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          xScale: xScale,
          yScale: yScale,
          margin: margin
        });
      } else if (d.type === "line") {
        return svgLineAnnotation({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "area") {
        return svgAreaAnnotation({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          xScale: xScale,
          xAccessor: xAccessor,
          yScale: yScale,
          yAccessor: yAccessor,
          annotationLayer: annotationLayer
        });
      } else if (d.type === "horizontal-points") {
        return svgHorizontalPointsAnnotation({
          d: d,
          lines: lines.data,
          points: points.data,
          xScale: xScale,
          yScale: yScale,
          pointStyle: points.styleFn
        });
      } else if (d.type === "vertical-points") {
        return svgVerticalPointsAnnotation({
          d: d,
          lines: lines.data,
          points: points.data,
          xScale: xScale,
          yScale: yScale,
          pointStyle: points.styleFn
        });
      }
      return null;
    }
  }, {
    key: "defaultXYHTMLRule",
    value: function defaultXYHTMLRule(_ref3) {
      var d = _ref3.d,
          i = _ref3.i,
          lines = _ref3.lines,
          areas = _ref3.areas,
          points = _ref3.points;

      var xAccessor = this.xAccessor;
      var yAccessor = this.yAccessor;

      var xScale = this.xScale;
      var yScale = this.yScale;

      var screenCoordinates = [];

      var size = this.props.size;


      var idAccessor = stringToFn(this.props.lineIDAccessor, function (l) {
        return l.semioticLineID;
      });
      var xCoord = d[projectedX] || xAccessor(d);
      var yCoord = d[projectedY] || yAccessor(d);

      var xString = xCoord && xCoord.toString ? xCoord.toString() : xCoord;
      var yString = yCoord && yCoord.toString ? yCoord.toString() : yCoord;

      var _adjustedPositionSize3 = adjustedPositionSize(this.props),
          adjustedPosition = _adjustedPositionSize3.adjustedPosition;

      if (!d.coordinates) {
        screenCoordinates = [xScale(xCoord), relativeY({
          point: d,
          lines: lines,
          projectedYMiddle: projectedYMiddle,
          projectedY: projectedY,
          projectedX: projectedX,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          yScale: yScale,
          xScale: xScale,
          idAccessor: idAccessor
        })];
        if (screenCoordinates[0] === undefined || screenCoordinates[1] === undefined || screenCoordinates[0] === null || screenCoordinates[1] === null) {
          //NO ANNOTATION IF INVALID SCREEN COORDINATES
          return null;
        }
      } else {
        screenCoordinates = d.coordinates.map(function (p) {
          return [xScale(xAccessor(p)) + adjustedPosition[0], relativeY({
            point: p,
            lines: lines,
            projectedYMiddle: projectedYMiddle,
            projectedY: projectedY,
            projectedX: projectedX,
            xAccessor: xAccessor,
            yAccessor: yAccessor,
            yScale: yScale,
            xScale: xScale,
            idAccessor: idAccessor
          }) + adjustedPosition[1]];
        });
      }

      if (this.props.htmlAnnotationRules && this.props.htmlAnnotationRules({
        d: d,
        i: i,
        screenCoordinates: screenCoordinates,
        xScale: xScale,
        yScale: yScale,
        xAccessor: xAccessor,
        yAccessor: yAccessor,
        xyFrameProps: this.props,
        xyFrameState: this.state,
        areas: areas,
        points: points,
        lines: lines
      }) !== null) {
        return this.props.htmlAnnotationRules({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          xScale: xScale,
          yScale: yScale,
          xAccessor: xAccessor,
          yAccessor: yAccessor,
          xyFrameProps: this.props,
          xyFrameState: this.state,
          areas: areas,
          points: points,
          lines: lines
        });
      }
      if (d.type === "frame-hover") {
        var content = React.createElement(
          "div",
          { className: "tooltip-content" },
          React.createElement(
            "p",
            { key: "html-annotation-content-1" },
            xString
          ),
          React.createElement(
            "p",
            { key: "html-annotation-content-2" },
            yString
          ),
          d.percent ? React.createElement(
            "p",
            { key: "html-annotation-content-3" },
            parseInt(d.percent * 1000, 10) / 10,
            "%"
          ) : null
        );

        if (d.type === "frame-hover" && this.props.tooltipContent) {
          content = this.props.tooltipContent(d);
        }
        return htmlTooltipAnnotation({
          content: content,
          screenCoordinates: screenCoordinates,
          size: size,
          i: i,
          d: d
        });
      }
      return null;
    }
  }, {
    key: "render",
    value: function render() {
      return this.renderBody({});
    }
  }, {
    key: "renderBody",
    value: function renderBody(_ref4) {
      var afterElements = _ref4.afterElements,
          beforeElements = _ref4.beforeElements;
      var _props = this.props,
          downloadFields = _props.downloadFields,
          xAccessor = _props.xAccessor,
          yAccessor = _props.yAccessor,
          lines = _props.lines,
          points = _props.points,
          areas = _props.areas,
          name = _props.name,
          download = _props.download,
          size = _props.size,
          className = _props.className,
          annotationSettings = _props.annotationSettings,
          annotations = _props.annotations,
          additionalDefs = _props.additionalDefs,
          hoverAnnotation = _props.hoverAnnotation,
          interaction = _props.interaction,
          customClickBehavior = _props.customClickBehavior,
          customHoverBehavior = _props.customHoverBehavior,
          customDoubleClickBehavior = _props.customDoubleClickBehavior,
          canvasPostProcess = _props.canvasPostProcess,
          baseMarkProps = _props.baseMarkProps,
          useSpans = _props.useSpans;
      var _state2 = this.state,
          title = _state2.title,
          backgroundGraphics = _state2.backgroundGraphics,
          foregroundGraphics = _state2.foregroundGraphics,
          adjustedPosition = _state2.adjustedPosition,
          adjustedSize = _state2.adjustedSize,
          margin = _state2.margin,
          matte = _state2.matte,
          axes = _state2.axes,
          axesTickLines = _state2.axesTickLines,
          extent = _state2.extent,
          xScale = _state2.xScale,
          yScale = _state2.yScale,
          dataVersion = _state2.dataVersion,
          fullDataset = _state2.fullDataset,
          areaAnnotations = _state2.areaAnnotations,
          legendSettings = _state2.legendSettings,
          xyFrameRender = _state2.xyFrameRender;


      var downloadButton = void 0;
      if (download && (points || lines)) {
        var downloadData = download === "points" ? mapParentsToPoints(fullDataset) : points || lines;
        downloadButton = React.createElement(DownloadButton, {
          csvName: name + "-" + new Date().toJSON(),
          width: parseInt(size[0], 10),
          data: xyDownloadMapping({
            data: downloadData,
            xAccessor: download === "points" || points ? stringToFn(xAccessor) : undefined,
            yAccessor: download === "points" || points ? stringToFn(yAccessor) : undefined,
            fields: downloadFields
          })
        });
      }

      var finalFilterDefs = filterDefs({
        matte: matte,
        key: matte && (this.props.frameKey || xyframeKey),
        additionalDefs: additionalDefs
      });

      // foreground and background graphics should handle either JSX or a function that passes size & margin and returns JSX
      return React.createElement(Frame, {
        name: "xyframe",
        renderPipeline: xyFrameRender,
        adjustedPosition: adjustedPosition,
        size: size,
        extent: extent,
        projectedCoordinateNames: projectedCoordinateNames,
        xScale: xScale,
        yScale: yScale,
        axes: axes,
        axesTickLines: axesTickLines,
        title: title,
        dataVersion: dataVersion,
        matte: matte,
        className: className,
        adjustedSize: adjustedSize,
        finalFilterDefs: finalFilterDefs,
        frameKey: xyframeKey,
        hoverAnnotation: hoverAnnotation,
        defaultSVGRule: this.defaultXYSVGRule.bind(this),
        defaultHTMLRule: this.defaultXYHTMLRule.bind(this),
        annotations: areaAnnotations.length > 0 ? [].concat(toConsumableArray(annotations), toConsumableArray(areaAnnotations)) : annotations,
        annotationSettings: annotationSettings,
        legendSettings: legendSettings,
        projectedYMiddle: projectedYMiddle,
        interaction: interaction,
        customClickBehavior: customClickBehavior,
        customHoverBehavior: customHoverBehavior,
        customDoubleClickBehavior: customDoubleClickBehavior,
        points: fullDataset,
        margin: margin,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: foregroundGraphics,
        beforeElements: beforeElements,
        afterElements: afterElements,
        downloadButton: downloadButton,
        disableContext: this.props.disableContext,
        canvasPostProcess: canvasPostProcess,
        baseMarkProps: baseMarkProps,
        useSpans: useSpans
      });
    }
  }]);
  return XYFrame;
}(React.Component);

XYFrame.defaultProps = {
  annotations: [],
  foregroundGraphics: undefined,
  size: [500, 500],
  className: "",
  lineType: "line",
  name: "xyframe"
};


XYFrame.propTypes = {
  name: propTypes.string,
  lines: propTypes.oneOfType([propTypes.array, propTypes.object]),
  points: propTypes.oneOfType([propTypes.array, propTypes.object]),
  areas: propTypes.oneOfType([propTypes.array, propTypes.object]),
  title: propTypes.oneOfType([propTypes.string, propTypes.object]),
  margin: propTypes.oneOfType([propTypes.number, propTypes.object]),
  dataVersion: propTypes.string,
  frameKey: propTypes.string,
  axes: propTypes.oneOfType([propTypes.array, propTypes.object]),
  matte: propTypes.oneOfType([propTypes.bool, propTypes.object]),
  size: propTypes.array,
  position: propTypes.array,
  xScaleType: propTypes.func,
  yScaleType: propTypes.func,
  xExtent: propTypes.oneOfType([propTypes.array, propTypes.object]),
  yExtent: propTypes.oneOfType([propTypes.array, propTypes.object]),
  invertX: propTypes.bool,
  invertY: propTypes.bool,
  xAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  yAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  lineDataAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  areaDataAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  backgroundGraphics: propTypes.oneOfType([propTypes.array, propTypes.object]),
  foregroundGraphics: propTypes.oneOfType([propTypes.array, propTypes.object]),
  canvasPostProcess: propTypes.oneOfType([propTypes.func, propTypes.string]),
  additionalDefs: propTypes.oneOfType([propTypes.array, propTypes.object]),
  customHoverBehavior: propTypes.func,
  customClickBehavior: propTypes.func,
  customDoubleclickBehavior: propTypes.func,
  lineType: propTypes.oneOfType([propTypes.string, propTypes.object]),
  showLinePoints: propTypes.bool,
  defined: propTypes.func,
  lineStyle: propTypes.oneOfType([propTypes.func, propTypes.object]),
  pointStyle: propTypes.oneOfType([propTypes.func, propTypes.object]),
  areaStyle: propTypes.oneOfType([propTypes.func, propTypes.object]),
  lineClass: propTypes.oneOfType([propTypes.func, propTypes.string]),
  pointClass: propTypes.oneOfType([propTypes.func, propTypes.string]),
  areaClass: propTypes.oneOfType([propTypes.func, propTypes.string]),
  canvasPoints: propTypes.oneOfType([propTypes.func, propTypes.bool]),
  customPointMark: propTypes.oneOfType([propTypes.func, propTypes.object]),
  hoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool]),
  customLineMark: propTypes.func,
  customAreaMark: propTypes.func,
  lineIDAccessor: propTypes.oneOfType([propTypes.func, propTypes.string]),
  svgAnnotationRules: propTypes.func,
  htmlAnnotationRules: propTypes.func,
  tooltipContent: propTypes.func,
  annotations: propTypes.array,
  interaction: propTypes.object,
  baseMarkProps: propTypes.object,
  download: propTypes.oneOfType([propTypes.bool, propTypes.string]), //add a download button for graphs data as csv
  downloadFields: propTypes.array //additional fields aside from x,y to add to the csv
};

function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
}

function arcBracket(_ref) {
  var x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      startAngle = _ref.startAngle,
      endAngle = _ref.endAngle,
      inset = _ref.inset,
      outset = _ref.outset,
      _ref$curly = _ref.curly,
      curly = _ref$curly === undefined ? true : _ref$curly;

  var start = polarToCartesian(x, y, radius + outset, endAngle);
  var end = polarToCartesian(x, y, radius + outset, startAngle);

  var innerStart = polarToCartesian(x, y, radius + outset - inset, endAngle);
  var innerEnd = polarToCartesian(x, y, radius + outset - inset, startAngle);

  var angleSize = endAngle - startAngle;
  var largeArcFlag = angleSize <= 180 ? "0" : "1";
  var d = void 0;
  if (curly) {
    var curlyOffset = Math.min(10, angleSize / 4);

    var middleLeft = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 + curlyOffset);

    var middle = polarToCartesian(x, y, radius + outset + 10, (startAngle + endAngle) / 2);
    var middleRight = polarToCartesian(x, y, radius + outset, (startAngle + endAngle) / 2 - curlyOffset);

    d = ["M", innerStart.x, innerStart.y, "L", start.x, start.y, "A", radius + outset, radius + outset, 0, 0, 0, middleLeft.x, middleLeft.y, "A", radius + outset, radius + outset, 1, 0, 1, middle.x, middle.y, "A", radius + outset, radius + outset, 1, 0, 1, middleRight.x, middleRight.y, "A", radius + outset, radius + outset, 0, 0, 0, end.x, end.y, "L", innerEnd.x, innerEnd.y].join(" ");
  } else {
    d = ["M", innerStart.x, innerStart.y, "L", start.x, start.y, "A", radius + outset, radius + outset, 0, largeArcFlag, 0, end.x, end.y, "L", innerEnd.x, innerEnd.y].join(" ");
  }

  var midAngle = (startAngle + endAngle) / 2;
  var textOffset = void 0,
      largeTextArcFlag = void 0,
      finalTextEnd = void 0,
      finalTextStart = void 0,
      arcFlip = void 0;
  var lowerArc = midAngle > 90 && midAngle < 270;
  if (lowerArc) {
    textOffset = 12;
    largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    arcFlip = 0;
  } else {
    largeTextArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
    textOffset = 5;
    arcFlip = 1;
  }
  textOffset += curly ? 10 : 0;
  var textStart = polarToCartesian(x, y, radius + outset + textOffset, endAngle);
  var textEnd = polarToCartesian(x, y, radius + outset + textOffset, startAngle);
  if (lowerArc) {
    finalTextStart = textStart;
    finalTextEnd = textEnd;
  } else {
    finalTextStart = textEnd;
    finalTextEnd = textStart;
  }

  var textD = ["M", finalTextStart.x, finalTextStart.y, "A", radius + outset + textOffset, radius + outset + textOffset, arcFlip, largeTextArcFlag, arcFlip, finalTextEnd.x, finalTextEnd.y].join(" ");

  return { arcPath: d, textArcPath: textD };
}

var svgHighlightRule = function svgHighlightRule(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      screenCoordinates = _ref2.screenCoordinates,
      projection = _ref2.projection,
      categories = _ref2.categories,
      pieceIDAccessor = _ref2.pieceIDAccessor,
      orFrameRender = _ref2.orFrameRender,
      oAccessor = _ref2.oAccessor;

  var thisID = pieceIDAccessor(d);
  var thisO = oAccessor(d);

  var foundPieces = orFrameRender.pieces && orFrameRender.pieces.data.filter(function (p) {
    return (thisID === undefined || pieceIDAccessor(p.piece.data) === thisID) && (thisO === undefined || oAccessor(p.piece.data) === thisO);
  }).map(function (p, q) {
    if (React.isValidElement(p.renderElement)) {
      console.error("OrdinalFrame highlighting currently only works with built-in pieces and not custom pieces");
      return null;
    }
    var styleObject = {
      style: {}
    };
    if (d.style && typeof d.style === "function") {
      styleObject = { style: d.style(p.piece.data) };
    } else if (d.style) {
      styleObject = { style: d.style };
    }
    var styledD = _extends({}, p.renderElement, styleObject);
    var className = "highlight-annotation " + (d.class && typeof d.class === "function" && d.class(p.piece.data, q) || d.class && d.class || "");

    return React.createElement(lib_2$1, _extends({
      fill: "none",
      stroke: "black",
      strokeWidth: "2px",
      key: "highlight-piece-" + q
    }, styledD, {
      className: className
    }));
  }) || [];
  /*
  const foundSummaries =
    (orFrameRender.summaries &&
      orFrameRender.summaries.data
        .filter(p => {
          return oAccessor(p.piece.data) === thisID
        })
        .map(p => {
          if (React.isValidElement(p.renderElement)) {
            console.error(
              "OrdinalFrame highlighting currently only works with built-in pieces and not custom pieces"
            )
            return null
          }
          let styleObject = {
            style: { fill: "none", stroke: "black", strokeWidth: "2px" }
          }
          if (d.style && typeof d.style === "function") {
            styleObject = { style: d.style(p.piece.data) }
          } else if (d.style) {
            styleObject = { style: d.style }
          }
          const styledD = { ...p.renderElement, ...styleObject }
           return <Mark {...styledD} />
        })) ||
    []
  */

  return [].concat(toConsumableArray(foundPieces));
};

var svgORRule = function svgORRule(_ref3) {
  var d = _ref3.d,
      i = _ref3.i,
      screenCoordinates = _ref3.screenCoordinates,
      projection = _ref3.projection;

  return React.createElement(
    lib_2$1,
    {
      markType: "text",
      key: d.label + "annotationtext" + i,
      forceUpdate: true,
      x: screenCoordinates[0] + (projection === "horizontal" ? 10 : 0),
      y: screenCoordinates[1] + (projection === "vertical" ? 10 : 0),
      className: "annotation annotation-or-label " + (d.className || ""),
      textAnchor: "middle"
    },
    d.label
  );
};

var basicReactAnnotationRule = function basicReactAnnotationRule(_ref4) {
  var d = _ref4.d,
      i = _ref4.i,
      screenCoordinates = _ref4.screenCoordinates;

  var noteData = Object.assign({
    dx: 0,
    dy: 0,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    x: screenCoordinates[0],
    y: screenCoordinates[1],
    type: typeof d.type === "function" ? d.type : undefined,
    screenCoordinates: screenCoordinates
  });
  if (d.fixedX) noteData.x = d.fixedX;
  if (d.fixedY) noteData.y = d.fixedY;
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgEncloseRule = function svgEncloseRule(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      screenCoordinates = _ref5.screenCoordinates;

  var circle = packEnclose$1(screenCoordinates.map(function (p) {
    return { x: p[0], y: p[1], r: 2 };
  }));

  return circleEnclosure({ d: d, i: i, circle: circle });
};

var svgRRule = function svgRRule(_ref6) {
  var d = _ref6.d,
      i = _ref6.i,
      screenCoordinates = _ref6.screenCoordinates,
      rScale = _ref6.rScale,
      rAccessor = _ref6.rAccessor,
      adjustedSize = _ref6.adjustedSize,
      adjustedPosition = _ref6.adjustedPosition,
      projection = _ref6.projection;

  var x = void 0,
      y = void 0,
      xPosition = void 0,
      yPosition = void 0,
      subject = void 0,
      dx = void 0,
      dy = void 0;
  if (projection === "radial") {
    return React.createElement(SemioticAnnotation, {
      key: d.key || "annotation-" + i,
      noteData: Object.assign({
        dx: 50,
        dy: 50,
        note: { label: d.label },
        connector: { end: "arrow" }
      }, d, {
        type: lib_8,
        subject: {
          radius: rScale(rAccessor(d)) / 2,
          radiusPadding: 0
        },
        x: adjustedSize[0] / 2,
        y: adjustedSize[1] / 2
      })
    });
  } else if (projection === "horizontal") {
    dx = 50;
    dy = 50;
    yPosition = d.offset || i * 25;
    x = screenCoordinates[0];
    y = yPosition;
    subject = {
      x: x,
      y1: 0,
      y2: adjustedSize[1] + adjustedPosition[1]
    };
  } else {
    dx = 50;
    dy = -20;
    xPosition = d.offset || i * 25;
    y = screenCoordinates[1];
    x = xPosition;
    subject = {
      y: y,
      x1: 0,
      x2: adjustedSize[0] + adjustedPosition[0]
    };
  }

  var noteData = Object.assign({
    dx: dx,
    dy: dy,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_4,
    x: x,
    y: y,
    subject: subject
  });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgCategoryRule = function svgCategoryRule(_ref7) {
  var projection = _ref7.projection,
      d = _ref7.d,
      i = _ref7.i,
      categories = _ref7.categories,
      adjustedSize = _ref7.adjustedSize;
  var _d$bracketType = d.bracketType,
      bracketType = _d$bracketType === undefined ? "curly" : _d$bracketType,
      _d$position = d.position,
      position = _d$position === undefined ? projection === "vertical" ? "top" : "left" : _d$position,
      _d$depth = d.depth,
      depth = _d$depth === undefined ? 30 : _d$depth,
      _d$offset = d.offset,
      offset = _d$offset === undefined ? 0 : _d$offset,
      _d$padding = d.padding,
      padding = _d$padding === undefined ? 0 : _d$padding;

  var actualCategories = Array.isArray(d.categories) ? d.categories : [d.categories];
  var cats = actualCategories.map(function (c) {
    return categories[c];
  });

  if (projection === "radial") {
    var arcPadding = padding / adjustedSize[1];
    var leftX = min(cats.map(function (p) {
      return p.pct_start + p.pct_padding / 2 + arcPadding / 2;
    }));
    var rightX = max(cats.map(function (p) {
      return p.pct_start + p.pct - p.pct_padding / 2 - arcPadding / 2;
    }));

    var chartSize = Math.min(adjustedSize[0], adjustedSize[1]) / 2;
    var centerX = adjustedSize[0] / 2;
    var centerY = adjustedSize[1] / 2;

    var _arcBracket = arcBracket({
      x: 0,
      y: 0,
      radius: chartSize,
      startAngle: leftX * 360,
      endAngle: rightX * 360,
      inset: depth,
      outset: offset,
      curly: bracketType === "curly"
    }),
        arcPath = _arcBracket.arcPath,
        textArcPath = _arcBracket.textArcPath;

    var textPathID = "text-path-" + i + "-" + Math.random();
    return React.createElement(
      "g",
      {
        className: "category-annotation annotation",
        transform: "translate(" + centerX + "," + centerY + ")"
      },
      React.createElement("path", { d: arcPath, fill: "none" }),
      React.createElement("path", { id: textPathID, d: textArcPath, style: { display: "none" } }),
      React.createElement(
        "text",
        { "font-size": "12.5" },
        React.createElement(
          "textPath",
          {
            startOffset: "50%",
            textAnchor: "middle",
            xlinkHref: "#" + textPathID
          },
          d.label
        )
      )
    );
  } else {
    var _leftX = min(cats.map(function (p) {
      return p.x;
    }));
    var _rightX = max(cats.map(function (p) {
      return p.x + p.width;
    }));

    if (projection === "vertical") {
      var yPosition = position === "top" ? 0 : adjustedSize[1];
      yPosition += position === "top" ? -offset : offset;
      var noteData = {
        type: lib_2,
        y: yPosition,
        x: _leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          width: _rightX - _leftX + padding * 2,
          depth: position === "top" ? -depth : depth
        }
      };
      return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
    } else if (projection === "horizontal") {
      var _yPosition = position === "left" ? 0 : adjustedSize[0];
      _yPosition += position === "left" ? -offset : offset;
      var _noteData = {
        type: lib_2,
        x: _yPosition,
        y: _leftX - padding,
        note: {
          title: d.title || d.label,
          label: d.title ? d.label : undefined
        },
        subject: {
          type: bracketType,
          height: _rightX - _leftX + padding * 2,
          depth: position === "left" ? -depth : depth
        }
      };
      return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: _noteData });
    }
  }
};

var htmlFrameHoverRule = function htmlFrameHoverRule(_ref8) {
  var d = _ref8.d,
      i = _ref8.i,
      rAccessor = _ref8.rAccessor,
      oAccessor = _ref8.oAccessor,
      projection = _ref8.projection,
      tooltipContent = _ref8.tooltipContent;

  //To string because React gives a DOM error if it gets a date
  var contentFill = void 0;
  if (d.isSummaryData) {
    var summaryLabel = React.createElement(
      "p",
      { key: "html-annotation-content-2" },
      d.label
    );
    if (d.pieces && d.pieces.length !== 0) {
      if (d.pieces.length === 1) {
        summaryLabel = React.createElement(
          "p",
          { key: "html-annotation-content-2" },
          rAccessor(d.pieces[0].data)
        );
      } else {
        var pieceData = extent(d.pieces.map(function (p) {
          return p.data;
        }).map(rAccessor));
        summaryLabel = React.createElement(
          "p",
          { key: "html-annotation-content-2" },
          "From ",
          pieceData[0],
          " to ",
          pieceData[1]
        );
      }
    }
    contentFill = [React.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.key
    ), summaryLabel, React.createElement(
      "p",
      { key: "html-annotation-content-3" },
      d.value
    )];
  } else {
    contentFill = [oAccessor(d.data) && React.createElement(
      "p",
      { key: "html-annotation-content-1" },
      oAccessor(d.data).toString()
    ), rAccessor(d.data) && React.createElement(
      "p",
      { key: "html-annotation-content-2" },
      rAccessor(d.data).toString()
    )];
  }
  var content = React.createElement(
    "div",
    { className: "tooltip-content" },
    contentFill
  );

  if (d.type === "frame-hover" && tooltipContent) {
    content = tooltipContent(d);
  }

  return React.createElement(
    "div",
    {
      key: "xylabel-" + i,
      className: "annotation annotation-or-label tooltip " + projection + " " + (d.className || ""),
      style: {
        position: "absolute",
        top: d.y + "px",
        left: d.x + "px"
      }
    },
    content
  );
};

var htmlColumnHoverRule = function htmlColumnHoverRule(_ref9) {
  var d = _ref9.d,
      i = _ref9.i,
      summaryType = _ref9.summaryType,
      oAccessor = _ref9.oAccessor,
      projectedColumns = _ref9.projectedColumns,
      type = _ref9.type,
      adjustedPosition = _ref9.adjustedPosition,
      adjustedSize = _ref9.adjustedSize,
      projection = _ref9.projection,
      tooltipContent = _ref9.tooltipContent;

  //we need to ignore negative pieces to make sure the hover behavior populates on top of the positive bar
  var positionValue = summaryType.type || ["swarm", "point", "clusterbar"].find(function (p) {
    return p === type.type;
  }) ? max(d.pieces.map(function (p) {
    return p.scaledValue;
  })) : sum$1(d.pieces.map(function (p) {
    return p.scaledValue;
  }).filter(function (p) {
    return p > 0;
  }));

  var column = projectedColumns[oAccessor(d.pieces[0].data)];

  var xPosition = column.middle + adjustedPosition[0];
  var yPosition = adjustedSize[1] - positionValue;
  yPosition += 10;

  if (projection === "horizontal") {
    yPosition = projectedColumns[oAccessor(d.pieces[0].data)].middle;
    xPosition = positionValue + adjustedPosition[0];
  } else if (projection === "radial") {
    
    var _pointOnArcAtAngle = pointOnArcAtAngle([d.arcAngles.translate[0], d.arcAngles.translate[1]], d.arcAngles.midAngle, d.arcAngles.length);

    var _pointOnArcAtAngle2 = slicedToArray(_pointOnArcAtAngle, 2);

    xPosition = _pointOnArcAtAngle2[0];
    yPosition = _pointOnArcAtAngle2[1];

    yPosition += 10;
  }

  //To string because React gives a DOM error if it gets a date
  var content = React.createElement(
    "div",
    { className: "tooltip-content" },
    oAccessor(d.pieces[0].data) && React.createElement(
      "p",
      { key: "or-annotation-1" },
      oAccessor(d.pieces[0].data).toString()
    ),
    React.createElement(
      "p",
      { key: "or-annotation-2" },
      sum$1(d.pieces.map(function (p) {
        return p.value;
      }).filter(function (p) {
        return p > 0;
      }))
    )
  );

  if (d.type === "column-hover" && tooltipContent) {
    if (tooltipContent === "pie") {
      content = React.createElement(
        "div",
        { className: "tooltip-content" },
        oAccessor(d.pieces[0].data) && React.createElement(
          "p",
          { key: "or-annotation-1" },
          oAccessor(d.pieces[0].data).toString()
        ),
        React.createElement(
          "p",
          { key: "or-annotation-2" },
          (column.pct * 100).toFixed(0) + "%"
        )
      );
    } else {
      content = tooltipContent(_extends({}, d, {
        pieces: d.pieces.map(function (p) {
          return p.data;
        }),
        column: column
      }));
    }
  }

  if (d.type === "xy") {
    content = d.label;
  }

  return React.createElement(
    "div",
    {
      key: "orlabel-" + i,
      className: "annotation annotation-or-label tooltip " + projection + " " + (d.className || ""),
      style: {
        position: "absolute",
        top: yPosition + "px",
        left: xPosition + "px"
      }
    },
    content
  );
};

var svgRectEncloseRule$1 = function svgRectEncloseRule(_ref10) {
  var d = _ref10.d,
      i = _ref10.i,
      screenCoordinates = _ref10.screenCoordinates;

  var bboxNodes = screenCoordinates.map(function (p) {
    return {
      x0: p.x0 = p[0],
      x1: p.x1 = p[0],
      y0: p.y0 = p[1],
      y1: p.y1 = p[1]
    };
  });

  return rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};

var constant$11 = function (x) {
  return function () {
    return x;
  };
};

var jiggle = function () {
  return (Math.random() - 0.5) * 1e-6;
};

var tree_add = function (d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
};

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = { data: d },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

var tree_cover = function (x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
      var z = x1 - x0,
          node = this._root,
          parent,
          i;

      switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
        case 0:
          {
            do {
              parent = new Array(4), parent[i] = node, node = parent;
            } while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));
            break;
          }
        case 1:
          {
            do {
              parent = new Array(4), parent[i] = node, node = parent;
            } while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));
            break;
          }
        case 2:
          {
            do {
              parent = new Array(4), parent[i] = node, node = parent;
            } while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));
            break;
          }
        case 3:
          {
            do {
              parent = new Array(4), parent[i] = node, node = parent;
            } while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));
            break;
          }
      }

      if (this._root && this._root.length) this._root = node;
    }

    // If the quadtree covers the point already, just return.
    else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
};

var tree_data = function () {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do {
      data.push(node.data);
    } while (node = node.next);
  });
  return data;
};

var tree_extent = function (_) {
    return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
};

var Quad = function (node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};

var tree_find = function (x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym));

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
  }

  return data;
};

var tree_remove = function (d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) {
    if (!(previous = node, node = node.next)) return this;
  }if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return next ? previous.next = next : delete previous.next, this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
};

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) {
    this.remove(data[i]);
  }return this;
}

var tree_root = function () {
  return this._root;
};

var tree_size = function () {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do {
      ++size;
    } while (node = node.next);
  });
  return size;
};

var tree_visit = function (callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
};

var tree_visitAfter = function (callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
};

function defaultX$1(d) {
  return d[0];
}

var tree_x = function (_) {
  return arguments.length ? (this._x = _, this) : this._x;
};

function defaultY$1(d) {
  return d[1];
}

var tree_y = function (_) {
  return arguments.length ? (this._y = _, this) : this._y;
};

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = { data: leaf.data },
      next = copy;
  while (leaf = leaf.next) {
    next = next.next = { data: leaf.data };
  }return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{ source: node, target: copy._root = new Array(4) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function x$3(d) {
  return d.x + d.vx;
}

function y$3(d) {
  return d.y + d.vy;
}

var forceCollide = function (radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$11(radius == null ? 1 : +radius);

  function force() {
    var i,
        n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x$3, y$3).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[i], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data,
          rj = quad.r,
          r = ri + rj;
      if (data) {
        if (data.index > i) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  force.initialize = function (_) {
    var i,
        n = (nodes = _).length;radii = new Array(n);
    for (i = 0; i < n; ++i) {
      radii[i] = +radius(nodes[i], i, nodes);
    }
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$11(+_), force) : radius;
  };

  return force;
};

function index$3(d, i) {
  return i;
}

var forceLink = function (links) {
  var id = index$3,
      strength = defaultStrength,
      strengths,
      distance = constant$11(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = map$1(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < n; ++i) {
      count[i] = 0;
    }

    for (i = 0; i < m; ++i) {
      link = links[i], link.index = i;
      if (_typeof(link.source) !== "object") link.source = nodeById.get(link.source);
      if (_typeof(link.target) !== "object") link.target = nodeById.get(link.target);
      ++count[link.source.index], ++count[link.target.index];
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.links = function (_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function (_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$11(+_), initializeStrength(), force) : strength;
  };

  force.distance = function (_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$11(+_), initializeDistance(), force) : distance;
  };

  return force;
};

function x$4(d) {
  return d.x;
}

function y$4(d) {
  return d.y;
}

var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));

function _default(_nodes) {
  var simulation,
      _alpha = 1,
      _alphaMin = 0.001,
      _alphaDecay = 1 - Math.pow(_alphaMin, 1 / 300),
      _alphaTarget = 0,
      _velocityDecay = 0.6,
      forces = map$1(),
      stepper = timer(step),
      event = dispatch("tick", "end");

  if (_nodes == null) _nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (_alpha < _alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i,
        n = _nodes.length,
        node;

    _alpha += (_alphaTarget - _alpha) * _alphaDecay;

    forces.each(function (force) {
      force(_alpha);
    });

    for (i = 0; i < n; ++i) {
      node = _nodes[i];
      if (node.fx == null) node.x += node.vx *= _velocityDecay;else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= _velocityDecay;else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = _nodes.length, node; i < n; ++i) {
      node = _nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i),
            angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(_nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function restart() {
      return stepper.restart(step), simulation;
    },

    stop: function stop() {
      return stepper.stop(), simulation;
    },

    nodes: function nodes(_) {
      return arguments.length ? (_nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : _nodes;
    },

    alpha: function alpha(_) {
      return arguments.length ? (_alpha = +_, simulation) : _alpha;
    },

    alphaMin: function alphaMin(_) {
      return arguments.length ? (_alphaMin = +_, simulation) : _alphaMin;
    },

    alphaDecay: function alphaDecay(_) {
      return arguments.length ? (_alphaDecay = +_, simulation) : +_alphaDecay;
    },

    alphaTarget: function alphaTarget(_) {
      return arguments.length ? (_alphaTarget = +_, simulation) : _alphaTarget;
    },

    velocityDecay: function velocityDecay(_) {
      return arguments.length ? (_velocityDecay = 1 - _, simulation) : 1 - _velocityDecay;
    },

    force: function force(name, _) {
      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },

    find: function find(x, y, radius) {
      var i = 0,
          n = _nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = _nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function on(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

var forceManyBody = function () {
  var nodes,
      node,
      alpha,
      strength = constant$11(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i,
        n = nodes.length,
        tree = quadtree(nodes, x$4, y$4).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) {
      node = nodes[i], tree.visit(apply);
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = +strength(nodes[i], i, nodes);
    }
  }

  function accumulate(quad) {
    var strength = 0,
        q,
        c,
        x,
        y,
        i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = q.value)) {
          strength += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / strength;
      quad.y = y / strength;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do {
          strength += strengths[q.data.index];
        } while (q = q.next);
      }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do {
      if (quad.data !== node) {
        w = strengths[quad.data.index] * alpha / l;
        node.vx += x * w;
        node.vy += y * w;
      }
    } while (quad = quad.next);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$11(+_), initialize(), force) : strength;
  };

  force.distanceMin = function (_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function (_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function (_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
};

var forceX = function (x) {
  var strength = constant$11(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$11(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$11(+_), initialize(), force) : strength;
  };

  force.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$11(+_), initialize(), force) : x;
  };

  return force;
};

var forceY = function (y) {
  var strength = constant$11(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$11(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$11(+_), initialize(), force) : strength;
  };

  force.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$11(+_), initialize(), force) : y;
  };

  return force;
};

var BoundingBox_1 = BoundingBox;

// from https://github.com/gabelerner/canvg/blob/860e418aca67b9a41e858a223d74d375793ec364/canvg.js#L449

function BoundingBox(x1, y1, x2, y2) {
  // pass in initial points if you want
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;

  this.addPoint(x1, y1);
  this.addPoint(x2, y2);
}

BoundingBox.prototype = {

  width: function width() {
    return this.x2 - this.x1;
  },

  height: function height() {
    return this.y2 - this.y1;
  },

  addPoint: function addPoint(x, y) {
    if (x != null) {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x;
        this.x2 = x;
      }
      if (x < this.x1) this.x1 = x;
      if (x > this.x2) this.x2 = x;
    }

    if (y != null) {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y;
        this.y2 = y;
      }
      if (y < this.y1) this.y1 = y;
      if (y > this.y2) this.y2 = y;
    }
  },

  addX: function addX(x) {
    this.addPoint(x, null);
  },

  addY: function addY(y) {
    this.addPoint(null, y);
  },

  addQuadraticCurve: function addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
    var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
    var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  },

  addBezierCurve: function addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    var i,
        p0 = [p0x, p0y],
        p1 = [p1x, p1y],
        p2 = [p2x, p2y],
        p3 = [p3x, p3y];

    this.addPoint(p0[0], p0[1]);
    this.addPoint(p3[0], p3[1]);

    for (i = 0; i <= 1; i++) {
      var f = function f(t) {
        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
      };

      var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
      var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
      var c = 3 * p1[i] - 3 * p0[i];

      if (a == 0) {
        if (b == 0) continue;
        var t = -c / b;
        if (0 < t && t < 1) {
          if (i == 0) this.addX(f(t));
          if (i == 1) this.addY(f(t));
        }
        continue;
      }

      var b2ac = Math.pow(b, 2) - 4 * c * a;
      if (b2ac < 0) continue;
      var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
      if (0 < t1 && t1 < 1) {
        if (i == 0) this.addX(f(t1));
        if (i == 1) this.addY(f(t1));
      }
      var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
      if (0 < t2 && t2 < 1) {
        if (i == 0) this.addX(f(t2));
        if (i == 1) this.addY(f(t2));
      }
    }
  }

};

var BoundingBoxView_1 = BoundingBoxView;

function BoundingBoxView(boundingBox) {

  this.x1 = this.minX = boundingBox.x1 || 0;
  this.y1 = this.minY = boundingBox.y1 || 0;
  this.x2 = this.maxX = boundingBox.x2 || 0;
  this.y2 = this.maxY = boundingBox.y2 || 0;
  this.width = boundingBox.width() || 0;
  this.height = boundingBox.height() || 0;
}

BoundingBoxView.prototype = {

  round: function round(precision) {
    precision = precision || 0;

    this.x1 = this.minX = +this.x1.toFixed(precision);
    this.y1 = this.minY = +this.y1.toFixed(precision);
    this.x2 = this.maxX = +this.x2.toFixed(precision);
    this.y2 = this.maxY = +this.y2.toFixed(precision);
    this.width = +this.width.toFixed(precision);
    this.height = +this.height.toFixed(precision);

    return this;
  },

  scale: function scale(_scale) {
    var self = this;

    _scale = _scale || 1;

    ['x1', 'minX', 'y1', 'minY', 'x2', 'maxX', 'y2', 'maxY', 'width', 'height'].forEach(function (name) {
      self[name] = self[name] * _scale;
    });

    return this;
  },

  toString: function toString() {
    return [this.minX, this.minY, this.width, this.height].join(' ');
  }

};

var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };

var SPECIAL_SPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

function isSpace(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029 || // Line terminators
  // White spaces
  ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0;
}

function isCommand(code) {
  /*eslint-disable no-bitwise*/
  switch (code | 0x20) {
    case 0x6D /* m */:
    case 0x7A /* z */:
    case 0x6C /* l */:
    case 0x68 /* h */:
    case 0x76 /* v */:
    case 0x63 /* c */:
    case 0x73 /* s */:
    case 0x71 /* q */:
    case 0x74 /* t */:
    case 0x61 /* a */:
    case 0x72 /* r */:
      return true;
  }
  return false;
}

function isDigit(code) {
  return code >= 48 && code <= 57; // 0..9
}

function isDigitStart(code) {
  return code >= 48 && code <= 57 || /* 0..9 */
  code === 0x2B || /* + */
  code === 0x2D || /* - */
  code === 0x2E; /* . */
}

function State(path) {
  this.index = 0;
  this.path = path;
  this.max = path.length;
  this.result = [];
  this.param = 0.0;
  this.err = '';
  this.segmentStart = 0;
  this.data = [];
}

function skipSpaces(state) {
  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {
    state.index++;
  }
}

function scanParam(state) {
  var start = state.index,
      index = start,
      max = state.max,
      zeroFirst = false,
      hasCeiling = false,
      hasDecimal = false,
      hasDot = false,
      ch;

  if (index >= max) {
    state.err = 'SvgPath: missed param (at pos ' + index + ')';
    return;
  }
  ch = state.path.charCodeAt(index);

  if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
      index++;
      ch = index < max ? state.path.charCodeAt(index) : 0;
    }

  // This logic is shamelessly borrowed from Esprima
  // https://github.com/ariya/esprimas
  //
  if (!isDigit(ch) && ch !== 0x2E /* . */) {
      state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
      return;
    }

  if (ch !== 0x2E /* . */) {
      zeroFirst = ch === 0x30 /* 0 */;
      index++;

      ch = index < max ? state.path.charCodeAt(index) : 0;

      if (zeroFirst && index < max) {
        // decimal number starts with '0' such as '09' is illegal.
        if (ch && isDigit(ch)) {
          state.err = 'SvgPath: numbers started with `0` such as `09` are ilegal (at pos ' + start + ')';
          return;
        }
      }

      while (index < max && isDigit(state.path.charCodeAt(index))) {
        index++;
        hasCeiling = true;
      }
      ch = index < max ? state.path.charCodeAt(index) : 0;
    }

  if (ch === 0x2E /* . */) {
      hasDot = true;
      index++;
      while (isDigit(state.path.charCodeAt(index))) {
        index++;
        hasDecimal = true;
      }
      ch = index < max ? state.path.charCodeAt(index) : 0;
    }

  if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {
      if (hasDot && !hasCeiling && !hasDecimal) {
        state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
        return;
      }

      index++;

      ch = index < max ? state.path.charCodeAt(index) : 0;
      if (ch === 0x2B /* + */ || ch === 0x2D /* - */) {
          index++;
        }
      if (index < max && isDigit(state.path.charCodeAt(index))) {
        while (index < max && isDigit(state.path.charCodeAt(index))) {
          index++;
        }
      } else {
        state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';
        return;
      }
    }

  state.index = index;
  state.param = parseFloat(state.path.slice(start, index)) + 0.0;
}

function finalizeSegment(state) {
  var cmd, cmdLC;

  // Process duplicated commands (without comand name)

  // This logic is shamelessly borrowed from Raphael
  // https://github.com/DmitryBaranovskiy/raphael/
  //
  cmd = state.path[state.segmentStart];
  cmdLC = cmd.toLowerCase();

  var params = state.data;

  if (cmdLC === 'm' && params.length > 2) {
    state.result.push([cmd, params[0], params[1]]);
    params = params.slice(2);
    cmdLC = 'l';
    cmd = cmd === 'm' ? 'l' : 'L';
  }

  if (cmdLC === 'r') {
    state.result.push([cmd].concat(params));
  } else {

    while (params.length >= paramCounts[cmdLC]) {
      state.result.push([cmd].concat(params.splice(0, paramCounts[cmdLC])));
      if (!paramCounts[cmdLC]) {
        break;
      }
    }
  }
}

function scanSegment(state) {
  var max = state.max,
      cmdCode,
      comma_found,
      need_params,
      i;

  state.segmentStart = state.index;
  cmdCode = state.path.charCodeAt(state.index);

  if (!isCommand(cmdCode)) {
    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';
    return;
  }

  need_params = paramCounts[state.path[state.index].toLowerCase()];

  state.index++;
  skipSpaces(state);

  state.data = [];

  if (!need_params) {
    // Z
    finalizeSegment(state);
    return;
  }

  comma_found = false;

  for (;;) {
    for (i = need_params; i > 0; i--) {
      scanParam(state);
      if (state.err.length) {
        return;
      }
      state.data.push(state.param);

      skipSpaces(state);
      comma_found = false;

      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C /* , */) {
          state.index++;
          skipSpaces(state);
          comma_found = true;
        }
    }

    // after ',' param is mandatory
    if (comma_found) {
      continue;
    }

    if (state.index >= state.max) {
      break;
    }

    // Stop on next segment
    if (!isDigitStart(state.path.charCodeAt(state.index))) {
      break;
    }
  }

  finalizeSegment(state);
}

/* Returns array of segments:
 *
 * [
 *   [ command, coord1, coord2, ... ]
 * ]
 */
var path_parse = function pathParse(svgPath) {
  var state = new State(svgPath);
  var max = state.max;

  skipSpaces(state);

  while (state.index < max && !state.err.length) {
    scanSegment(state);
  }

  if (state.err.length) {
    state.result = [];
  } else if (state.result.length) {

    if ('mM'.indexOf(state.result[0][0]) < 0) {
      state.err = 'SvgPath: string should start with `M` or `m`';
      state.result = [];
    } else {
      state.result[0][0] = 'M';
    }
  }

  return {
    err: state.err,
    segments: state.result
  };
};

// combine 2 matrixes
// m1, m2 - [a, b, c, d, e, g]
//

function combine(m1, m2) {
  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
}

function Matrix() {
  if (!(this instanceof Matrix)) {
    return new Matrix();
  }
  this.queue = []; // list of matrixes to apply
  this.cache = null; // combined matrix cache
}

Matrix.prototype.matrix = function (m) {
  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {
    return this;
  }
  this.cache = null;
  this.queue.push(m);
  return this;
};

Matrix.prototype.translate = function (tx, ty) {
  if (tx !== 0 || ty !== 0) {
    this.cache = null;
    this.queue.push([1, 0, 0, 1, tx, ty]);
  }
  return this;
};

Matrix.prototype.scale = function (sx, sy) {
  if (sx !== 1 || sy !== 1) {
    this.cache = null;
    this.queue.push([sx, 0, 0, sy, 0, 0]);
  }
  return this;
};

Matrix.prototype.rotate = function (angle, rx, ry) {
  var rad, cos, sin;

  if (angle !== 0) {
    this.translate(rx, ry);

    rad = angle * Math.PI / 180;
    cos = Math.cos(rad);
    sin = Math.sin(rad);

    this.queue.push([cos, sin, -sin, cos, 0, 0]);
    this.cache = null;

    this.translate(-rx, -ry);
  }
  return this;
};

Matrix.prototype.skewX = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);
  }
  return this;
};

Matrix.prototype.skewY = function (angle) {
  if (angle !== 0) {
    this.cache = null;
    this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);
  }
  return this;
};

// Flatten queue
//
Matrix.prototype.toArray = function () {
  if (this.cache) {
    return this.cache;
  }

  if (!this.queue.length) {
    this.cache = [1, 0, 0, 1, 0, 0];
    return this.cache;
  }

  this.cache = this.queue[0];

  if (this.queue.length === 1) {
    return this.cache;
  }

  for (var i = 1; i < this.queue.length; i++) {
    this.cache = combine(this.cache, this.queue[i]);
  }

  return this.cache;
};

// Apply list of matrixes to (x,y) point.
// If `isRelative` set, `translate` component of matrix will be skipped
//
Matrix.prototype.calc = function (x, y, isRelative) {
  var m;

  // Don't change point on empty transforms queue
  if (!this.queue.length) {
    return [x, y];
  }

  // Calculate final matrix, if not exists
  //
  // NB. if you deside to apply transforms to point one-by-one,
  // they should be taken in reverse order

  if (!this.cache) {
    this.cache = this.toArray();
  }

  m = this.cache;

  // Apply matrix to point
  return [x * m[0] + y * m[2] + (isRelative ? 0 : m[4]), x * m[1] + y * m[3] + (isRelative ? 0 : m[5])];
};

var matrix = Matrix;

var operations = {
  matrix: true,
  scale: true,
  rotate: true,
  translate: true,
  skewX: true,
  skewY: true
};

var CMD_SPLIT_RE = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
var PARAMS_SPLIT_RE = /[\s,]+/;

var transform_parse = function transformParse(transformString) {
  var matrix$$1 = new matrix();
  var cmd, params;

  // Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']
  transformString.split(CMD_SPLIT_RE).forEach(function (item) {

    // Skip empty elements
    if (!item.length) {
      return;
    }

    // remember operation
    if (typeof operations[item] !== 'undefined') {
      cmd = item;
      return;
    }

    // extract params & att operation to matrix
    params = item.split(PARAMS_SPLIT_RE).map(function (i) {
      return +i || 0;
    });

    // If params count is not correct - ignore command
    switch (cmd) {
      case 'matrix':
        if (params.length === 6) {
          matrix$$1.matrix(params);
        }
        return;

      case 'scale':
        if (params.length === 1) {
          matrix$$1.scale(params[0], params[0]);
        } else if (params.length === 2) {
          matrix$$1.scale(params[0], params[1]);
        }
        return;

      case 'rotate':
        if (params.length === 1) {
          matrix$$1.rotate(params[0], 0, 0);
        } else if (params.length === 3) {
          matrix$$1.rotate(params[0], params[1], params[2]);
        }
        return;

      case 'translate':
        if (params.length === 1) {
          matrix$$1.translate(params[0], 0);
        } else if (params.length === 2) {
          matrix$$1.translate(params[0], params[1]);
        }
        return;

      case 'skewX':
        if (params.length === 1) {
          matrix$$1.skewX(params[0]);
        }
        return;

      case 'skewY':
        if (params.length === 1) {
          matrix$$1.skewY(params[0]);
        }
        return;
    }
  });

  return matrix$$1;
};

// Convert an arc to a sequence of cubic bézier curves
//
var TAU = Math.PI * 2;

/* eslint-disable space-infix-ops */

// Calculate an angle between two vectors
//
function vector_angle(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var umag = Math.sqrt(ux * ux + uy * uy);
  var vmag = Math.sqrt(ux * ux + uy * uy);
  var dot = ux * vx + uy * vy;
  var div = dot / (umag * vmag);

  // rounding errors, e.g. -1.0000000000000002 can screw up this
  if (div > 1.0) {
    div = 1.0;
  }
  if (div < -1.0) {
    div = -1.0;
  }

  return sign * Math.acos(div);
}

// Convert from endpoint to center parameterization,
// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
//
// Return [cx, cy, theta1, delta_theta]
//
function get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {
  // Step 1.
  //
  // Moving an ellipse so origin will be the middlepoint between our two
  // points. After that, rotate it to line up ellipse axes with coordinate
  // axes.
  //
  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

  var rx_sq = rx * rx;
  var ry_sq = ry * ry;
  var x1p_sq = x1p * x1p;
  var y1p_sq = y1p * y1p;

  // Step 2.
  //
  // Compute coordinates of the centre of this ellipse (cx', cy')
  // in the new coordinate system.
  //
  var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;

  if (radicant < 0) {
    // due to rounding errors it might be e.g. -1.3877787807814457e-17
    radicant = 0;
  }

  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);

  var cxp = radicant * rx / ry * y1p;
  var cyp = radicant * -ry / rx * x1p;

  // Step 3.
  //
  // Transform back to get centre coordinates (cx, cy) in the original
  // coordinate system.
  //
  var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;
  var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;

  // Step 4.
  //
  // Compute angles (theta1, delta_theta).
  //
  var v1x = (x1p - cxp) / rx;
  var v1y = (y1p - cyp) / ry;
  var v2x = (-x1p - cxp) / rx;
  var v2y = (-y1p - cyp) / ry;

  var theta1 = vector_angle(1, 0, v1x, v1y);
  var delta_theta = vector_angle(v1x, v1y, v2x, v2y);

  if (fs === 0 && delta_theta > 0) {
    delta_theta -= TAU;
  }
  if (fs === 1 && delta_theta < 0) {
    delta_theta += TAU;
  }

  return [cx, cy, theta1, delta_theta];
}

//
// Approximate one unit arc segment with bézier curves,
// see http://math.stackexchange.com/questions/873224
//
function approximate_unit_arc(theta1, delta_theta) {
  var alpha = 4 / 3 * Math.tan(delta_theta / 4);

  var x1 = Math.cos(theta1);
  var y1 = Math.sin(theta1);
  var x2 = Math.cos(theta1 + delta_theta);
  var y2 = Math.sin(theta1 + delta_theta);

  return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];
}

var a2c = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {
  var sin_phi = Math.sin(phi * TAU / 360);
  var cos_phi = Math.cos(phi * TAU / 360);

  // Make sure radii are valid
  //
  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;
  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;

  if (x1p === 0 && y1p === 0) {
    // we're asked to draw line to itself
    return [];
  }

  if (rx === 0 || ry === 0) {
    // one of the radii is zero
    return [];
  }

  // Compensate out-of-range radii
  //
  rx = Math.abs(rx);
  ry = Math.abs(ry);

  var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  // Get center parameters (cx, cy, theta1, delta_theta)
  //
  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);

  var result = [];
  var theta1 = cc[2];
  var delta_theta = cc[3];

  // Split an arc to multiple segments, so each segment
  // will be less than τ/4 (= 90°)
  //
  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);
  delta_theta /= segments;

  for (var i = 0; i < segments; i++) {
    result.push(approximate_unit_arc(theta1, delta_theta));
    theta1 += delta_theta;
  }

  // We have a bezier approximation of a unit circle,
  // now need to transform back to the original ellipse
  //
  return result.map(function (curve) {
    for (var i = 0; i < curve.length; i += 2) {
      var x = curve[i + 0];
      var y = curve[i + 1];

      // scale
      x *= rx;
      y *= ry;

      // rotate
      var xp = cos_phi * x - sin_phi * y;
      var yp = sin_phi * x + cos_phi * y;

      // translate
      curve[i + 0] = xp + cc[0];
      curve[i + 1] = yp + cc[1];
    }

    return curve;
  });
};

/* eslint-disable space-infix-ops */

// The precision used to consider an ellipse as a circle
//

var epsilon$4 = 0.0000000001;

// To convert degree in radians
//
var torad = Math.PI / 180;

// Class constructor :
//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.
//
function Ellipse(rx, ry, ax) {
  if (!(this instanceof Ellipse)) {
    return new Ellipse(rx, ry, ax);
  }
  this.rx = rx;
  this.ry = ry;
  this.ax = ax;
}

// Apply a linear transform m to the ellipse
// m is an array representing a matrix :
//    -         -
//   | m[0] m[2] |
//   | m[1] m[3] |
//    -         -
//
Ellipse.prototype.transform = function (m) {
  // We consider the current ellipse as image of the unit circle
  // by first scale(rx,ry) and then rotate(ax) ...
  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.
  var c = Math.cos(this.ax * torad),
      s = Math.sin(this.ax * torad);
  var ma = [this.rx * (m[0] * c + m[2] * s), this.rx * (m[1] * c + m[3] * s), this.ry * (-m[0] * s + m[2] * c), this.ry * (-m[1] * s + m[3] * c)];

  // ma * transpose(ma) = [ J L ]
  //                      [ L K ]
  // L is calculated later (if the image is not a circle)
  var J = ma[0] * ma[0] + ma[2] * ma[2],
      K = ma[1] * ma[1] + ma[3] * ma[3];

  // the discriminant of the characteristic polynomial of ma * transpose(ma)
  var D = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1]));

  // the "mean eigenvalue"
  var JK = (J + K) / 2;

  // check if the image is (almost) a circle
  if (D < epsilon$4 * JK) {
    // if it is
    this.rx = this.ry = Math.sqrt(JK);
    this.ax = 0;
    return this;
  }

  // if it is not a circle
  var L = ma[0] * ma[1] + ma[2] * ma[3];

  D = Math.sqrt(D);

  // {l1,l2} = the two eigen values of ma * transpose(ma)
  var l1 = JK + D / 2,
      l2 = JK - D / 2;
  // the x - axis - rotation angle is the argument of the l1 - eigenvector
  this.ax = Math.abs(L) < epsilon$4 && Math.abs(l1 - K) < epsilon$4 ? 90 : Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) * 180 / Math.PI;

  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90
  if (this.ax >= 0) {
    // if ax in [0,90]
    this.rx = Math.sqrt(l1);
    this.ry = Math.sqrt(l2);
  } else {
    // if ax in ]-90,0[ => exchange axes
    this.ax += 90;
    this.rx = Math.sqrt(l2);
    this.ry = Math.sqrt(l1);
  }

  return this;
};

// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0
//
Ellipse.prototype.isDegenerate = function () {
  return this.rx < epsilon$4 * this.ry || this.ry < epsilon$4 * this.rx;
};

var ellipse = Ellipse;

// Class constructor
//
function SvgPath(path) {
  if (!(this instanceof SvgPath)) {
    return new SvgPath(path);
  }

  var pstate = path_parse(path);

  // Array of path segments.
  // Each segment is array [command, param1, param2, ...]
  this.segments = pstate.segments;

  // Error message on parse error.
  this.err = pstate.err;

  // Transforms stack for lazy evaluation
  this.__stack = [];
}

SvgPath.prototype.__matrix = function (m) {
  var self = this,
      i;

  // Quick leave for empty matrix
  if (!m.queue.length) {
    return;
  }

  this.iterate(function (s, index, x, y) {
    var p, result, name, isRelative;

    switch (s[0]) {

      // Process 'assymetric' commands separately
      case 'v':
        p = m.calc(0, s[1], true);
        result = p[0] === 0 ? ['v', p[1]] : ['l', p[0], p[1]];
        break;

      case 'V':
        p = m.calc(x, s[1], false);
        result = p[0] === m.calc(x, y, false)[0] ? ['V', p[1]] : ['L', p[0], p[1]];
        break;

      case 'h':
        p = m.calc(s[1], 0, true);
        result = p[1] === 0 ? ['h', p[0]] : ['l', p[0], p[1]];
        break;

      case 'H':
        p = m.calc(s[1], y, false);
        result = p[1] === m.calc(x, y, false)[1] ? ['H', p[0]] : ['L', p[0], p[1]];
        break;

      case 'a':
      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]

        // Drop segment if arc is empty (end point === start point)
        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||
            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {
          return [];
        }*/

        // Transform rx, ry and the x-axis-rotation
        var ma = m.toArray();
        var e = ellipse(s[1], s[2], s[3]).transform(ma);

        // flip sweep-flag if matrix is not orientation-preserving
        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {
          s[5] = s[5] ? '0' : '1';
        }

        // Transform end point as usual (without translation for relative notation)
        p = m.calc(s[6], s[7], s[0] === 'a');

        // Empty arcs can be ignored by renderer, but should not be dropped
        // to avoid collisions with `S A S` and so on. Replace with empty line.
        if (s[0] === 'A' && s[6] === x && s[7] === y || s[0] === 'a' && s[6] === 0 && s[7] === 0) {
          result = [s[0] === 'a' ? 'l' : 'L', p[0], p[1]];
          break;
        }

        // if the resulting ellipse is (almost) a segment ...
        if (e.isDegenerate()) {
          // replace the arc by a line
          result = [s[0] === 'a' ? 'l' : 'L', p[0], p[1]];
        } else {
          // if it is a real ellipse
          // s[0], s[4] and s[5] are not modified
          result = [s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1]];
        }

        break;

      case 'm':
        // Edge case. The very first `m` should be processed as absolute, if happens.
        // Make sense for coord shift transforms.
        isRelative = index > 0;

        p = m.calc(s[1], s[2], isRelative);
        result = ['m', p[0], p[1]];
        break;

      default:
        name = s[0];
        result = [name];
        isRelative = name.toLowerCase() === name;

        // Apply transformations to the segment
        for (i = 1; i < s.length; i += 2) {
          p = m.calc(s[i], s[i + 1], isRelative);
          result.push(p[0], p[1]);
        }
    }

    self.segments[index] = result;
  }, true);
};

// Apply stacked commands
//
SvgPath.prototype.__evaluateStack = function () {
  var m, i;

  if (!this.__stack.length) {
    return;
  }

  if (this.__stack.length === 1) {
    this.__matrix(this.__stack[0]);
    this.__stack = [];
    return;
  }

  m = matrix();
  i = this.__stack.length;

  while (--i >= 0) {
    m.matrix(this.__stack[i].toArray());
  }

  this.__matrix(m);
  this.__stack = [];
};

// Convert processed SVG Path back to string
//
SvgPath.prototype.toString = function () {
  var elements = [],
      skipCmd,
      cmd;

  this.__evaluateStack();

  for (var i = 0; i < this.segments.length; i++) {
    // remove repeating commands names
    cmd = this.segments[i][0];
    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this.segments[i - 1][0];
    elements = elements.concat(skipCmd ? this.segments[i].slice(1) : this.segments[i]);
  }

  return elements.join(' ')
  // Optimizations: remove spaces around commands & before `-`
  //
  // We could also remove leading zeros for `0.5`-like values,
  // but their count is too small to spend time for.
  .replace(/ ?([achlmqrstvz]) ?/gi, '$1').replace(/ \-/g, '-')
  // workaround for FontForge SVG importing bug
  .replace(/zm/g, 'z m');
};

// Translate path to (x [, y])
//
SvgPath.prototype.translate = function (x, y) {
  this.__stack.push(matrix().translate(x, y || 0));
  return this;
};

// Scale path to (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.scale = function (sx, sy) {
  this.__stack.push(matrix().scale(sx, !sy && sy !== 0 ? sx : sy));
  return this;
};

// Rotate path around point (sx [, sy])
// sy = sx if not defined
//
SvgPath.prototype.rotate = function (angle, rx, ry) {
  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));
  return this;
};

// Skew path along the X axis by `degrees` angle
//
SvgPath.prototype.skewX = function (degrees) {
  this.__stack.push(matrix().skewX(degrees));
  return this;
};

// Skew path along the Y axis by `degrees` angle
//
SvgPath.prototype.skewY = function (degrees) {
  this.__stack.push(matrix().skewY(degrees));
  return this;
};

// Apply matrix transform (array of 6 elements)
//
SvgPath.prototype.matrix = function (m) {
  this.__stack.push(matrix().matrix(m));
  return this;
};

// Transform path according to "transform" attr of SVG spec
//
SvgPath.prototype.transform = function (transformString) {
  if (!transformString.trim()) {
    return this;
  }
  this.__stack.push(transform_parse(transformString));
  return this;
};

// Round coords with given decimal precition.
// 0 by default (to integers)
//
SvgPath.prototype.round = function (d) {
  var contourStartDeltaX = 0,
      contourStartDeltaY = 0,
      deltaX = 0,
      deltaY = 0,
      l;

  d = d || 0;

  this.__evaluateStack();

  this.segments.forEach(function (s) {
    var isRelative = s[0].toLowerCase() === s[0];

    switch (s[0]) {
      case 'H':
      case 'h':
        if (isRelative) {
          s[1] += deltaX;
        }
        deltaX = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'V':
      case 'v':
        if (isRelative) {
          s[1] += deltaY;
        }
        deltaY = s[1] - s[1].toFixed(d);
        s[1] = +s[1].toFixed(d);
        return;

      case 'Z':
      case 'z':
        deltaX = contourStartDeltaX;
        deltaY = contourStartDeltaY;
        return;

      case 'M':
      case 'm':
        if (isRelative) {
          s[1] += deltaX;
          s[2] += deltaY;
        }

        deltaX = s[1] - s[1].toFixed(d);
        deltaY = s[2] - s[2].toFixed(d);

        contourStartDeltaX = deltaX;
        contourStartDeltaY = deltaY;

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        return;

      case 'A':
      case 'a':
        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        if (isRelative) {
          s[6] += deltaX;
          s[7] += deltaY;
        }

        deltaX = s[6] - s[6].toFixed(d);
        deltaY = s[7] - s[7].toFixed(d);

        s[1] = +s[1].toFixed(d);
        s[2] = +s[2].toFixed(d);
        s[3] = +s[3].toFixed(d + 2); // better precision for rotation
        s[6] = +s[6].toFixed(d);
        s[7] = +s[7].toFixed(d);
        return;

      default:
        // a c l q s t
        l = s.length;

        if (isRelative) {
          s[l - 2] += deltaX;
          s[l - 1] += deltaY;
        }

        deltaX = s[l - 2] - s[l - 2].toFixed(d);
        deltaY = s[l - 1] - s[l - 1].toFixed(d);

        s.forEach(function (val, i) {
          if (!i) {
            return;
          }
          s[i] = +s[i].toFixed(d);
        });
        return;
    }
  });

  return this;
};

// Apply iterator function to all segments. If function returns result,
// current segment will be replaced to array of returned segments.
// If empty array is returned, current regment will be deleted.
//
SvgPath.prototype.iterate = function (iterator, keepLazyStack) {
  var segments = this.segments,
      replacements = {},
      needReplace = false,
      lastX = 0,
      lastY = 0,
      countourStartX = 0,
      countourStartY = 0;
  var i, j, newSegments;

  if (!keepLazyStack) {
    this.__evaluateStack();
  }

  segments.forEach(function (s, index) {

    var res = iterator(s, index, lastX, lastY);

    if (Array.isArray(res)) {
      replacements[index] = res;
      needReplace = true;
    }

    var isRelative = s[0] === s[0].toLowerCase();

    // calculate absolute X and Y
    switch (s[0]) {
      case 'm':
      case 'M':
        lastX = s[1] + (isRelative ? lastX : 0);
        lastY = s[2] + (isRelative ? lastY : 0);
        countourStartX = lastX;
        countourStartY = lastY;
        return;

      case 'h':
      case 'H':
        lastX = s[1] + (isRelative ? lastX : 0);
        return;

      case 'v':
      case 'V':
        lastY = s[1] + (isRelative ? lastY : 0);
        return;

      case 'z':
      case 'Z':
        // That make sence for multiple contours
        lastX = countourStartX;
        lastY = countourStartY;
        return;

      default:
        lastX = s[s.length - 2] + (isRelative ? lastX : 0);
        lastY = s[s.length - 1] + (isRelative ? lastY : 0);
    }
  });

  // Replace segments if iterator return results

  if (!needReplace) {
    return this;
  }

  newSegments = [];

  for (i = 0; i < segments.length; i++) {
    if (typeof replacements[i] !== 'undefined') {
      for (j = 0; j < replacements[i].length; j++) {
        newSegments.push(replacements[i][j]);
      }
    } else {
      newSegments.push(segments[i]);
    }
  }

  this.segments = newSegments;

  return this;
};

// Converts segments from relative to absolute
//
SvgPath.prototype.abs = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameUC = name.toUpperCase(),
        i;

    // Skip absolute commands
    if (name === nameUC) {
      return;
    }

    s[0] = nameUC;

    switch (name) {
      case 'v':
        // v has shifted coords parity
        s[1] += y;
        return;

      case 'a':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] += x;
        s[7] += y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] += i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};

// Converts segments from absolute to relative
//
SvgPath.prototype.rel = function () {

  this.iterate(function (s, index, x, y) {
    var name = s[0],
        nameLC = name.toLowerCase(),
        i;

    // Skip relative commands
    if (name === nameLC) {
      return;
    }

    // Don't touch the first M to avoid potential confusions.
    if (index === 0 && name === 'M') {
      return;
    }

    s[0] = nameLC;

    switch (name) {
      case 'V':
        // V has shifted coords parity
        s[1] -= y;
        return;

      case 'A':
        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
        // touch x, y only
        s[6] -= x;
        s[7] -= y;
        return;

      default:
        for (i = 1; i < s.length; i++) {
          s[i] -= i % 2 ? x : y; // odd values are X, even - Y
        }
    }
  }, true);

  return this;
};

// Converts arcs to cubic bézier curves
//
SvgPath.prototype.unarc = function () {
  this.iterate(function (s, index, x, y) {
    var new_segments,
        nextX,
        nextY,
        result = [],
        name = s[0];

    // Skip anything except arcs
    if (name !== 'A' && name !== 'a') {
      return null;
    }

    if (name === 'a') {
      // convert relative arc coordinates to absolute
      nextX = x + s[6];
      nextY = y + s[7];
    } else {
      nextX = s[6];
      nextY = s[7];
    }

    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);

    // Degenerated arcs can be ignored by renderer, but should not be dropped
    // to avoid collisions with `S A S` and so on. Replace with empty line.
    if (new_segments.length === 0) {
      return [[s[0] === 'a' ? 'l' : 'L', s[6], s[7]]];
    }

    new_segments.forEach(function (s) {
      result.push(['C', s[2], s[3], s[4], s[5], s[6], s[7]]);
    });

    return result;
  });

  return this;
};

// Converts smooth curves (with missed control point) to generic curves
//
SvgPath.prototype.unshort = function () {
  var segments = this.segments;
  var prevControlX, prevControlY, prevSegment;
  var curControlX, curControlY;

  // TODO: add lazy evaluation flag when relative commands supported

  this.iterate(function (s, idx, x, y) {
    var name = s[0],
        nameUC = name.toUpperCase(),
        isRelative;

    // First command MUST be M|m, it's safe to skip.
    // Protect from access to [-1] for sure.
    if (!idx) {
      return;
    }

    if (nameUC === 'T') {
      // quadratic curve
      isRelative = name === 't';

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'Q') {
        prevControlX = prevSegment[1] - x;
        prevControlY = prevSegment[2] - y;
      } else if (prevSegment[0] === 'q') {
        prevControlX = prevSegment[1] - prevSegment[3];
        prevControlY = prevSegment[2] - prevSegment[4];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [isRelative ? 'q' : 'Q', curControlX, curControlY, s[1], s[2]];
    } else if (nameUC === 'S') {
      // cubic curve
      isRelative = name === 's';

      prevSegment = segments[idx - 1];

      if (prevSegment[0] === 'C') {
        prevControlX = prevSegment[3] - x;
        prevControlY = prevSegment[4] - y;
      } else if (prevSegment[0] === 'c') {
        prevControlX = prevSegment[3] - prevSegment[5];
        prevControlY = prevSegment[4] - prevSegment[6];
      } else {
        prevControlX = 0;
        prevControlY = 0;
      }

      curControlX = -prevControlX;
      curControlY = -prevControlY;

      if (!isRelative) {
        curControlX += x;
        curControlY += y;
      }

      segments[idx] = [isRelative ? 'c' : 'C', curControlX, curControlY, s[1], s[2], s[3], s[4]];
    }
  });

  return this;
};

var svgpath$2 = SvgPath;

var svgpath = svgpath$2;

var Path_1 = Path$1;

function Path$1(d) {
  this.d = d;
}

Path$1.prototype = {

  getBoundingBox: function getBoundingBox() {
    var pathDriver, boundingBox;

    pathDriver = new svgpath(this.d);
    boundingBox = new BoundingBox_1();

    pathDriver.abs().unarc().unshort().iterate(function (seg, index, x, y) {

      switch (seg[0]) {
        case 'M':
        case 'L':
          boundingBox.addPoint(seg[1], seg[2]);
          break;
        case 'H':
          boundingBox.addX(seg[1]);
          break;
        case 'V':
          boundingBox.addY(seg[1]);
          break;
        case 'Q':
          boundingBox.addQuadraticCurve(x, y, seg[1], seg[2], seg[3], seg[4]);
          break;
        case 'C':
          boundingBox.addBezierCurve(x, y, seg[1], seg[2], seg[3], seg[4], seg[5], seg[6]);
          break;
      }
    });

    return new BoundingBoxView_1(boundingBox);
  }

};

var caster_1 = caster;

function caster(path) {
  return new Path_1(path).getBoundingBox();
}

caster.Path = Path_1;

var svgPathBoundingBox = caster_1;

var twoPI$2 = Math.PI * 2;

var iconBarCustomMark = function iconBarCustomMark(_ref) {
  var type = _ref.type,
      projection = _ref.projection,
      finalHeight = _ref.finalHeight,
      finalWidth = _ref.finalWidth,
      styleFn = _ref.styleFn,
      renderValue = _ref.renderValue,
      classFn = _ref.classFn;
  return function (piece, i, xy) {
    var iconD = typeof type.icon === "string" ? type.icon : type.icon(piece.data, i);
    var _type$iconPadding = type.iconPadding,
        iconPadding = _type$iconPadding === undefined ? 1 : _type$iconPadding,
        _type$resize = type.resize,
        resize = _type$resize === undefined ? "auto" : _type$resize;


    var iconBounds = svgPathBoundingBox(iconD);
    var iconTranslate = [0 - iconBounds.x1 + iconPadding, 0 - iconBounds.y1 + iconPadding];
    iconBounds.height += iconPadding * 2;
    iconBounds.width += iconPadding * 2;

    var icons = [];

    var stackedIconSize = iconBounds.height;
    var stackedIconNumber = 1;
    var iconScale = 1;
    var spaceToUse = projection === "horizontal" ? finalHeight : finalWidth;
    var sizeToFit = projection === "horizontal" ? iconBounds.height : iconBounds.width;
    var sizeToPad = projection === "horizontal" ? iconBounds.width : iconBounds.height;
    var spaceToFill = projection === "horizontal" ? xy.width : xy.height;
    var spaceToStackFill = projection === "horizontal" ? xy.height : xy.width;
    if (resize === "auto") {
      stackedIconSize = spaceToUse / sizeToFit;
      if (stackedIconSize < 1) {
        iconScale = stackedIconSize;
      } else {
        stackedIconNumber = Math.floor(stackedIconSize);
        iconScale = 1 + (stackedIconSize - stackedIconNumber) / stackedIconNumber;
      }
    } else if (resize === "fixed") {
      iconScale = spaceToUse / sizeToFit;
    }

    //  const finalIconWidth = iconBounds.width * iconScale;
    var finalIconHeight = iconBounds.height * iconScale;

    var spaceToStep = sizeToPad * iconScale;
    var spaceToStackStep = sizeToFit * iconScale;

    iconTranslate[0] = iconTranslate[0] * iconScale;
    iconTranslate[1] = iconTranslate[1] * iconScale;

    var randoClipID = "iso-clip-" + i + "-" + Math.random();
    var clipPath = "url(#" + randoClipID + ")";
    if (xy.width > 0) {
      icons.push(React.createElement(
        "clipPath",
        { key: randoClipID, id: randoClipID },
        React.createElement("rect", { x: 0, y: 0, width: xy.width, height: xy.height })
      ));
      var iconPieces = [];
      var stepStart = projection === "horizontal" ? 0 : xy.height - finalIconHeight;
      var stepper = projection === "horizontal" ? spaceToStep : -spaceToStep;
      var stepTest = projection === "horizontal" ? function (step, spaceToFillValue) {
        return step < spaceToFillValue;
      } : function (step, spaceToFillValue, stepperValue) {
        return step > 0 + stepperValue;
      };

      for (var step = stepStart; stepTest(step, spaceToFill, stepper); step += stepper) {
        for (var stack = 0; stack < spaceToStackFill; stack += spaceToStackStep) {
          var stepX = projection === "horizontal" ? step : stack;
          var stepY = projection === "horizontal" ? stack : step;
          var paddedX = stepX + iconTranslate[0];
          var paddedY = stepY + iconTranslate[1];
          iconPieces.push(React.createElement(lib_2$1, {
            forceUpdate: true,
            markType: "path",
            key: "icon-" + step + "-" + stack,
            transform: "translate(" + paddedX + "," + paddedY + ") scale(" + iconScale + ")",
            vectorEffect: "non-scaling-stroke",
            d: iconD,
            style: styleFn(piece.data, i),
            renderMode: renderValue,
            className: classFn(piece.data, i)
          }));
        }
      }
      icons.push(React.createElement(
        "g",
        { key: "clipped-region-" + i, clipPath: clipPath },
        iconPieces
      ));
    }
    return icons;
  };
};

function pointOnArcAtAngle$1(center, angle, distance) {
  var radians = Math.PI * (angle + 0.75) * 2;

  var xPosition = center[0] + distance * Math.cos(radians);
  var yPosition = center[1] + distance * Math.sin(radians);

  return [xPosition, yPosition];
}

function clusterBarLayout(_ref2) {
  var type = _ref2.type,
      data = _ref2.data,
      renderMode = _ref2.renderMode,
      eventListenersGenerator = _ref2.eventListenersGenerator,
      styleFn = _ref2.styleFn,
      projection = _ref2.projection,
      classFn = _ref2.classFn,
      adjustedSize = _ref2.adjustedSize;

  var allCalculatedPieces = [];
  var keys = Object.keys(data);
  keys.forEach(function (key, ordsetI) {
    var ordset = data[key];

    var barColumnWidth = ordset.width;
    var clusterWidth = barColumnWidth / ordset.pieceData.length;

    var currentX = 0;
    var currentY = 0;

    var calculatedPieces = ordset.pieceData.map(function (piece, i) {
      var renderValue = renderMode && renderMode(piece.data, i);

      var xPosition = piece.x;
      var yPosition = piece.base;
      var finalWidth = clusterWidth;
      var finalHeight = piece.scaledValue;
      var xy = {};
      if (!piece.negative) {
        yPosition -= piece.scaledValue;
      }

      if (projection === "horizontal") {
        //TODO: NEGATIVE FOR HORIZONTAL
        yPosition = piece.x;
        xPosition = piece.base;
        finalHeight = clusterWidth;
        finalWidth = piece.scaledValue;
        if (piece.negative) {
          xPosition -= piece.scaledValue;
        }
      }

      var markD = void 0,
          translate = void 0,
          markProps = {};

      if (projection === "radial") {
        var arcGenerator = arc().innerRadius(0).outerRadius(piece.scaledValue / 2);

        var angle = (ordset.pct - ordset.pct_padding) / ordset.pieceData.length;
        var startAngle = ordset.pct_start + i / ordset.pieceData.length * (ordset.pct - ordset.pct_padding);
        var endAngle = startAngle + angle;

        markD = arcGenerator({
          startAngle: startAngle * twoPI$2,
          endAngle: endAngle * twoPI$2
        });
        var xOffset = adjustedSize[0] / 2;
        var yOffset = adjustedSize[1] / 2;
        translate = "translate(" + xOffset + "," + yOffset + ")";

        var startAngleFinal = startAngle * twoPI$2;
        var endAngleFinal = endAngle * twoPI$2;
        var outerPoint = pointOnArcAtAngle$1([0, 0], (startAngle + endAngle) / 2, piece.scaledValue / 2);

        xy.arcGenerator = arcGenerator;
        xy.startAngle = startAngleFinal;
        xy.endAngle = endAngleFinal;
        xy.dx = outerPoint[0];
        xy.dy = outerPoint[1];

        var centroid = arcGenerator.centroid({
          startAngle: startAngleFinal,
          endAngle: endAngleFinal
        });
        finalHeight = undefined;
        finalWidth = undefined;
        xPosition = centroid[0] + xOffset;
        yPosition = centroid[1] + yOffset;

        markProps = {
          markType: "path",
          d: markD,
          tx: xOffset,
          ty: yOffset
        };
      } else {
        xPosition += currentX;
        yPosition += currentY;
        markProps = {
          markType: "rect",
          x: xPosition,
          y: yPosition,
          width: finalWidth,
          height: finalHeight,
          rx: 0,
          ry: 0
        };
      }

      var eventListeners = eventListenersGenerator(piece, i);

      xy.x = xPosition;
      xy.y = yPosition;
      xy.middle = clusterWidth / 2;
      xy.height = finalHeight;
      xy.width = finalWidth;

      if (type.icon && projection !== "radial") {
        type.customMark = iconBarCustomMark({
          type: type,
          projection: projection,
          finalHeight: finalHeight,
          finalWidth: finalWidth,
          styleFn: styleFn,
          renderValue: renderValue,
          classFn: classFn
        });
      } else if (type.icon && projection === "radial") {
        console.error("Icons are currently unsupported on radial charts");
      }

      var renderElementObject = type.customMark ? React.createElement(
        "g",
        {
          key: "piece-" + piece.renderKey,
          transform: translate ? translate : "translate(" + xPosition + "," + yPosition + ")"
        },
        type.customMark(_extends({}, piece.data, piece), i, xy)
      ) : _extends({
        className: classFn(piece.data, i),
        renderMode: renderValue,
        key: "piece-" + piece.renderKey,
        transform: translate,
        style: styleFn(piece.data, ordsetI)
      }, markProps, eventListeners);

      var calculatedPiece = {
        o: key,
        xy: xy,
        piece: piece,
        renderElement: renderElementObject
      };
      if (projection === "horizontal") {
        currentY += finalHeight;
      } else {
        currentX += finalWidth;
      }

      //        currentOffset += pieceSize
      return calculatedPiece;
    });
    allCalculatedPieces = [].concat(toConsumableArray(allCalculatedPieces), toConsumableArray(calculatedPieces));
  });
  return allCalculatedPieces;
}

function barLayout(_ref3) {
  var type = _ref3.type,
      data = _ref3.data,
      renderMode = _ref3.renderMode,
      eventListenersGenerator = _ref3.eventListenersGenerator,
      styleFn = _ref3.styleFn,
      projection = _ref3.projection,
      classFn = _ref3.classFn,
      adjustedSize = _ref3.adjustedSize;

  var keys = Object.keys(data);
  var allCalculatedPieces = [];
  keys.forEach(function (key, ordsetI) {
    var ordset = data[key];
    var barColumnWidth = ordset.width;

    var calculatedPieces = ordset.pieceData.map(function (piece, i) {
      var pieceSize = piece.scaledValue;
      var renderValue = renderMode && renderMode(piece.data, i);

      var xPosition = piece.x;
      var yPosition = piece.bottom;
      var finalWidth = barColumnWidth;
      var finalHeight = pieceSize;

      if (!piece.negative) {
        yPosition -= piece.scaledValue;
      }

      if (projection === "horizontal") {
        yPosition = piece.x;
        xPosition = piece.bottom;
        finalHeight = barColumnWidth;
        finalWidth = pieceSize;
        if (piece.negative) {
          xPosition = piece.bottom - piece.scaledValue;
        }
      }

      var markD = void 0,
          markProps = void 0;

      if (projection === "radial") {
        var innerRadius = type.innerRadius;

        var innerSize = piece.bottom / 2;
        var outerSize = piece.scaledValue / 2 + piece.bottom / 2;
        if (innerRadius) {
          innerRadius = parseInt(innerRadius, 10);
          var canvasRadius = adjustedSize[0] / 2;
          var donutMod = (canvasRadius - innerRadius) / canvasRadius;
          innerSize = innerSize * donutMod + innerRadius;
          outerSize = outerSize * donutMod + innerRadius;
        }

        var arcGenerator = arc().innerRadius(innerSize).outerRadius(outerSize);
        //          .padAngle(ordset.pct_padding * twoPI);

        var angle = ordset.pct;
        var startAngle = ordset.pct === 1 ? 0 : ordset.pct_start;
        var endAngle = ordset.pct === 1 ? 1 : Math.max(startAngle, startAngle + angle - ordset.pct_padding / 2);

        markD = arcGenerator({
          startAngle: startAngle * twoPI$2,
          endAngle: endAngle * twoPI$2
        });
        var centroid = arcGenerator.centroid({
          startAngle: startAngle * twoPI$2,
          endAngle: endAngle * twoPI$2
        });
        finalHeight = undefined;
        finalWidth = undefined;
        var xOffset = adjustedSize[0] / 2;
        var yOffset = adjustedSize[1] / 2;
        xPosition = centroid[0] + xOffset;
        yPosition = centroid[1] + yOffset;

        markProps = {
          markType: "path",
          d: markD,
          tx: xOffset,
          ty: yOffset,
          transform: "translate(" + xOffset + "," + yOffset + ")"
        };
      } else {
        markProps = {
          markType: "rect",
          x: xPosition,
          y: yPosition,
          width: finalWidth,
          height: finalHeight,
          rx: 0,
          ry: 0
        };
      }

      var eventListeners = eventListenersGenerator(piece, i);
      var xy = {
        x: xPosition,
        y: yPosition,
        middle: barColumnWidth / 2,
        height: finalHeight,
        width: finalWidth
      };

      if (type.icon && projection !== "radial") {
        type.customMark = iconBarCustomMark({
          type: type,
          projection: projection,
          finalHeight: finalHeight,
          finalWidth: finalWidth,
          styleFn: styleFn,
          renderValue: renderValue,
          classFn: classFn
        });
      } else if (type.icon && projection !== "horizontal") {
        console.error("Icons are currently unsupported in radial charts");
      }

      var renderElementObject = type.customMark ? React.createElement(
        "g",
        {
          key: "piece-" + piece.renderKey,
          transform: "translate(" + xPosition + "," + yPosition + ")"
        },
        type.customMark(_extends({}, piece.data, piece), i, xy)
      ) : _extends({
        className: classFn(piece.data, i),
        renderMode: renderValue,
        key: "piece-" + piece.renderKey,
        style: styleFn(piece.data, ordsetI)
      }, eventListeners, markProps);

      var calculatedPiece = {
        o: key,
        xy: xy,
        piece: piece,
        renderElement: renderElementObject
      };
      return calculatedPiece;
    });
    allCalculatedPieces = [].concat(toConsumableArray(allCalculatedPieces), toConsumableArray(calculatedPieces));
  });

  return allCalculatedPieces;
}

function timelineLayout(_ref4) {
  var type = _ref4.type,
      data = _ref4.data,
      renderMode = _ref4.renderMode,
      eventListenersGenerator = _ref4.eventListenersGenerator,
      styleFn = _ref4.styleFn,
      projection = _ref4.projection,
      classFn = _ref4.classFn,
      adjustedSize = _ref4.adjustedSize;

  var allCalculatedPieces = [];
  var keys = Object.keys(data);
  keys.forEach(function (key, ordsetI) {
    var ordset = data[key];
    var calculatedPieces = [];

    ordset.pieceData.forEach(function (piece, i) {
      var renderValue = renderMode && renderMode(piece.data, i);
      var xPosition = ordset.x;
      var height = piece.scaledEndValue - piece.scaledValue;
      var yPosition = piece.scaledVerticalValue - height;
      var width = ordset.width;
      var markProps = {
        markType: "rect",
        height: height < 0 ? -height : height,
        width: width,
        x: xPosition,
        y: height < 0 ? yPosition + height : yPosition
      };

      if (projection === "horizontal") {
        yPosition = ordset.x;
        xPosition = piece.scaledValue;
        width = piece.scaledEndValue - piece.scaledValue;
        height = ordset.width;
        markProps = {
          markType: "rect",
          height: height,
          width: width < 0 ? -width : width,
          x: width < 0 ? xPosition + width : xPosition,
          y: yPosition
        };
      } else if (projection === "radial") {
        var innerRadius = type.innerRadius;

        var innerSize = piece.scaledValue / 2;
        var outerSize = piece.scaledEndValue / 2;
        if (innerRadius) {
          innerRadius = parseInt(innerRadius, 10);
          var canvasRadius = adjustedSize[0] / 2;
          var donutMod = (canvasRadius - innerRadius) / canvasRadius;
          innerSize = innerSize * donutMod + innerRadius;
          outerSize = outerSize * donutMod + innerRadius;
        }

        var arcGenerator = arc().innerRadius(innerSize).outerRadius(outerSize);
        //          .padAngle(ordset.pct_padding * twoPI);

        var angle = ordset.pct;
        var startAngle = ordset.pct === 1 ? 0 : ordset.pct_start;
        var endAngle = ordset.pct === 1 ? 1 : Math.max(startAngle, startAngle + angle - ordset.pct_padding / 2);

        var markD = arcGenerator({
          startAngle: startAngle * twoPI$2,
          endAngle: endAngle * twoPI$2
        });

        var xOffset = adjustedSize[0] / 2;
        var yOffset = adjustedSize[1] / 2;
        markProps = {
          markType: "path",
          d: markD,
          transform: "translate(" + xOffset + "," + yOffset + ")",
          tx: xOffset,
          ty: yOffset
        };
      }

      //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type

      var eventListeners = eventListenersGenerator(piece, i);
      var xy = {
        x: xPosition,
        y: yPosition,
        height: height
      };

      var renderElementObject = type.customMark ? React.createElement(
        "g",
        {
          key: "piece-" + piece.renderKey,
          transform: "translate(" + xPosition + "," + (yPosition + height) + ")"
        },
        type.customMark(_extends({}, piece.data, piece), i, xy)
      ) : _extends({
        className: classFn(piece.data, i),
        renderMode: renderValue,
        key: "piece-" + piece.renderKey,
        style: styleFn(piece.data, ordsetI)
      }, markProps, eventListeners);

      var calculatedPiece = {
        o: key,
        xy: xy,
        piece: piece,
        renderElement: renderElementObject
      };

      calculatedPieces.push(calculatedPiece);
    });
    allCalculatedPieces = [].concat(toConsumableArray(allCalculatedPieces), calculatedPieces);
  });

  return allCalculatedPieces;
}

function pointLayout(_ref5) {
  var type = _ref5.type,
      data = _ref5.data,
      renderMode = _ref5.renderMode,
      eventListenersGenerator = _ref5.eventListenersGenerator,
      styleFn = _ref5.styleFn,
      projection = _ref5.projection,
      classFn = _ref5.classFn,
      adjustedSize = _ref5.adjustedSize;

  var circleRadius = type.r || 3;
  var allCalculatedPieces = [];
  var keys = Object.keys(data);
  keys.forEach(function (key, ordsetI) {
    var ordset = data[key];

    var calculatedPieces = [];

    ordset.pieceData.forEach(function (piece, i) {
      var renderValue = renderMode && renderMode(piece.data, i);

      var xPosition = ordset.middle;
      var yPosition = piece.scaledVerticalValue;

      if (projection === "horizontal") {
        yPosition = ordset.middle;
        xPosition = piece.scaledValue;
      } else if (projection === "radial") {
        var angle = ordset.pct_middle;

        var rPosition = piece.scaledValue / 2;
        var baseCentroid = pointOnArcAtAngle$1([adjustedSize[0] / 2, adjustedSize[1] / 2], angle, rPosition);
        xPosition = baseCentroid[0];
        yPosition = baseCentroid[1];
      }

      //Only return the actual piece if you're rendering points, otherwise you just needed to iterate and calculate the points for the contour summary type
      var actualCircleRadius = typeof circleRadius === "function" ? circleRadius(piece, i) : circleRadius;
      var eventListeners = eventListenersGenerator(piece, i);

      var renderElementObject = type.customMark ? React.createElement(
        "g",
        {
          key: "piece-" + piece.renderKey,
          transform: "translate(" + xPosition + "," + yPosition + ")"
        },
        type.customMark(_extends({}, piece.data, piece), i)
      ) : _extends({
        className: classFn(piece.data, i),
        markType: "rect",
        renderMode: renderValue,
        key: "piece-" + piece.renderKey,
        height: actualCircleRadius * 2,
        width: actualCircleRadius * 2,
        x: xPosition - actualCircleRadius,
        y: yPosition - actualCircleRadius,
        rx: actualCircleRadius,
        ry: actualCircleRadius,
        style: styleFn(piece.data, ordsetI)
      }, eventListeners);

      var calculatedPiece = {
        o: key,
        xy: {
          x: xPosition,
          y: yPosition
        },
        piece: piece,
        renderElement: renderElementObject
      };

      calculatedPieces.push(calculatedPiece);
    });
    allCalculatedPieces = [].concat(toConsumableArray(allCalculatedPieces), calculatedPieces);
  });

  return allCalculatedPieces;
}

function swarmLayout(_ref6) {
  var type = _ref6.type,
      data = _ref6.data,
      renderMode = _ref6.renderMode,
      eventListenersGenerator = _ref6.eventListenersGenerator,
      styleFn = _ref6.styleFn,
      projection = _ref6.projection,
      classFn = _ref6.classFn,
      adjustedSize = _ref6.adjustedSize;

  var allCalculatedPieces = [];
  var iterations = type.iterations || 120;

  var columnKeys = Object.keys(data);

  columnKeys.forEach(function (key, ordsetI) {
    var oColumn = data[key];
    var anglePiece = 1 / columnKeys.length;
    var oData = oColumn.pieceData;
    var adjustedColumnWidth = oColumn.width;

    var circleRadius = type.r || Math.max(2, Math.min(5, 4 * adjustedColumnWidth / oData.length));

    var simulation = _default(oData).force("y", forceY(function (d) {
      return d.scaledValue;
    }).strength(type.strength || 2)).force("x", forceX(oColumn.middle)).force("collide", forceCollide(circleRadius)).stop();

    if (projection === "vertical") {
      simulation.force("y", forceY(function (d) {
        return d.scaledVerticalValue;
      }).strength(type.strength || 2));
    }

    for (var i = 0; i < iterations; ++i) {
      simulation.tick();
    }var calculatedPieces = oData.map(function (piece, i) {
      var renderValue = renderMode && renderMode(piece.data, i);

      var xPosition = piece.x;
      var yPosition = piece.y;

      if (projection === "horizontal") {
        yPosition = piece.x;
        xPosition = piece.y;
      } else if (projection === "radial") {
        var angle = oColumn.pct_middle;
        xPosition = (piece.x - oColumn.middle) / adjustedColumnWidth * anglePiece;
        var rPosition = piece.scaledValue / 2;
        var xAngle = angle + xPosition;
        var baseCentroid = pointOnArcAtAngle$1([adjustedSize[0] / 2, adjustedSize[1] / 2], xAngle, rPosition);
        xPosition = baseCentroid[0];
        yPosition = baseCentroid[1];
      }

      var actualCircleRadius = typeof circleRadius === "function" ? circleRadius(piece, i) : circleRadius;

      var eventListeners = eventListenersGenerator(piece, i);

      var renderElementObject = type.customMark ? React.createElement(
        "g",
        {
          key: "piece-" + piece.renderKey,
          transform: "translate(" + xPosition + "," + yPosition + ")"
        },
        type.customMark(_extends({}, piece.data, piece), i)
      ) : _extends({
        className: classFn(piece.data, i),
        markType: "rect",
        renderMode: renderValue,
        key: "piece-" + piece.renderKey,
        height: actualCircleRadius * 2,
        width: actualCircleRadius * 2,
        x: xPosition - actualCircleRadius,
        y: yPosition - actualCircleRadius,
        rx: actualCircleRadius,
        ry: actualCircleRadius,
        style: styleFn(piece.data, ordsetI)
      }, eventListeners);

      var calculatedPiece = {
        o: key,
        xy: {
          x: xPosition,
          y: yPosition
        },
        piece: piece,
        renderElement: renderElementObject
      };

      return calculatedPiece;
    });
    allCalculatedPieces = [].concat(toConsumableArray(allCalculatedPieces), toConsumableArray(calculatedPieces));
  });

  return allCalculatedPieces;
}

var xScale = identity$4();
var yScale = identity$4();

var midMod = function midMod(d) {
  return d.middle ? d.middle : 0;
};
var zeroFunction = function zeroFunction() {
  return 0;
};
var twoPI$1 = Math.PI * 2;

var projectedCoordinatesObject = { y: "y", x: "x" };

var defaultOverflow = { top: 0, bottom: 0, left: 0, right: 0 };

var layoutHash = {
  clusterbar: clusterBarLayout,
  bar: barLayout,
  point: pointLayout,
  swarm: swarmLayout,
  timeline: timelineLayout
};

var OrdinalFrame = function (_React$Component) {
  inherits(OrdinalFrame, _React$Component);

  function OrdinalFrame(props) {
    classCallCheck(this, OrdinalFrame);

    var _this = possibleConstructorReturn(this, (OrdinalFrame.__proto__ || Object.getPrototypeOf(OrdinalFrame)).call(this, props));

    _this.calculateOrdinalFrame = _this.calculateOrdinalFrame.bind(_this);
    _this.defaultORHTMLRule = _this.defaultORHTMLRule.bind(_this);
    _this.defaultORSVGRule = _this.defaultORSVGRule.bind(_this);

    _this.renderBody = _this.renderBody.bind(_this);

    _this.state = {
      adjustedPosition: null,
      adjustedSize: null,
      backgroundGraphics: null,
      foregroundGraphics: null,
      axisData: null,
      axis: null,
      renderNumber: 0,
      oLabels: []
    };

    _this.oAccessor = null;
    _this.rAccessor = null;
    _this.oScale = null;
    _this.rScale = null;
    return _this;
  }

  createClass(OrdinalFrame, [{
    key: "calculateOrdinalFrame",
    value: function calculateOrdinalFrame(currentProps) {
      var oLabels = void 0;
      var projectedColumns = {};

      var padding = currentProps.oPadding ? currentProps.oPadding : 0;

      var summaryType = objectifyType(currentProps.summaryType);
      var pieceType = objectifyType(currentProps.type);
      var connectorType = objectifyType(currentProps.connectorType);

      var projection = currentProps.projection,
          customHoverBehavior = currentProps.customHoverBehavior,
          customClickBehavior = currentProps.customClickBehavior,
          size = currentProps.size,
          pixelColumnWidth = currentProps.pixelColumnWidth;

      var eventListenersGenerator = generateOrdinalFrameEventListeners(customHoverBehavior, customClickBehavior);

      var oAccessor = stringToFn(currentProps.oAccessor, function (d) {
        return d.renderKey;
      });
      var rAccessor = stringToFn(currentProps.rAccessor, function (d) {
        return d.value || 1;
      });

      var connectorStyle = stringToFn(currentProps.connectorStyle, function () {
        return {};
      }, true);
      var summaryStyle = stringToFn(currentProps.summaryStyle, function () {
        return {};
      }, true);
      var pieceStyle = stringToFn(currentProps.style, function () {
        return {};
      }, true);
      var pieceClass = stringToFn(currentProps.pieceClass, function () {
        return "";
      }, true);
      var summaryClass = stringToFn(currentProps.summaryClass, function () {
        return "";
      }, true);
      var summaryPosition = currentProps.summaryPosition || function (position) {
        return position;
      };

      var barData = keyAndObjectifyBarData(currentProps);

      var allData = barData.map(function (d) {
        return d.data;
      });

      //      const dataAccessor = currentProps.dataAccessor || function (d) {return d}
      var margin = calculateMargin(currentProps);

      var _adjustedPositionSize = adjustedPositionSize(currentProps),
          adjustedPosition = _adjustedPositionSize.adjustedPosition,
          adjustedSize = _adjustedPositionSize.adjustedSize;

      var title = generateFrameTitle(currentProps);

      var baseOExtent = currentProps.oExtent;
      var oExtentSettings = baseOExtent === undefined || Array.isArray(baseOExtent) ? { extent: baseOExtent } : baseOExtent;

      var calculatedOExtent = [].concat(toConsumableArray(new Set(allData.map(function (d, i) {
        return oAccessor(d, i);
      }))));

      var oExtent = oExtentSettings.extent || calculatedOExtent;

      if (pixelColumnWidth) {
        if (projection === "radial") {
          console.error("pixelColumnWidth is not honored in radial mode");
        } else if (projection === "vertical") {
          var sizeOffset = size[0] - adjustedSize[0];
          adjustedSize[0] = oExtent.length * pixelColumnWidth;
          size[0] = adjustedSize[0] + sizeOffset;
        } else {
          var _sizeOffset = size[1] - adjustedSize[1];
          adjustedSize[1] = oExtent.length * pixelColumnWidth;
          size[1] = adjustedSize[1] + _sizeOffset;
        }
      }

      var baseRExtent = currentProps.rExtent;
      var rExtentSettings = baseRExtent === undefined || Array.isArray(baseRExtent) ? { extent: baseRExtent } : baseRExtent;

      var rExtent = rExtentSettings.extent;
      var subZeroRExtent = [0, 0];

      if (pieceType.type === "bar" && summaryType.type && summaryType.type !== "none") {
        pieceType.type = undefined;
      }

      if (pieceType.type === "timeline") {
        var rData = allData.map(rAccessor);
        var leftExtent = extent(rData.map(function (d) {
          return d[0];
        }));
        var rightExtent = extent(rData.map(function (d) {
          return d[1];
        }));
        rExtent = extent([].concat(toConsumableArray(leftExtent), toConsumableArray(rightExtent)));
      } else if (pieceType.type !== "bar") {
        rExtent = extent(allData, rAccessor);
      } else {
        var positiveData = allData.filter(function (d) {
          return rAccessor(d) >= 0;
        });
        var negativeData = allData.filter(function (d) {
          return rAccessor(d) <= 0;
        });

        var nestedPositiveData = nest().key(oAccessor).rollup(function (leaves) {
          return sum$1(leaves.map(rAccessor));
        }).entries(positiveData);

        var nestedNegativeData = nest().key(oAccessor).rollup(function (leaves) {
          return sum$1(leaves.map(rAccessor));
        }).entries(negativeData);

        rExtent = [0, nestedPositiveData.length === 0 ? 0 : Math.max(max(nestedPositiveData, function (d) {
          return d.value;
        }), 0)];

        subZeroRExtent = [0, nestedNegativeData.length === 0 ? 0 : Math.min(min(nestedNegativeData, function (d) {
          return d.value;
        }), 0)];
        rExtent = [subZeroRExtent[1], rExtent[1]];
      }

      if (pieceType.type === "clusterbar") {
        rExtent[0] = 0;
      }

      var calculatedRExtent = rExtent;

      if (rExtentSettings.extent && rExtentSettings.extent[0] !== undefined && rExtentSettings.extent[1] !== undefined) {
        rExtent = rExtentSettings.extent;
      } else {
        if (rExtentSettings.extent && rExtentSettings.extent[1] !== undefined && rExtentSettings.extent[0] === undefined) {
          rExtent[1] = rExtentSettings.extent[1];
        }

        if (rExtentSettings.extent && rExtentSettings.extent[0] !== undefined && rExtentSettings.extent[1] === undefined) {
          rExtent[0] = rExtentSettings.extent[0];
        }
      }

      if (currentProps.sortO) {
        oExtent = oExtent.sort(currentProps.sortO);
      }
      if (currentProps.invertR || rExtentSettings.extent && rExtentSettings.extent[0] > rExtentSettings.extent[1]) {
        rExtent = [rExtent[1], rExtent[0]];
      }

      var rDomain = [0, adjustedSize[0]];
      var oDomain = [0, adjustedSize[1]];

      if (projection === "vertical") {
        oDomain = [0, adjustedSize[0]];
        rDomain = [0, adjustedSize[1]];
      }

      var oScaleType = currentProps.oScaleType || band;
      var rScaleType = currentProps.rScaleType || linear$2;

      var cwHash = void 0;

      var oScale = void 0;

      if (currentProps.dynamicColumnWidth) {
        var columnValueCreator = void 0;
        if (typeof currentProps.dynamicColumnWidth === "string") {
          columnValueCreator = function columnValueCreator(d) {
            return sum$1(d.map(function (p) {
              return p.data[currentProps.dynamicColumnWidth];
            }));
          };
        } else {
          columnValueCreator = function columnValueCreator(d) {
            return currentProps.dynamicColumnWidth(d.map(function (p) {
              return p.data;
            }));
          };
        }
        var thresholdDomain = [0];
        var maxColumnValues = 0;
        var columnValues = [];

        oExtent.forEach(function (d) {
          var oValues = barData.filter(function (p, q) {
            return oAccessor(p.data, q) === d;
          });
          var columnValue = columnValueCreator(oValues);

          columnValues.push(columnValue);
          maxColumnValues += columnValue;
        });

        cwHash = { total: 0 };
        oExtent.forEach(function (d, i) {
          var oValue = columnValues[i];
          var stepValue = oValue / maxColumnValues * (oDomain[1] - oDomain[0]);
          cwHash[d] = stepValue;
          cwHash.total += stepValue;
          if (i !== oExtent.length - 1) {
            thresholdDomain.push(stepValue + thresholdDomain[i]);
          }
        });

        oScale = ordinal().domain(oExtent).range(thresholdDomain);
      } else {
        oScale = oScaleType().domain(oExtent).range(oDomain);
      }

      var rScale = rScaleType().domain(rExtent).range(rDomain);

      var rScaleReverse = rScaleType().domain(rDomain).range(rDomain.reverse());

      var rScaleVertical = rScaleType().domain(rExtent).range(rDomain);

      this.oScale = oScale;
      this.rScale = rScale;

      this.oAccessor = oAccessor;
      this.rAccessor = rAccessor;

      var columnWidth = cwHash ? 0 : oScale.bandwidth();

      var pieceData = [];

      var mappedMiddleSize = adjustedSize[1];
      if (projection === "vertical") {
        mappedMiddleSize = adjustedSize[0];
      }
      var mappedMiddles = this.mappedMiddles(oScale, mappedMiddleSize, padding);

      var nestedPieces = {};
      nest().key(function (d, i) {
        return oAccessor(d.data, i);
      }).entries(barData).forEach(function (d) {
        nestedPieces[d.key] = d.values;
      });
      pieceData = oExtent.map(function (d) {
        return nestedPieces[d] ? nestedPieces[d] : [];
      });

      var zeroValue = projection === "vertical" ? rScaleReverse(rScale(0)) : rScale(0);

      oExtent.forEach(function (o, i) {
        projectedColumns[o] = { name: o, padding: padding, pieceData: pieceData[i] };
        projectedColumns[o].x = oScale(o) + padding / 2;
        projectedColumns[o].y = 0;
        projectedColumns[o].middle = mappedMiddles[o] + padding / 2;

        var negativeOffset = zeroValue;
        var positiveOffset = zeroValue;

        projectedColumns[o].pieceData.forEach(function (piece) {
          var valPosition = void 0;
          piece.value = rAccessor(piece.data);

          if (pieceType.type === "timeline") {
            piece.scaledValue = rScale(piece.value[0]);
            piece.scaledEndValue = rScale(piece.value[1]);
            piece.scaledVerticalValue = rScaleVertical(piece.value[0]);
            piece.scaledZeroOffset = rScaleVertical(0) - piece.scaledVerticalValue;
          } else if (pieceType.type !== "bar" && pieceType.type !== "clusterbar") {
            piece.scaledValue = rScale(piece.value);
            piece.scaledVerticalValue = rScaleVertical(piece.value);
            piece.scaledZeroOffset = piece.scaledValue - zeroValue;
          } else {
            valPosition = projection === "vertical" ? rScaleReverse(rScale(piece.value)) : rScale(piece.value);
            piece.scaledValue = Math.abs(zeroValue - valPosition);
            piece.scaledZeroOffset = valPosition - zeroValue;
          }

          piece.x = projectedColumns[o].x;
          if (piece.value >= 0) {
            piece.base = zeroValue;
            piece.bottom = positiveOffset;
            piece.middle = piece.scaledValue / 2 + positiveOffset;
            positiveOffset = projection === "vertical" ? positiveOffset - piece.scaledValue : positiveOffset + piece.scaledValue;
            piece.negative = false;
          } else {
            piece.base = zeroValue;
            piece.bottom = negativeOffset;
            piece.middle = positiveOffset - piece.scaledValue / 2;
            negativeOffset = projection === "vertical" ? negativeOffset + piece.scaledValue : negativeOffset - piece.scaledValue;
            piece.negative = true;
          }
        });

        if (cwHash) {
          projectedColumns[o].width = cwHash[o] - padding;

          if (currentProps.ordinalAlign === "center") {
            projectedColumns[o].x = projectedColumns[o].x - projectedColumns[o].width / 2;
            projectedColumns[o].middle = projectedColumns[o].middle - projectedColumns[o].width / 2;
          }
          projectedColumns[o].pct = cwHash[o] / cwHash.total;
          projectedColumns[o].pct_start = (projectedColumns[o].x - oDomain[0]) / cwHash.total;
          projectedColumns[o].pct_padding = padding / cwHash.total;
          projectedColumns[o].pct_middle = (projectedColumns[o].middle - oDomain[0]) / cwHash.total;
        } else {
          projectedColumns[o].width = columnWidth - padding;
          if (currentProps.ordinalAlign === "center") {
            projectedColumns[o].x = projectedColumns[o].x - projectedColumns[o].width / 2;
            projectedColumns[o].middle = projectedColumns[o].middle - projectedColumns[o].width / 2;
          }

          projectedColumns[o].pct = columnWidth / adjustedSize[1];
          projectedColumns[o].pct_start = (projectedColumns[o].x - oDomain[0]) / adjustedSize[1];
          projectedColumns[o].pct_padding = padding / adjustedSize[1];
          projectedColumns[o].pct_middle = (projectedColumns[o].middle - oDomain[0]) / adjustedSize[1];
        }
      });

      var labelArray = [];

      var pieArcs = [];

      if (currentProps.oLabel || currentProps.hoverAnnotation) {
        oExtent.forEach(function (d, i) {
          var arcGenerator = arc().innerRadius(0).outerRadius(rScale.range()[1] / 2);
          var angle = 1 / oExtent.length;
          var startAngle = angle * i;
          angle = projectedColumns[d].pct;
          startAngle = projectedColumns[d].pct_start;

          var endAngle = startAngle + angle;
          var midAngle = startAngle + angle / 2;

          var markD = arcGenerator({
            startAngle: startAngle * twoPI$1,
            endAngle: endAngle * twoPI$1
          });
          var translate = [adjustedSize[0] / 2, adjustedSize[1] / 2];
          var centroid = arcGenerator.centroid({
            startAngle: startAngle * twoPI$1,
            endAngle: endAngle * twoPI$1
          });
          pieArcs.push({
            startAngle: startAngle,
            endAngle: endAngle,
            midAngle: midAngle,
            markD: markD,
            translate: translate,
            centroid: centroid
          });
        });
      }

      var labelSettings = _typeof(currentProps.oLabel) === "object" ? Object.assign({ label: true }, currentProps.oLabel) : { orient: "default", label: currentProps.oLabel };

      if (currentProps.oLabel) {
        var labelingFn = void 0;
        if (labelSettings.label === true) {
          labelingFn = function labelingFn(d) {
            return React.createElement(
              "text",
              {
                style: {
                  textAnchor: projection === "horizontal" && labelSettings.orient === "right" ? "start" : projection === "horizontal" ? "end" : "middle"
                }
              },
              d
            );
          };
        } else if (typeof labelSettings.label === "function") {
          labelingFn = labelSettings.label;
        }

        oExtent.forEach(function (d, i) {
          var xPosition = projectedColumns[d].middle;
          var yPosition = 0;

          if (projection === "horizontal") {
            yPosition = projectedColumns[d].middle;
            if (labelSettings.orient === "right") {
              xPosition = adjustedSize[0] + 3;
            } else {
              xPosition = -3;
            }
          } else if (projection === "radial") {
            xPosition = pieArcs[i].centroid[0] + pieArcs[i].translate[0];
            yPosition = pieArcs[i].centroid[1] + pieArcs[i].translate[1];
          }
          var label = labelingFn(d, currentProps.data ? currentProps.data.filter(function (p, q) {
            return oAccessor(p, q) === d;
          }) : undefined, i);
          labelArray.push(React.createElement(
            "g",
            {
              key: "olabel-" + i,
              transform: "translate(" + xPosition + "," + yPosition + ")"
            },
            label
          ));
        });

        if (projection === "vertical") {
          var labelY = void 0;
          if (labelSettings.orient === "top") {
            labelY = -15;
          } else {
            labelY = 15 + rScale.range()[1];
          }
          oLabels = React.createElement(
            "g",
            {
              key: "ordinalframe-labels-container",
              transform: "translate(" + margin.left + "," + (labelY + margin.top) + ")"
            },
            labelArray
          );
        } else if (projection === "horizontal") {
          oLabels = React.createElement(
            "g",
            {
              key: "ordinalframe-labels-container",
              transform: "translate(" + margin.left + "," + margin.top + ")"
            },
            labelArray
          );
        } else if (projection === "radial") {
          oLabels = React.createElement(
            "g",
            {
              key: "ordinalframe-labels-container",
              transform: "translate(" + margin.left + "," + margin.top + ")"
            },
            labelArray
          );
        }
      }

      var columnOverlays = void 0;

      if (currentProps.hoverAnnotation) {
        columnOverlays = oExtent.map(function (d, i) {
          var barColumnWidth = projectedColumns[d].width;
          var xPosition = projectedColumns[d].x;
          var yPosition = 0;
          var height = rScale.range()[1];
          var width = barColumnWidth + padding;
          if (projection === "horizontal") {
            yPosition = projectedColumns[d].x;
            xPosition = 0;
            width = rScale.range()[1];
            height = barColumnWidth;
          }

          if (projection === "radial") {
            var _pieArcs$i = pieArcs[i],
                markD = _pieArcs$i.markD,
                centroid = _pieArcs$i.centroid,
                translate = _pieArcs$i.translate,
                midAngle = _pieArcs$i.midAngle;

            return {
              markType: "path",
              key: "hover" + d,
              d: markD,
              transform: "translate(" + translate + ")",
              style: { opacity: 0, fill: "pink" },
              onClick: function onClick() {
                return {
                  type: "column-hover",
                  pieces: projectedColumns[d].pieceData,
                  summary: projectedColumns[d].pieceData,
                  arcAngles: {
                    centroid: centroid,
                    translate: translate,
                    midAngle: midAngle,
                    length: rScale.range()[1] / 2
                  }
                };
              },
              onMouseEnter: function onMouseEnter() {
                return {
                  type: "column-hover",
                  pieces: projectedColumns[d].pieceData,
                  summary: projectedColumns[d].pieceData,
                  arcAngles: {
                    centroid: centroid,
                    translate: translate,
                    midAngle: midAngle,
                    length: rScale.range()[1] / 2
                  }
                };
              },
              onMouseLeave: function onMouseLeave() {
                return {};
              }
            };
          }

          return {
            markType: "rect",
            key: "hover-" + d,
            x: xPosition,
            y: yPosition,
            height: height,
            width: width,
            style: { opacity: 0, stroke: "black", fill: "pink" },
            onClick: function onClick() {
              return {
                type: "column-hover",
                pieces: projectedColumns[d].pieceData,
                summary: projectedColumns[d].pieceData
              };
            },
            onMouseEnter: function onMouseEnter() {
              return {
                type: "column-hover",
                pieces: projectedColumns[d].pieceData,
                summary: projectedColumns[d].pieceData
              };
            },
            onMouseLeave: function onMouseLeave() {
              return {};
            }
          };
        });
      }

      var _orFrameAxisGenerator = orFrameAxisGenerator({
        axis: currentProps.axis,
        data: currentProps.data,
        projection: projection,
        adjustedSize: adjustedSize,
        size: size,
        rScale: rScale,
        rScaleType: rScaleType,
        pieceType: pieceType,
        rExtent: rExtent
      }),
          axis = _orFrameAxisGenerator.axis,
          axesTickLines = _orFrameAxisGenerator.axesTickLines;

      var renderMode = currentProps.renderMode,
          canvasSummaries = currentProps.canvasSummaries,
          summaryRenderMode = currentProps.summaryRenderMode,
          connectorClass = currentProps.connectorClass,
          connectorRenderMode = currentProps.connectorRenderMode,
          canvasConnectors = currentProps.canvasConnectors,
          canvasPieces = currentProps.canvasPieces;


      var pieceDataXY = void 0;
      var pieceRenderMode = stringToFn(renderMode, undefined, true);
      var pieceCanvasRender = stringToFn(canvasPieces, undefined, true);
      var summaryCanvasRender = stringToFn(canvasPieces, undefined, true);
      var connectorCanvasRender = stringToFn(canvasConnectors, undefined, true);

      var pieceTypeForXY = pieceType.type && pieceType.type !== "none" ? pieceType.type : "point";
      var pieceTypeLayout = typeof pieceTypeForXY === "function" ? pieceTypeForXY : layoutHash[pieceTypeForXY];
      var calculatedPieceData = pieceTypeLayout({
        type: pieceType,
        data: projectedColumns,
        renderMode: pieceRenderMode,
        eventListenersGenerator: eventListenersGenerator,
        styleFn: pieceStyle,
        projection: projection,
        classFn: pieceClass,
        adjustedSize: adjustedSize,
        rScale: rScale
      });

      var keyedData = calculatedPieceData.reduce(function (p, c) {
        if (!p[c.o]) {
          p[c.o] = [];
        }
        p[c.o].push(c);
        return p;
      }, {});

      Object.keys(projectedColumns).forEach(function (d) {
        projectedColumns[d].xyData = keyedData[d] || [];
      });
      var calculatedSummaries = {};

      if (summaryType.type) {
        calculatedSummaries = drawSummaries({
          data: projectedColumns,
          type: summaryType,
          renderMode: stringToFn(summaryRenderMode, undefined, true),
          styleFn: stringToFn(summaryStyle, function () {
            return {};
          }, true),
          classFn: stringToFn(summaryClass, function () {
            return "";
          }, true),
          canvasRender: stringToFn(canvasSummaries, undefined, true),
          positionFn: summaryPosition,
          projection: projection,
          eventListenersGenerator: eventListenersGenerator,
          adjustedSize: adjustedSize,
          baseMarkProps: currentProps.baseMarkProps || {}
        });
      }

      if (currentProps.pieceHoverAnnotation && ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) === -1 || currentProps.summaryHoverAnnotation) {
        var yMod = projection === "horizontal" ? midMod : zeroFunction;
        var xMod = projection === "vertical" ? midMod : zeroFunction;

        if (currentProps.summaryHoverAnnotation && calculatedSummaries.xyPoints) {
          pieceDataXY = calculatedSummaries.xyPoints.map(function (d) {
            return Object.assign({}, d, {
              type: "frame-hover",
              isSummaryData: true,
              x: d.x,
              y: d.y
            });
          });
        } else if (currentProps.pieceHoverAnnotation && calculatedPieceData) {
          pieceDataXY = calculatedPieceData.map(function (d) {
            return Object.assign({}, d.piece, {
              type: "frame-hover",
              x: d.xy.x + xMod(d.xy),
              y: d.xy.y + yMod(d.xy)
            });
          });
        }
      }

      if (currentProps.pieceHoverAnnotation && ["bar", "clusterbar", "timeline"].indexOf(pieceType.type) !== -1) {
        var _yMod = projection === "horizontal" ? midMod : zeroFunction;
        var _xMod = projection === "vertical" ? midMod : zeroFunction;

        columnOverlays = calculatedPieceData.map(function (d, i) {
          return _extends({}, d.renderElement, {
            key: "hover-" + i,
            type: "frame-hover",
            style: { opacity: 0, stroke: "black", fill: "pink" },
            onClick: function onClick() {
              return _extends({}, d.piece, {
                x: d.xy.x + _xMod(d.xy),
                y: d.xy.y + _yMod(d.xy)
              });
            },
            onMouseEnter: function onMouseEnter() {
              return _extends({}, d.piece, {
                x: d.xy.x + _xMod(d.xy),
                y: d.xy.y + _yMod(d.xy)
              });
            },
            onMouseLeave: function onMouseLeave() {
              return {};
            }
          });
        });
      }

      var orFrameRender = {
        connectors: {
          projection: projection,
          data: keyedData,
          styleFn: stringToFn(connectorStyle, function () {
            return {};
          }, true),
          classFn: stringToFn(connectorClass, function () {
            return "";
          }, true),
          renderMode: stringToFn(connectorRenderMode, undefined, true),
          canvasRender: connectorCanvasRender,
          behavior: orFrameConnectionRenderer,
          type: connectorType,
          eventListenersGenerator: eventListenersGenerator
        },
        summaries: {
          data: calculatedSummaries.marks,
          behavior: renderLaidOutSummaries,
          canvasRender: summaryCanvasRender,
          styleFn: stringToFn(summaryStyle, function () {
            return {};
          }, true),
          classFn: stringToFn(summaryClass, function () {
            return "";
          }, true)
        },
        pieces: {
          shouldRender: pieceType.type && pieceType.type !== "none",
          data: calculatedPieceData,
          behavior: renderLaidOutPieces,
          canvasRender: pieceCanvasRender,
          styleFn: stringToFn(pieceStyle, function () {
            return {};
          }, true),
          classFn: stringToFn(pieceClass, function () {
            return "";
          }, true)
        }
      };

      if (rExtentSettings.onChange && (this.state.calculatedRExtent || []).join(",") !== (calculatedRExtent || []).join(",")) {
        rExtentSettings.onChange(calculatedRExtent);
      }

      if (oExtentSettings.onChange && (this.state.calculatedOExtent || []).join(",") !== (calculatedOExtent || []).join(",")) {
        oExtentSettings.onChange(calculatedOExtent);
      }

      this.setState({
        pieceDataXY: pieceDataXY,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        axisData: currentProps.axis,
        axes: React.createElement(
          "g",
          { key: "ordinalframe-axis", className: "axis-labels" },
          axis
        ),
        axesTickLines: axesTickLines,
        oLabels: oLabels,
        title: title,
        columnOverlays: columnOverlays,
        renderNumber: this.state.renderNumber + 1,
        oAccessor: currentProps.oAccessor,
        rAccessor: currentProps.rAccessor,
        oScaleType: currentProps.oScaleType,
        rScaleType: currentProps.rScaleType,
        oExtent: oExtent,
        rExtent: rExtent,
        calculatedOExtent: calculatedOExtent,
        calculatedRExtent: calculatedRExtent,
        projectedColumns: projectedColumns,
        margin: margin,
        legendSettings: currentProps.legend,
        eventListenersGenerator: eventListenersGenerator,
        orFrameRender: orFrameRender
      });
    }
  }, {
    key: "componentWillMount",
    value: function componentWillMount() {
      this.calculateOrdinalFrame(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.state.dataVersion && this.state.dataVersion !== nextProps.dataVersion || !this.state.projectedColumns) {
        this.calculateOrdinalFrame(nextProps);
      } else if (this.props.size[0] !== nextProps.size[0] || this.props.size[1] !== nextProps.size[1] || !this.state.dataVersion && orFrameChangeProps.find(function (d) {
        return _this2.props[d] !== nextProps[d];
      })) {
        this.calculateOrdinalFrame(nextProps);
      }
    }
  }, {
    key: "clonedAppliedElement",
    value: function clonedAppliedElement(_ref) {
      var tx = _ref.tx,
          ty = _ref.ty,
          d = _ref.d,
          i = _ref.i,
          markProps = _ref.markProps,
          styleFn = _ref.styleFn,
          renderFn = _ref.renderFn,
          classFn = _ref.classFn,
          baseClass = _ref.baseClass;

      markProps.style = styleFn ? styleFn(d, i) : {};
      markProps.renderMode = renderFn ? renderFn(d, i) : undefined;

      if (tx || ty) {
        markProps.transform = "translate(" + (tx || 0) + "," + (ty || 0) + ")";
      }

      markProps.className = baseClass;

      markProps.key = baseClass + "-" + i;

      if (classFn) {
        markProps.className = baseClass + " " + classFn(d, i);
      }

      return React.createElement(lib_2$1, markProps);
    }
  }, {
    key: "defaultORSVGRule",
    value: function defaultORSVGRule(_ref2) {
      var d = _ref2.d,
          i = _ref2.i,
          annotationLayer = _ref2.annotationLayer;

      var oAccessor = this.oAccessor;
      var rAccessor = this.rAccessor;
      var oScale = this.oScale;
      var rScale = this.rScale;

      var projection = this.props.projection;
      var _state = this.state,
          projectedColumns = _state.projectedColumns,
          orFrameRender = _state.orFrameRender;


      var pieceIDAccessor = stringToFn(this.props.pieceIDAccessor, function (p) {
        return p.semioticPieceID;
      });

      var _adjustedPositionSize2 = adjustedPositionSize(this.props),
          adjustedPosition = _adjustedPositionSize2.adjustedPosition,
          adjustedSize = _adjustedPositionSize2.adjustedSize;

      var screenProject = function screenProject(p) {
        var oColumn = projectedColumns[oAccessor(p)];
        var o = void 0;
        if (oColumn) {
          o = oColumn.middle;
        } else {
          o = 0;
        }
        var idPiece = pieceIDAccessor(d) && oColumn && oColumn.pieceData.find(function (r) {
          return pieceIDAccessor(r.data) === pieceIDAccessor(d);
        });

        if (oColumn && projection === "radial") {
          return pointOnArcAtAngle([adjustedSize[0] / 2, adjustedSize[1] / 2], oColumn.pct_middle, idPiece ? (idPiece.bottom + idPiece.scaledValue / 2) / 2 : rScale(rAccessor(p)) / 2);
        }
        if (projection === "horizontal") {
          return [idPiece ? idPiece.bottom + idPiece.scaledValue / 2 : rScale(rAccessor(p)), o];
        }
        var newScale = linear$2().domain(rScale.domain()).range(rScale.range().reverse());

        return [o, idPiece ? idPiece.bottom - idPiece.scaledValue / 2 : newScale(rAccessor(p))];
      };

      var screenCoordinates = [0, 0];

      //TODO: Support radial??
      if (d.coordinates || d.type === "enclose" && d.neighbors) {
        screenCoordinates = (d.coordinates || d.neighbors).map(function (p) {
          return screenProject(p);
        });
      } else {
        screenCoordinates = screenProject(d);
      }

      //TODO: Process your rules first
      var customAnnotation = this.props.svgAnnotationRules && this.props.svgAnnotationRules({
        d: d,
        i: i,
        oScale: oScale,
        rScale: rScale,
        oAccessor: oAccessor,
        rAccessor: rAccessor,
        orFrameProps: this.props,
        screenCoordinates: screenCoordinates,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        annotationLayer: annotationLayer,
        orFrameState: this.state,
        categories: this.state.projectedColumns
      });
      if (this.props.svgAnnotationRules && customAnnotation !== null) {
        return customAnnotation;
      } else if (d.type === "or") {
        return svgORRule({ d: d, i: i, screenCoordinates: screenCoordinates, projection: projection });
      } else if (d.type === "highlight") {
        return svgHighlightRule({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          projection: projection,
          categories: projectedColumns,
          pieceIDAccessor: pieceIDAccessor,
          orFrameRender: orFrameRender,
          oAccessor: oAccessor
        });
      } else if (d.type === "react-annotation" || typeof d.type === "function") {
        return basicReactAnnotationRule({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "enclose") {
        return svgEncloseRule({ d: d, i: i, screenCoordinates: screenCoordinates });
      } else if (d.type === "enclose-rect") {
        return svgRectEncloseRule$1({ d: d, screenCoordinates: screenCoordinates, i: i });
      } else if (d.type === "r") {
        return svgRRule({
          d: d,
          i: i,
          screenCoordinates: screenCoordinates,
          rScale: rScale,
          rAccessor: rAccessor,
          projection: projection,
          adjustedSize: adjustedSize,
          adjustedPosition: adjustedPosition
        });
      } else if (d.type === "category") {
        return svgCategoryRule({
          projection: projection,
          d: d,
          i: i,
          categories: this.state.projectedColumns,
          adjustedSize: adjustedSize
        });
      }
      return null;
    }
  }, {
    key: "defaultORHTMLRule",
    value: function defaultORHTMLRule(_ref3) {
      var d = _ref3.d,
          i = _ref3.i;

      var oAccessor = this.oAccessor;
      var rAccessor = this.rAccessor;
      var oScale = this.oScale;
      var rScale = this.rScale;

      var _props = this.props,
          htmlAnnotationRules = _props.htmlAnnotationRules,
          tooltipContent = _props.tooltipContent,
          projection = _props.projection,
          size = _props.size;
      var projectedColumns = this.state.projectedColumns;


      var type = _typeof(this.props.type) === "object" ? this.props.type : { type: this.props.type };
      var summaryType = _typeof(this.props.summaryType) === "object" ? this.props.summaryType : { type: this.props.summaryType };

      var _adjustedPositionSize3 = adjustedPositionSize(this.props),
          adjustedPosition = _adjustedPositionSize3.adjustedPosition,
          adjustedSize = _adjustedPositionSize3.adjustedSize;

      //TODO: Process your rules first


      if (htmlAnnotationRules && htmlAnnotationRules({
        d: d,
        i: i,
        oScale: oScale,
        rScale: rScale,
        oAccessor: oAccessor,
        rAccessor: rAccessor,
        orFrameProps: this.props,
        orFrameState: this.state,
        categories: this.state.projectedColumns
      }) !== null) {
        return htmlAnnotationRules({
          d: d,
          i: i,
          oScale: oScale,
          rScale: rScale,
          oAccessor: oAccessor,
          rAccessor: rAccessor,
          orFrameProps: this.props,
          categories: this.state.projectedColumns
        });
      }

      if (d.type === "frame-hover") {
        return htmlFrameHoverRule({
          d: d,
          i: i,
          rAccessor: rAccessor,
          oAccessor: oAccessor,
          size: size,
          projection: projection,
          tooltipContent: tooltipContent
        });
      } else if (d.type === "column-hover") {
        return htmlColumnHoverRule({
          d: d,
          i: i,
          summaryType: summaryType,
          oAccessor: oAccessor,
          rAccessor: rAccessor,
          projectedColumns: projectedColumns,
          type: type,
          adjustedPosition: adjustedPosition,
          adjustedSize: adjustedSize,
          projection: projection,
          tooltipContent: tooltipContent
        });
      }
      return null;
    }
  }, {
    key: "mappedMiddles",
    value: function mappedMiddles(oScale, middleMax, padding) {
      var oScaleDomainValues = oScale.domain();

      var mappedMiddles = {};
      oScaleDomainValues.forEach(function (p, q) {
        var base = oScale(p) - padding;
        var next = oScaleDomainValues[q + 1] ? oScale(oScaleDomainValues[q + 1]) : middleMax;
        var diff = (next - base) / 2;
        mappedMiddles[p] = base + diff;
      });

      return mappedMiddles;
    }
  }, {
    key: "render",
    value: function render() {
      return this.renderBody({ afterElements: this.props.afterElements });
    }
  }, {
    key: "renderBody",
    value: function renderBody(_ref4) {
      var afterElements = _ref4.afterElements;
      var _props2 = this.props,
          className = _props2.className,
          annotationSettings = _props2.annotationSettings,
          size = _props2.size,
          downloadFields = _props2.downloadFields,
          rAccessor = _props2.rAccessor,
          oAccessor = _props2.oAccessor,
          name = _props2.name,
          download = _props2.download,
          annotations = _props2.annotations,
          matte = _props2.matte,
          renderKey = _props2.renderKey,
          interaction = _props2.interaction,
          customClickBehavior = _props2.customClickBehavior,
          customHoverBehavior = _props2.customHoverBehavior,
          customDoubleClickBehavior = _props2.customDoubleClickBehavior,
          projection = _props2.projection,
          backgroundGraphics = _props2.backgroundGraphics,
          foregroundGraphics = _props2.foregroundGraphics,
          beforeElements = _props2.beforeElements,
          disableContext = _props2.disableContext,
          summaryType = _props2.summaryType,
          summaryHoverAnnotation = _props2.summaryHoverAnnotation,
          pieceHoverAnnotation = _props2.pieceHoverAnnotation,
          hoverAnnotation = _props2.hoverAnnotation,
          canvasPostProcess = _props2.canvasPostProcess,
          baseMarkProps = _props2.baseMarkProps,
          useSpans = _props2.useSpans;
      var _state2 = this.state,
          orFrameRender = _state2.orFrameRender,
          projectedColumns = _state2.projectedColumns,
          adjustedPosition = _state2.adjustedPosition,
          adjustedSize = _state2.adjustedSize,
          legendSettings = _state2.legendSettings,
          columnOverlays = _state2.columnOverlays,
          axesTickLines = _state2.axesTickLines,
          axes = _state2.axes,
          margin = _state2.margin,
          pieceDataXY = _state2.pieceDataXY,
          oLabels = _state2.oLabels,
          title = _state2.title;


      var downloadButton = void 0;

      if (download) {
        downloadButton = React.createElement(DownloadButton, {
          csvName: (name || "orframe") + "-" + new Date().toJSON(),
          width: size[0],
          data: orDownloadMapping({
            data: projectedColumns,
            rAccessor: stringToFn(rAccessor),
            oAccessor: stringToFn(oAccessor),
            fields: downloadFields
          })
        });
      }

      var finalFilterDefs = filterDefs({
        key: "orframe",
        additionalDefs: this.props.additionalDefs
      });

      var interactionOverflow = void 0;

      if (summaryType && summaryType.amplitude) {
        if (projection === "horizontal") {
          interactionOverflow = {
            top: summaryType.amplitude,
            bottom: 0,
            left: 0,
            right: 0
          };
        } else if (projection === "radial") {
          interactionOverflow = defaultOverflow;
        } else {
          interactionOverflow = {
            top: 0,
            bottom: 0,
            left: summaryType.amplitude,
            right: 0
          };
        }
      }

      return React.createElement(Frame, {
        name: "ordinalframe",
        renderPipeline: orFrameRender,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        size: size,
        xScale: xScale,
        yScale: yScale,
        axes: [axes],
        useSpans: useSpans,
        axesTickLines: axesTickLines,
        title: title,
        matte: matte,
        className: className,
        finalFilterDefs: finalFilterDefs,
        frameKey: "none",
        renderKeyFn: renderKey,
        projectedCoordinateNames: projectedCoordinatesObject,
        defaultSVGRule: this.defaultORSVGRule.bind(this),
        defaultHTMLRule: this.defaultORHTMLRule.bind(this),
        hoverAnnotation: summaryHoverAnnotation || pieceHoverAnnotation || hoverAnnotation,
        annotations: annotations,
        annotationSettings: annotationSettings,
        legendSettings: legendSettings,
        interaction: interaction,
        customClickBehavior: customClickBehavior,
        customHoverBehavior: customHoverBehavior,
        customDoubleClickBehavior: customDoubleClickBehavior,
        points: pieceDataXY,
        margin: margin,
        columns: projectedColumns,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: [foregroundGraphics, oLabels],
        beforeElements: beforeElements,
        afterElements: afterElements,
        downloadButton: downloadButton,
        overlay: columnOverlays,
        rScale: this.rScale,
        projection: projection,
        disableContext: disableContext,
        interactionOverflow: interactionOverflow,
        canvasPostProcess: canvasPostProcess,
        baseMarkProps: baseMarkProps
      });
    }
  }]);
  return OrdinalFrame;
}(React.Component);

OrdinalFrame.defaultProps = {
  annotations: [],
  foregroundGraphics: [],
  annotationSettings: {},
  projection: "vertical",
  size: [500, 500],
  className: ""
};


OrdinalFrame.propTypes = {
  data: propTypes.array,
  name: propTypes.string,
  title: propTypes.oneOfType([propTypes.string, propTypes.object]),
  margin: propTypes.oneOfType([propTypes.number, propTypes.object]),
  size: propTypes.array,
  position: propTypes.array,
  oScaleType: propTypes.func,
  rScaleType: propTypes.func,
  oExtent: propTypes.oneOfType([propTypes.array, propTypes.object]),
  rExtent: propTypes.oneOfType([propTypes.array, propTypes.object]),
  invertO: propTypes.bool,
  invertR: propTypes.bool,
  oAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  rAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  annotations: propTypes.array,
  customHoverBehavior: propTypes.func,
  customClickBehavior: propTypes.func,
  svgAnnotationRules: propTypes.func,
  oPadding: propTypes.number,
  projection: propTypes.string,
  htmlAnnotationRules: propTypes.func,
  type: propTypes.oneOfType([propTypes.string, propTypes.object, propTypes.func]),
  summaryType: propTypes.oneOfType([propTypes.string, propTypes.object]),
  connectorType: propTypes.func,
  tooltipContent: propTypes.oneOfType([propTypes.string, propTypes.func]),
  className: propTypes.string,
  additionalDefs: propTypes.oneOfType([propTypes.array, propTypes.object]),
  interaction: propTypes.object,
  baseMarkProps: propTypes.object,
  renderKey: propTypes.oneOfType([propTypes.string, propTypes.func]),
  dataAccessor: propTypes.func,
  rBaseline: propTypes.number,
  sortO: propTypes.func,
  pixelColumnWidth: propTypes.number,
  dynamicColumnWidth: propTypes.oneOfType([propTypes.string, propTypes.func]),
  renderFn: propTypes.oneOfType([propTypes.string, propTypes.func]),
  style: propTypes.oneOfType([propTypes.object, propTypes.func]),
  connectorStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  summaryStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  summaryPosition: propTypes.func,
  oLabel: propTypes.oneOfType([propTypes.bool, propTypes.func, propTypes.object]),
  hoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool]),
  pieceHoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool]),
  summaryHoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool]),
  axis: propTypes.oneOfType([propTypes.object, propTypes.array]),
  canvasPostProcess: propTypes.oneOfType([propTypes.func, propTypes.string]),
  backgroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array]),
  foregroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array])
};

// components

var MiniMap = function MiniMap(props) {
  var interactivity = {
    start: props.brushStart,
    during: props.brush,
    end: props.brushEnd
  };

  if (props.xBrushable && props.yBrushable) {
    interactivity.brush = "xyBrush";

    if (props.xBrushExtent || props.yBrushExtent) {
      interactivity.extent = [[0, 0], [].concat(toConsumableArray(props.size))];
    }
    if (props.xBrushExtent) {
      interactivity.extent[0] = props.xBrushExtent;
    }
    if (props.yBrushExtent) {
      interactivity.extent[1] = props.yBrushExtent;
    }
  } else if (props.xBrushable) {
    interactivity.brush = "xBrush";
    if (props.xBrushExtent) {
      interactivity.extent = props.xBrushExtent;
    }
  } else if (props.yBrushable) {
    interactivity.brush = "yBrush";
    if (props.yBrushExtent) {
      interactivity.extent = props.yBrushExtent;
    }
  }

  return React.createElement(XYFrame, _extends({}, props, { interaction: interactivity }));
};

MiniMap.propTypes = {
  brushStart: propTypes.func,
  brush: propTypes.func,
  brushEnd: propTypes.func,
  xBrushExtent: propTypes.array,
  yBrushExtent: propTypes.array,
  xBrushable: propTypes.bool,
  yBrushable: propTypes.bool
};

// components
var MinimapXYFrame = function (_XYFrame) {
  inherits(MinimapXYFrame, _XYFrame);

  function MinimapXYFrame(props) {
    classCallCheck(this, MinimapXYFrame);

    var _this = possibleConstructorReturn(this, (MinimapXYFrame.__proto__ || Object.getPrototypeOf(MinimapXYFrame)).call(this, props));

    _this.generateMinimap = _this.generateMinimap.bind(_this);
    return _this;
  }

  createClass(MinimapXYFrame, [{
    key: "generateMinimap",
    value: function generateMinimap() {
      var miniDefaults = {
        title: "",
        position: [0, 0],
        size: [this.props.size[0], this.props.size[1] * 0.25],
        xAccessor: this.props.xAccessor,
        yAccessor: this.props.yAccessor,
        points: this.props.points,
        lines: this.props.lines,
        areas: this.props.areas,
        lineDataAccessor: this.props.lineDataAccessor,
        xBrushable: true,
        yBrushable: true,
        brushStart: function brushStart() {},
        brush: function brush() {},
        brushEnd: function brushEnd() {},
        lineType: this.props.lineType
      };

      var combinedOptions = Object.assign(miniDefaults, this.props.minimap);

      combinedOptions.hoverAnnotation = false;

      return React.createElement(MiniMap, combinedOptions);
    }
  }, {
    key: "render",
    value: function render() {
      var miniMap = this.generateMinimap();
      var options = {};
      if (this.props.renderBefore) {
        options.beforeElements = miniMap;
      } else {
        options.afterElements = miniMap;
      }

      return this.renderBody(options);
    }
  }]);
  return MinimapXYFrame;
}(XYFrame);

MinimapXYFrame.propTypes = {
  size: propTypes.array,
  xAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  yAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  points: propTypes.array,
  lines: propTypes.array,
  areas: propTypes.array,
  lineDataAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  lineType: propTypes.oneOfType([propTypes.string, propTypes.object]),
  minimap: propTypes.object,
  renderBefore: propTypes.oneOfType([propTypes.array, propTypes.object])
};

var bboxCollide = function (bbox) {

  function x(d) {
    return d.x + d.vx;
  }

  function y(d) {
    return d.y + d.vy;
  }

  function constant(x) {
    return function () {
      return x;
    };
  }

  var nodes,
      boundingBoxes,
      strength = 1,
      iterations = 1;

  if (typeof bbox !== "function") {
    bbox = constant(bbox === null ? [[0, 0][(1)]] : bbox);
  }

  function force() {
    var i, tree, node, xi, yi, bbi, nx1, ny1, nx2, ny2;

    var cornerNodes = [];
    nodes.forEach(function (d, i) {
      cornerNodes.push({ node: d, vx: d.vx, vy: d.vy, x: d.x + (boundingBoxes[i][1][0] + boundingBoxes[i][0][0]) / 2, y: d.y + (boundingBoxes[i][0][1] + boundingBoxes[i][1][1]) / 2 });
      cornerNodes.push({ node: d, vx: d.vx, vy: d.vy, x: d.x + boundingBoxes[i][0][0], y: d.y + boundingBoxes[i][0][1] });
      cornerNodes.push({ node: d, vx: d.vx, vy: d.vy, x: d.x + boundingBoxes[i][0][0], y: d.y + boundingBoxes[i][1][1] });
      cornerNodes.push({ node: d, vx: d.vx, vy: d.vy, x: d.x + boundingBoxes[i][1][0], y: d.y + boundingBoxes[i][0][1] });
      cornerNodes.push({ node: d, vx: d.vx, vy: d.vy, x: d.x + boundingBoxes[i][1][0], y: d.y + boundingBoxes[i][1][1] });
    });
    var cn = cornerNodes.length;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(cornerNodes, x, y).visitAfter(prepareCorners);

      for (i = 0; i < cn; ++i) {
        var nodeI = ~~(i / 5);
        node = nodes[nodeI];
        bbi = boundingBoxes[nodeI];
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        nx1 = xi + bbi[0][0];
        ny1 = yi + bbi[0][1];
        nx2 = xi + bbi[1][0];
        ny2 = yi + bbi[1][1];
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data;
      if (data) {
        var bWidth = bbLength(bbi, 0),
            bHeight = bbLength(bbi, 1);

        if (data.node.index !== nodeI) {
          var dataNode = data.node;
          var bbj = boundingBoxes[dataNode.index],
              dnx1 = dataNode.x + dataNode.vx + bbj[0][0],
              dny1 = dataNode.y + dataNode.vy + bbj[0][1],
              dnx2 = dataNode.x + dataNode.vx + bbj[1][0],
              dny2 = dataNode.y + dataNode.vy + bbj[1][1],
              dWidth = bbLength(bbj, 0),
              dHeight = bbLength(bbj, 1);

          if (nx1 <= dnx2 && dnx1 <= nx2 && ny1 <= dny2 && dny1 <= ny2) {

            var xSize = [Math.min.apply(null, [dnx1, dnx2, nx1, nx2]), Math.max.apply(null, [dnx1, dnx2, nx1, nx2])];
            var ySize = [Math.min.apply(null, [dny1, dny2, ny1, ny2]), Math.max.apply(null, [dny1, dny2, ny1, ny2])];

            var xOverlap = bWidth + dWidth - (xSize[1] - xSize[0]);
            var yOverlap = bHeight + dHeight - (ySize[1] - ySize[0]);

            var xBPush = xOverlap * strength * (yOverlap / bHeight);
            var yBPush = yOverlap * strength * (xOverlap / bWidth);

            var xDPush = xOverlap * strength * (yOverlap / dHeight);
            var yDPush = yOverlap * strength * (xOverlap / dWidth);

            if ((nx1 + nx2) / 2 < (dnx1 + dnx2) / 2) {
              node.vx -= xBPush;
              dataNode.vx += xDPush;
            } else {
              node.vx += xBPush;
              dataNode.vx -= xDPush;
            }
            if ((ny1 + ny2) / 2 < (dny1 + dny2) / 2) {
              node.vy -= yBPush;
              dataNode.vy += yDPush;
            } else {
              node.vy += yBPush;
              dataNode.vy -= yDPush;
            }
          }
        }
        return;
      }

      return x0 > nx2 || x1 < nx1 || y0 > ny2 || y1 < ny1;
    }
  }

  function prepareCorners(quad) {

    if (quad.data) {
      return quad.bb = boundingBoxes[quad.data.node.index];
    }
    quad.bb = [[0, 0], [0, 0]];
    for (var i = 0; i < 4; ++i) {
      if (quad[i] && quad[i].bb[0][0] < quad.bb[0][0]) {
        quad.bb[0][0] = quad[i].bb[0][0];
      }
      if (quad[i] && quad[i].bb[0][1] < quad.bb[0][1]) {
        quad.bb[0][1] = quad[i].bb[0][1];
      }
      if (quad[i] && quad[i].bb[1][0] > quad.bb[1][0]) {
        quad.bb[1][0] = quad[i].bb[1][0];
      }
      if (quad[i] && quad[i].bb[1][1] > quad.bb[1][1]) {
        quad.bb[1][1] = quad[i].bb[1][1];
      }
    }
  }

  function bbLength(bbox, heightWidth) {
    return bbox[1][heightWidth] - bbox[0][heightWidth];
  }

  force.initialize = function (_) {
    var i,
        n = (nodes = _).length;boundingBoxes = new Array(n);
    for (i = 0; i < n; ++i) {
      boundingBoxes[i] = bbox(nodes[i], i, nodes);
    }
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.bbox = function (_) {
    return arguments.length ? (bbox = typeof _ === "function" ? _ : constant(+_), force) : bbox;
  };

  return force;
};

var arrowHead = function (d, nodeTargetSize, bodySize, headSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var headDistance = headSize * 3;

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 - Math.PI / 2;
    var angle2 = angle0 + Math.PI / 2;

    var x1 = d.source.x + headSize * Math.cos(angle1);
    var y1 = d.source.y - headSize * Math.sin(angle1);
    var x2 = d.source.x + headSize * Math.cos(angle2);
    var y2 = d.source.y - headSize * Math.sin(angle2);

    var x3 = d.target.x - headSize * Math.cos(angle1);
    var y3 = d.target.y + headSize * Math.sin(angle1);
    var x4 = d.target.x - headSize * Math.cos(angle2);
    var y4 = d.target.y + headSize * Math.sin(angle2);

    var mx1 = d.source.x + bodySize * Math.cos(angle1);
    var my1 = d.source.y - bodySize * Math.sin(angle1);
    var mx2 = d.source.x + bodySize * Math.cos(angle2);
    var my2 = d.source.y - bodySize * Math.sin(angle2);

    var mx3 = d.target.x + bodySize * Math.cos(angle1);
    var my3 = d.target.y - bodySize * Math.sin(angle1);
    var mx4 = d.target.x + bodySize * Math.cos(angle2);
    var my4 = d.target.y - bodySize * Math.sin(angle2);

    var dY = d.source.y - d.target.y;
    var dX = d.source.x - d.target.x;

    var midDiffY1 = my1 - my3;
    var midDiffX1 = mx1 - mx3;
    var midDiffY2 = my2 - my4;
    var midDiffX2 = mx2 - mx4;

    var diffY1 = y1 - y3;
    var diffX1 = x1 - x3;
    var diffY2 = y2 - y4;
    var diffX2 = x2 - x4;

    var pythag = Math.sqrt(midDiffX1 * midDiffX1 + midDiffY1 * midDiffY1);
    var pythag2 = Math.sqrt(dX * dX + dY * dY);

    var adjX1 = mx2 - midDiffX1 * (pythag - headDistance - nodeTargetSize) / pythag;
    var adjY1 = my2 - midDiffY1 * (pythag - headDistance - nodeTargetSize) / pythag;
    var adjX2 = mx1 - midDiffX2 * (pythag - headDistance - nodeTargetSize) / pythag;
    var adjY2 = my1 - midDiffY2 * (pythag - headDistance - nodeTargetSize) / pythag;

    var headX2 = x1 - diffX2 * (pythag - headDistance - nodeTargetSize) / pythag;
    var headY2 = y1 - diffY2 * (pythag - headDistance - nodeTargetSize) / pythag;
    var headX1 = x2 - diffX1 * (pythag - headDistance - nodeTargetSize) / pythag;
    var headY1 = y2 - diffY1 * (pythag - headDistance - nodeTargetSize) / pythag;

    var tipX = d.source.x - dX * (pythag2 - nodeTargetSize) / pythag2;
    var tipY = d.source.y - dY * (pythag2 - nodeTargetSize) / pythag2;

    return "M" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + headX2 + "," + headY2 + "L" + adjX2 + "," + adjY2 + "L" + mx1 + "," + my1 + "z";
};

var comet = function (d, nodeSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 - Math.PI / 2;
    var angle2 = angle0 + Math.PI / 2;

    var x1 = d.target.x + nodeSize * Math.cos(angle1);
    var y1 = d.target.y - nodeSize * Math.sin(angle1);
    var x2 = d.target.x + nodeSize * Math.cos(angle2);
    var y2 = d.target.y - nodeSize * Math.sin(angle2);

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.source.x + "," + d.source.y + "z";
};

var nail = function (d, nodeSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 - Math.PI / 2;
    var angle2 = angle0 + Math.PI / 2;

    var x1 = d.source.x + nodeSize * Math.cos(angle1);
    var y1 = d.source.y - nodeSize * Math.sin(angle1);
    var x2 = d.source.x + nodeSize * Math.cos(angle2);
    var y2 = d.source.y - nodeSize * Math.sin(angle2);

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + d.target.x + "," + d.target.y + "z";
};

var taffy = function (d, nodeSourceSize, nodeTargetSize, midpointSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 - Math.PI / 2;
    var angle2 = angle0 + Math.PI / 2;

    var x1 = d.source.x + nodeSourceSize * Math.cos(angle1);
    var y1 = d.source.y - nodeSourceSize * Math.sin(angle1);
    var x2 = d.source.x + nodeSourceSize * Math.cos(angle2);
    var y2 = d.source.y - nodeSourceSize * Math.sin(angle2);

    var x3 = d.target.x + nodeTargetSize * Math.cos(angle2);
    var y3 = d.target.y - nodeTargetSize * Math.sin(angle2);
    var x4 = d.target.x + nodeTargetSize * Math.cos(angle1);
    var y4 = d.target.y - nodeTargetSize * Math.sin(angle1);

    var mx1 = d.source.x + midpointSize * Math.cos(angle1);
    var my1 = d.source.y - midpointSize * Math.sin(angle1);
    var mx2 = d.source.x + midpointSize * Math.cos(angle2);
    var my2 = d.source.y - midpointSize * Math.sin(angle2);

    var mx3 = d.target.x + midpointSize * Math.cos(angle1);
    var my3 = d.target.y - midpointSize * Math.sin(angle1);
    var mx4 = d.target.x + midpointSize * Math.cos(angle2);
    var my4 = d.target.y - midpointSize * Math.sin(angle2);

    var midY2 = (my1 + my3) / 2;
    var midX2 = (mx1 + mx3) / 2;
    var midY1 = (my2 + my4) / 2;
    var midX1 = (mx2 + mx4) / 2;

    return "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + " L " + midX1 + "," + midY1 + " L " + x3 + "," + y3 + " L " + x4 + "," + y4 + " L " + midX2 + "," + midY2 + "z";
};

var ribbon = function (d, bodySize) {
        var diffX = d.target.y - d.source.y;
        var diffY = d.target.x - d.source.x;

        var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
        var angle1 = angle0 - Math.PI / 2;
        var angle2 = angle0 + Math.PI / 2;

        var mx1 = d.source.x + bodySize * Math.cos(angle1);
        var my1 = d.source.y - bodySize * Math.sin(angle1);
        var mx2 = d.source.x + bodySize * Math.cos(angle2);
        var my2 = d.source.y - bodySize * Math.sin(angle2);

        var mx3 = d.target.x - bodySize * Math.cos(angle1);
        var my3 = d.target.y + bodySize * Math.sin(angle1);
        var mx4 = d.target.x - bodySize * Math.cos(angle2);
        var my4 = d.target.y + bodySize * Math.sin(angle2);

        return "M" + mx1 + "," + my1 + "L" + mx2 + "," + my2 + "L" + mx3 + "," + my3 + "L" + mx4 + "," + my4 + "z";
};

var lineArc = function (d) {
    var dx = d.target.x - d.source.x,
        dy = d.target.y - d.source.y,
        dr = Math.sqrt(dx * dx + dy * dy);
    return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
};

var halfArrow = function (d, nodeTargetSize, bodySize, headSize) {
    var diffX = d.target.y - d.source.y;
    var diffY = d.target.x - d.source.x;

    var headDistance = headSize * 3;

    var angle0 = Math.atan2(diffY, diffX) + Math.PI / 2;
    var angle1 = angle0 - Math.PI / 2;
    var angle2 = angle0 + Math.PI / 2;

    var x1 = d.source.x + headSize * Math.cos(angle1);
    var y1 = d.source.y - headSize * Math.sin(angle1);
    var x2 = d.source.x + headSize * Math.cos(angle2);
    var y2 = d.source.y - headSize * Math.sin(angle2);
    var x3 = d.target.x - headSize * Math.cos(angle1);
    var y3 = d.target.y + headSize * Math.sin(angle1);

    var mx1 = d.source.x + bodySize * Math.cos(angle1);
    var my1 = d.source.y - bodySize * Math.sin(angle1);
    var mx2 = d.source.x + bodySize * Math.cos(angle2);
    var my2 = d.source.y - bodySize * Math.sin(angle2);

    var mx3 = d.target.x + bodySize * Math.cos(angle1);
    var my3 = d.target.y - bodySize * Math.sin(angle1);

    var dY = d.source.y - d.target.y;
    var dX = d.source.x - d.target.x;

    var midDiffY1 = my1 - my3;
    var midDiffX1 = mx1 - mx3;

    var diffY1 = y1 - y3;
    var diffX1 = x1 - x3;

    var pythag = Math.sqrt(midDiffX1 * midDiffX1 + midDiffY1 * midDiffY1);
    var pythag2 = Math.sqrt(dX * dX + dY * dY);

    var adjX1 = mx2 - midDiffX1 * (pythag - headDistance - nodeTargetSize) / pythag;
    var adjY1 = my2 - midDiffY1 * (pythag - headDistance - nodeTargetSize) / pythag;

    var headX1 = x2 - diffX1 * (pythag - headDistance - nodeTargetSize) / pythag;
    var headY1 = y2 - diffY1 * (pythag - headDistance - nodeTargetSize) / pythag;

    var tipX = d.source.x - dX * (pythag2 - nodeTargetSize) / pythag2;
    var tipY = d.source.y - dY * (pythag2 - nodeTargetSize) / pythag2;

    return "M" + d.source.x + "," + d.source.y + "L" + mx2 + "," + my2 + "L" + adjX1 + "," + adjY1 + "L" + headX1 + "," + headY1 + "L" + tipX + "," + tipY + "L" + d.source.x + "," + d.source.y + "z";
};

var d = {
  arrowHead: arrowHead,
  comet: comet,
  nail: nail,
  taffy: taffy,
  ribbon: ribbon,
  lineArc: lineArc,
  halfArrow: halfArrow
};

var customEdgeHashD = {
  linearc: function linearc(d$$1) {
    return d.lineArc(d$$1);
  },
  ribbon: function ribbon(d$$1) {
    return d.ribbon(d$$1, d$$1.width);
  },
  arrowhead: function arrowhead(d$$1) {
    return d.arrowHead(d$$1, d$$1.target.nodeSize, d$$1.width, d$$1.width * 1.5);
  },
  halfarrow: function halfarrow(d$$1) {
    return d.halfArrow(d$$1, d$$1.target.nodeSize, d$$1.width, d$$1.width * 1.5);
  },
  nail: function nail(d$$1) {
    return d.nail(d$$1, d$$1.source.nodeSize);
  },
  comet: function comet(d$$1) {
    return d.comet(d$$1, d$$1.target.nodeSize);
  },
  taffy: function taffy(d$$1) {
    return d.taffy(d$$1, d$$1.source.nodeSize / 2, d$$1.target.nodeSize / 2, (d$$1.source.nodeSize + d$$1.target.nodeSize) / 4);
  }
};

var circleNodeGenerator = function circleNodeGenerator(_ref) {
  var d$$1 = _ref.d,
      i = _ref.i,
      styleFn = _ref.styleFn,
      renderMode = _ref.renderMode,
      key = _ref.key,
      className = _ref.className,
      transform = _ref.transform,
      baseMarkProps = _ref.baseMarkProps;

  //this is repetitious
  return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
    key: key,
    transform: transform,
    markType: "rect",
    width: d$$1.nodeSize * 2,
    height: d$$1.nodeSize * 2,
    ry: d$$1.nodeSize * 2,
    rx: d$$1.nodeSize * 2,
    x: -d$$1.nodeSize,
    y: -d$$1.nodeSize,
    style: styleFn(d$$1, i),
    renderMode: renderMode ? renderMode(d$$1, i) : undefined,
    className: className
  }));
};

var chordEdgeGenerator = function chordEdgeGenerator(size) {
  return function (_ref2) {
    var d$$1 = _ref2.d,
        i = _ref2.i,
        styleFn = _ref2.styleFn,
        renderMode = _ref2.renderMode,
        key = _ref2.key,
        className = _ref2.className,
        baseMarkProps = _ref2.baseMarkProps;
    return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d$$1, i) : undefined,
      key: key,
      className: className,
      simpleInterpolate: true,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d$$1.d,
      style: styleFn(d$$1, i)
    }));
  };
};

var wordcloudNodeGenerator = function wordcloudNodeGenerator(_ref3) {
  var d$$1 = _ref3.d,
      i = _ref3.i,
      styleFn = _ref3.styleFn,
      key = _ref3.key,
      className = _ref3.className,
      transform = _ref3.transform;

  var textStyle = styleFn(d$$1, i);
  textStyle.fontSize = d$$1.fontSize + "px";
  textStyle.fontWeight = d$$1.fontWeight;
  textStyle.textAnchor = "middle";
  var textTransform = void 0,
      textY = void 0,
      textX = void 0;
  textTransform = "scale(" + d$$1.scale + ")";

  if (!d$$1.rotate) {
    textY = d$$1.textHeight / 4;
    textTransform = "scale(" + d$$1.scale + ")";
  } else {
    textTransform = "rotate(90) scale(" + d$$1.scale + ")";
    textY = d$$1.textHeight / 4;
  }

  return React.createElement(
    "g",
    { key: key, transform: transform },
    React.createElement(
      "text",
      {
        style: textStyle,
        y: textY,
        x: textX,
        transform: textTransform,
        className: className + " wordcloud"
      },
      d$$1._NWFText
    )
  );
};

var sankeyNodeGenerator = function sankeyNodeGenerator(_ref4) {
  var d$$1 = _ref4.d,
      i = _ref4.i,
      styleFn = _ref4.styleFn,
      renderMode = _ref4.renderMode,
      key = _ref4.key,
      className = _ref4.className,
      transform = _ref4.transform,
      baseMarkProps = _ref4.baseMarkProps;
  return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
    renderMode: renderMode ? renderMode(d$$1, i) : undefined,
    key: key,
    className: className,
    transform: transform,
    markType: "rect",
    height: d$$1.height,
    width: d$$1.width,
    x: -d$$1.width / 2,
    y: -d$$1.height / 2,
    rx: 0,
    ry: 0,
    style: styleFn(d$$1)
  }));
};

var chordNodeGenerator = function chordNodeGenerator(size) {
  return function (_ref5) {
    var d$$1 = _ref5.d,
        i = _ref5.i,
        styleFn = _ref5.styleFn,
        renderMode = _ref5.renderMode,
        key = _ref5.key,
        className = _ref5.className,
        baseMarkProps = _ref5.baseMarkProps;
    return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
      renderMode: renderMode ? renderMode(d$$1, i) : undefined,
      key: key,
      className: className,
      transform: "translate(" + size[0] / 2 + "," + size[1] / 2 + ")",
      markType: "path",
      d: d$$1.d,
      style: styleFn(d$$1, i)
    }));
  };
};

var radialRectNodeGenerator = function radialRectNodeGenerator(size, center) {
  var radialArc = arc();
  return function (_ref6) {
    var d$$1 = _ref6.d,
        i = _ref6.i,
        styleFn = _ref6.styleFn,
        renderMode = _ref6.renderMode,
        key = _ref6.key,
        className = _ref6.className,
        baseMarkProps = _ref6.baseMarkProps;

    radialArc.innerRadius(d$$1.y0 / 2).outerRadius(d$$1.y1 / 2);

    return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
      key: key,
      transform: "translate(" + center + ")",
      markType: "path",
      d: radialArc({
        startAngle: d$$1.x0 / size[0] * Math.PI * 2,
        endAngle: d$$1.x1 / size[0] * Math.PI * 2
      }),
      style: styleFn(d$$1, i),
      renderMode: renderMode ? renderMode(d$$1, i) : undefined,
      className: className
    }));
  };
};

var hierarchicalRectNodeGenerator = function hierarchicalRectNodeGenerator(_ref7) {
  var d$$1 = _ref7.d,
      i = _ref7.i,
      styleFn = _ref7.styleFn,
      renderMode = _ref7.renderMode,
      key = _ref7.key,
      className = _ref7.className,
      baseMarkProps = _ref7.baseMarkProps;

  //this is repetitious
  return React.createElement(lib_2$1, _extends({}, baseMarkProps, {
    key: key,
    transform: "translate(0,0)",
    markType: "rect",
    width: d$$1.x1 - d$$1.x0,
    height: d$$1.y1 - d$$1.y0,
    x: d$$1.x0,
    y: d$$1.y0,
    rx: 0,
    ry: 0,
    style: styleFn(d$$1, i),
    renderMode: renderMode ? renderMode(d$$1, i) : undefined,
    className: className
  }));
};

var genericLineGenerator = function genericLineGenerator(d$$1) {
  return "M" + d$$1.source.x + "," + d$$1.source.y + "L" + d$$1.target.x + "," + d$$1.target.y;
};

var drawNodes = function drawNodes(_ref8) {
  var data = _ref8.data,
      renderKeyFn = _ref8.renderKeyFn,
      customMark = _ref8.customMark,
      styleFn = _ref8.styleFn,
      classFn = _ref8.classFn,
      renderMode = _ref8.renderMode,
      canvasDrawing = _ref8.canvasDrawing,
      canvasRenderFn = _ref8.canvasRenderFn,
      baseMarkProps = _ref8.baseMarkProps;

  var markGenerator = customMark || circleNodeGenerator;
  var renderedData = [];

  if (customMark && canvasRenderFn) {
    console.error("canvas rendering currently only supports generic circle nodes based on nodeSize");
  }

  data.forEach(function (d$$1, i) {
    if (canvasRenderFn && canvasRenderFn(d$$1, i) === true) {
      var canvasNode = {
        baseClass: "frame-piece",
        tx: d$$1.x,
        ty: d$$1.y,
        d: d$$1,
        i: i,
        markProps: { markType: "circle", r: d$$1.nodeSize },
        styleFn: styleFn,
        renderFn: renderMode,
        classFn: classFn
      };
      canvasDrawing.push(canvasNode);
    } else {
      renderedData.push(markGenerator({
        d: d$$1,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d$$1, i) : d$$1.id || "node-" + i,
        className: "node " + classFn(d$$1, i),
        transform: "translate(" + d$$1.x + "," + d$$1.y + ")",
        baseMarkProps: baseMarkProps
      }));
    }
  });
  return renderedData;
};

var drawEdges = function drawEdges(_ref9) {
  var data = _ref9.data,
      renderKeyFn = _ref9.renderKeyFn,
      customMark = _ref9.customMark,
      styleFn = _ref9.styleFn,
      classFn = _ref9.classFn,
      renderMode = _ref9.renderMode,
      canvasRenderFn = _ref9.canvasRenderFn,
      canvasDrawing = _ref9.canvasDrawing,
      type = _ref9.type,
      baseMarkProps = _ref9.baseMarkProps;

  var dGenerator = genericLineGenerator;
  var renderedData = [];
  if (customMark) {
    data.forEach(function (d$$1, i) {
      renderedData.push(customMark({
        d: d$$1,
        i: i,
        renderKeyFn: renderKeyFn,
        styleFn: styleFn,
        classFn: classFn,
        renderMode: renderMode,
        key: renderKeyFn ? renderKeyFn(d$$1, i) : "edge-" + i,
        className: classFn(d$$1, i) + " edge",
        transform: "translate(" + d$$1.x + "," + d$$1.y + ")",
        baseMarkProps: baseMarkProps
      }));
    });
  } else {
    if (type) {
      if (typeof type === "function") {
        dGenerator = type;
      } else if (customEdgeHashD[type]) {
        dGenerator = function dGenerator(d$$1) {
          return customEdgeHashD[type](d$$1);
        };
      }
    }
    data.forEach(function (d$$1, i) {
      if (canvasRenderFn && canvasRenderFn(d$$1, i) === true) {
        var canvasNode = {
          baseClass: "frame-piece",
          tx: d$$1.x,
          ty: d$$1.y,
          d: d$$1,
          i: i,
          markProps: { markType: "path", d: dGenerator(d$$1) },
          styleFn: styleFn,
          renderFn: renderMode,
          classFn: classFn
        };
        canvasDrawing.push(canvasNode);
      } else {
        renderedData.push(React.createElement(lib_2$1, _extends({}, baseMarkProps, {
          key: renderKeyFn ? renderKeyFn(d$$1, i) : "edge-" + i,
          markType: "path",
          renderMode: renderMode ? renderMode(d$$1, i) : undefined,
          className: classFn(d$$1) + " edge",
          d: dGenerator(d$$1),
          style: styleFn(d$$1, i)
        })));
      }
    });
  }

  return renderedData;
};

function topologicalSort(nodesArray, edgesArray) {
  // adapted from https://simplapi.wordpress.com/2015/08/19/detect-graph-cycle-in-javascript/
  var nodes = [];
  var nodeHash = {};
  edgesArray.forEach(function (edge) {
    if (!edge.source.id || !edge.target.id) {
      return false;
    }
    if (!nodeHash[edge.source.id]) {
      nodeHash[edge.source.id] = { _id: edge.source.id, links: [] };
      nodes.push(nodeHash[edge.source.id]);
    }
    if (!nodeHash[edge.target.id]) {
      nodeHash[edge.target.id] = { _id: edge.target.id, links: [] };
      nodes.push(nodeHash[edge.target.id]);
    }
    nodeHash[edge.source.id].links.push(edge.target.id);
  });

  // Test if a node got any icoming edge
  function hasIncomingEdge(list, node) {
    for (var i = 0, l = list.length; i < l; ++i) {
      if (list[i].links.indexOf(node._id) !== -1) {
        return true;
      }
    }
    return false;
  }

  // Kahn Algorithm
  var L = [],
      S = nodes.filter(function (node) {
    return !hasIncomingEdge(nodes, node);
  });

  var n = null;

  while (S.length) {
    // Remove a node n from S
    n = S.pop();
    // Add n to tail of L
    L.push(n);

    var i = n.links.length;
    while (i--) {
      // Getting the node associated to the current stored id in links
      var m = nodes[nodes.map(function (d$$1) {
        return d$$1._id;
      }).indexOf(n.links[i])];

      // Remove edge e from the graph
      n.links.pop();

      if (!hasIncomingEdge(nodes, m)) {
        S.push(m);
      }
    }
  }

  // If any of them still got links, there is cycle somewhere
  var nodeWithEdge = nodes.find(function (node) {
    return node.links.length !== 0;
  });

  return nodeWithEdge ? null : L;
}

var ascending$5 = function (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector$1 = function (compare) {
  if (compare.length === 1) compare = ascendingComparator$1(compare);
  return {
    left: function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }
      return lo;
    },
    right: function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator$1(f) {
  return function (d, x) {
    return ascending$5(f(d), x);
  };
}

var ascendingBisect$1 = bisector$1(ascending$5);
var bisectRight$1 = ascendingBisect$1.right;
var bisectLeft$1 = ascendingBisect$1.left;

var pairs$1 = function (array, f) {
  if (f == null) f = pair$1;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);
  while (i < n) {
    pairs[i] = f(p, p = array[++i]);
  }return pairs;
};

function pair$1(a, b) {
  return [a, b];
}

var cross$3 = function (values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair$1;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
};

var descending$5 = function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var number$3 = function (x) {
  return x === null ? NaN : +x;
};

var variance$1 = function (values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
};

var deviation$1 = function (array, f) {
  var v = variance$1(array, f);
  return v ? Math.sqrt(v) : v;
};

var extent$1 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
};

var array$4 = Array.prototype;

var slice$5 = array$4.slice;
var map$4 = array$4.map;

var constant$12 = function (x) {
  return function () {
    return x;
  };
};

var identity$6 = function (x) {
  return x;
};

var range$1 = function (start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10$1 = Math.sqrt(50);
var e5$1 = Math.sqrt(10);
var e2$1 = Math.sqrt(2);

var ticks$1 = function (start, stop, count) {
    var reverse,
        i = -1,
        n,
        ticks,
        step;

    stop = +stop, start = +start, count = +count;
    if (start === stop && count > 0) return [start];
    if (reverse = stop < start) n = start, start = stop, stop = n;
    if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step)) return [];

    if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));
        while (++i < n) {
            ticks[i] = (start + i) * step;
        }
    } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));
        while (++i < n) {
            ticks[i] = (start - i) / step;
        }
    }

    if (reverse) ticks.reverse();

    return ticks;
};

function tickIncrement$1(start, stop, count) {
    var step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log(step) / Math.LN10),
        error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
}

function tickStep$1(start, stop, count) {
    var step0 = Math.abs(stop - start) / Math.max(0, count),
        step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
        error = step0 / step1;
    if (error >= e10$1) step1 *= 10;else if (error >= e5$1) step1 *= 5;else if (error >= e2$1) step1 *= 2;
    return stop < start ? -step1 : step1;
}

var sturges = function (values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram$1 = function () {
  var value = identity$6,
      domain = extent$1,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep$1(x0, x1, tz);
      tz = range$1(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) {
      tz.shift(), --m;
    }while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight$1(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$12(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant$12([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$12(slice$5.call(_)) : constant$12(_), histogram) : threshold;
  };

  return histogram;
};

var quantile$2 = function (values, p, valueof) {
  if (valueof == null) valueof = number$3;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
};

var freedmanDiaconis$1 = function (values, min, max) {
  values = map$4.call(values, number$3).sort(ascending$5);
  return Math.ceil((max - min) / (2 * (quantile$2(values, 0.75) - quantile$2(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

var scott$1 = function (values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation$1(values) * Math.pow(values.length, -1 / 3)));
};

var max$1 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
};

var mean$1 = function (values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
};

var median$1 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile$2(numbers.sort(ascending$5), 0.5);
};

var merge$1 = function (arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) {
    j += arrays[i].length;
  }merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
};

var min$1 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
};

var permute$1 = function (array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);
  while (i--) {
    permutes[i] = array[indexes[i]];
  }return permutes;
};

var scan$1 = function (values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending$5;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
};

var shuffle$2 = function (array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
};

var sum$3 = function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
};

var transpose$1 = function (matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min$1(matrix, length$1), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
};

function length$1(d) {
  return d.length;
}

var zip$1 = function () {
  return transpose$1(arguments);
};



var d3Array = Object.freeze({
	bisect: bisectRight$1,
	bisectRight: bisectRight$1,
	bisectLeft: bisectLeft$1,
	ascending: ascending$5,
	bisector: bisector$1,
	cross: cross$3,
	descending: descending$5,
	deviation: deviation$1,
	extent: extent$1,
	histogram: histogram$1,
	thresholdFreedmanDiaconis: freedmanDiaconis$1,
	thresholdScott: scott$1,
	thresholdSturges: sturges,
	max: max$1,
	mean: mean$1,
	median: median$1,
	merge: merge$1,
	min: min$1,
	pairs: pairs$1,
	permute: permute$1,
	quantile: quantile$2,
	range: range$1,
	scan: scan$1,
	shuffle: shuffle$2,
	sum: sum$3,
	ticks: ticks$1,
	tickIncrement: tickIncrement$1,
	tickStep: tickStep$1,
	transpose: transpose$1,
	variance: variance$1,
	zip: zip$1
});

var prefix$1 = "$";

function Map$5() {}

Map$5.prototype = map$5.prototype = {
  constructor: Map$5,
  has: function has(key) {
    return prefix$1 + key in this;
  },
  get: function get(key) {
    return this[prefix$1 + key];
  },
  set: function set(key, value) {
    this[prefix$1 + key] = value;
    return this;
  },
  remove: function remove(key) {
    var property = prefix$1 + key;
    return property in this && delete this[property];
  },
  clear: function clear() {
    for (var property in this) {
      if (property[0] === prefix$1) delete this[property];
    }
  },
  keys: function keys() {
    var keys = [];
    for (var property in this) {
      if (property[0] === prefix$1) keys.push(property.slice(1));
    }return keys;
  },
  values: function values() {
    var values = [];
    for (var property in this) {
      if (property[0] === prefix$1) values.push(this[property]);
    }return values;
  },
  entries: function entries() {
    var entries = [];
    for (var property in this) {
      if (property[0] === prefix$1) entries.push({ key: property.slice(1), value: this[property] });
    }return entries;
  },
  size: function size() {
    var size = 0;
    for (var property in this) {
      if (property[0] === prefix$1) ++size;
    }return size;
  },
  empty: function empty() {
    for (var property in this) {
      if (property[0] === prefix$1) return false;
    }return true;
  },
  each: function each(f) {
    for (var property in this) {
      if (property[0] === prefix$1) f(this[property], property.slice(1), this);
    }
  }
};

function map$5(object, f) {
  var map = new Map$5();

  // Copy constructor.
  if (object instanceof Map$5) object.each(function (value, key) {
    map.set(key, value);
  });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;

      if (f == null) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f(o = object[i], i, object), o);
      }
    }

    // Convert object to map.
    else if (object) for (var key in object) {
        map.set(key, object[key]);
      }return map;
}

var nest$1 = function () {
  var keys = [],
      _sortKeys = [],
      _sortValues,
      _rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (_sortValues != null) array.sort(_sortValues);
      return _rollup != null ? _rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$5(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function _entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = _sortKeys[depth - 1];
    if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({ key: k, values: _entries(v, depth) });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function object(array) {
      return apply(array, 0, createObject$1, setObject$1);
    },
    map: function map(array) {
      return apply(array, 0, createMap$1, setMap$1);
    },
    entries: function entries(array) {
      return _entries(apply(array, 0, createMap$1, setMap$1), 0);
    },
    key: function key(d) {
      keys.push(d);return nest;
    },
    sortKeys: function sortKeys(order) {
      _sortKeys[keys.length - 1] = order;return nest;
    },
    sortValues: function sortValues(order) {
      _sortValues = order;return nest;
    },
    rollup: function rollup(f) {
      _rollup = f;return nest;
    }
  };
};

function createObject$1() {
  return {};
}

function setObject$1(object, key, value) {
  object[key] = value;
}

function createMap$1() {
  return map$5();
}

function setMap$1(map, key, value) {
  map.set(key, value);
}

function Set$3() {}

var proto$1 = map$5.prototype;

Set$3.prototype = set$6.prototype = {
  constructor: Set$3,
  has: proto$1.has,
  add: function add(value) {
    value += "";
    this[prefix$1 + value] = value;
    return this;
  },
  remove: proto$1.remove,
  clear: proto$1.clear,
  values: proto$1.keys,
  size: proto$1.size,
  empty: proto$1.empty,
  each: proto$1.each
};

function set$6(object, f) {
  var set = new Set$3();

  // Copy constructor.
  if (object instanceof Set$3) object.each(function (value) {
    set.add(value);
  });

  // Otherwise, assume it’s an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) {
        set.add(object[i]);
      } else while (++i < n) {
        set.add(f(object[i], i, object));
      }
    }

  return set;
}

var keys$1 = function (map) {
  var keys = [];
  for (var key in map) {
    keys.push(key);
  }return keys;
};

var values$1 = function (map) {
  var values = [];
  for (var key in map) {
    values.push(map[key]);
  }return values;
};

var entries$1 = function (map) {
  var entries = [];
  for (var key in map) {
    entries.push({ key: key, value: map[key] });
  }return entries;
};



var d3Collection = Object.freeze({
	nest: nest$1,
	set: set$6,
	map: map$5,
	keys: keys$1,
	values: values$1,
	entries: entries$1
});

var align = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.left = left;
  exports.right = right;
  exports.justify = justify;
  exports.center = center;

  // For a given link, return the target node's depth
  function targetDepth(d) {
    return d.target.depth;
  }

  // The depth of a node when the nodeAlign (align) is set to 'left'
  function left(node) {
    return node.depth;
  }

  // The depth of a node when the nodeAlign (align) is set to 'right'
  function right(node, n) {
    return n - 1 - node.height;
  }

  // The depth of a node when the nodeAlign (align) is set to 'justify'
  function justify(node, n) {
    return node.sourceLinks.length ? node.depth : n - 1;
  }

  // The depth of a node when the nodeAlign (align) is set to 'center'
  function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0, d3Array.min)(node.sourceLinks, targetDepth) - 1 : 0;
  }
});

unwrapExports(align);
var align_1 = align.left;
var align_2 = align.right;
var align_3 = align.justify;
var align_4 = align.center;

var constant_1 = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = constant;
  // returns a function, using the parameter given to the sankey setting
  function constant(x) {
    return function () {
      return x;
    };
  }
});

unwrapExports(constant_1);

var constant$14 = function (x) {
  return function constant() {
    return x;
  };
};

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max$2 = Math.max;
var min$2 = Math.min;
var sin = Math.sin;
var sqrt$1 = Math.sqrt;

var epsilon$5 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
}

function asin$2(x) {
  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
}

function arcInnerRadius$2(d) {
  return d.innerRadius;
}

function arcOuterRadius$2(d) {
  return d.outerRadius;
}

function arcStartAngle$2(d) {
  return d.startAngle;
}

function arcEndAngle$2(d) {
  return d.endAngle;
}

function arcPadAngle$2(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect$2(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents$2(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$1(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$1(max$2(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc$2 = function () {
  var innerRadius = arcInnerRadius$2,
      outerRadius = arcOuterRadius$2,
      cornerRadius = constant$14(0),
      padRadius = null,
      startAngle = arcStartAngle$2,
      endAngle = arcEndAngle$2,
      padAngle = arcPadAngle$2,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$3,
        a1 = endAngle.apply(this, arguments) - halfPi$3,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$5)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$4 - epsilon$5) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon$5) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      }

      // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > epsilon$5 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$1(r0 * r0 + r1 * r1)),
              rc = min$2(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon$5) {
            var p0 = asin$2(rp / r0 * sin(ap)),
                p1 = asin$2(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon$5) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon$5) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon$5) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00);

            // Restrict the corner radius according to the sector angle.
            if (da < pi$4) {
              var oc = da0 > epsilon$5 ? intersect$2(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                  ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2),
                  lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min$2(rc, (r0 - lc) / (kc - 1));
              rc1 = min$2(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon$5)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon$5) {
              t0 = cornerTangents$2(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents$2(x11, y11, x10, y10, r1, rc1, cw);

              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon$5) || !(da0 > epsilon$5)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon$5) {
              t0 = cornerTangents$2(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents$2(x01, y01, x00, y00, r0, -rc0, cw);

              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

              // Have the corners merged?
              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

              // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
                }
            }

            // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$14(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$14(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$14(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$14(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$14(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$14(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$14(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
};

function Linear$2(context) {
  this._context = context;
}

Linear$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        this._context.lineTo(x, y);break;
    }
  }
};

var curveLinear$2 = function (context) {
  return new Linear$2(context);
};

function x$5(p) {
  return p[0];
}

function y$5(p) {
  return p[1];
}

var line$2 = function () {
  var x$$1 = x$5,
      y$$1 = y$5,
      defined = constant$14(true),
      context = null,
      curve = curveLinear$2,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$14(+_), line) : x$$1;
  };

  line.y = function (_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$14(+_), line) : y$$1;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$14(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area$3 = function () {
  var x0 = x$5,
      x1 = null,
      y0 = constant$14(0),
      y1 = y$5,
      defined = constant$14(true),
      context = null,
      curve = curveLinear$2,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line$2().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$14(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$14(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$14(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$14(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$14(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$14(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$14(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending$6 = function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity$7 = function (d) {
  return d;
};

var pie$2 = function () {
  var value = identity$7,
      sortValues = descending$6,
      sort = null,
      startAngle = constant$14(0),
      endAngle = constant$14(tau$4),
      padAngle = constant$14(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$14(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$14(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$14(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$14(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear$2 = curveRadial$2(curveLinear$2);

function Radial$2(curve) {
  this._curve = curve;
}

Radial$2.prototype = {
  areaStart: function areaStart() {
    this._curve.areaStart();
  },
  areaEnd: function areaEnd() {
    this._curve.areaEnd();
  },
  lineStart: function lineStart() {
    this._curve.lineStart();
  },
  lineEnd: function lineEnd() {
    this._curve.lineEnd();
  },
  point: function point(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial$2(curve) {

  function radial(context) {
    return new Radial$2(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c(curveRadial$2(_)) : c()._curve;
  };

  return l;
}

var lineRadial$1 = function () {
  return lineRadial(line$2().curve(curveRadialLinear$2));
};

var areaRadial = function () {
  var a = area$3().curve(curveRadialLinear$2),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return lineRadial(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return lineRadial(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return lineRadial(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return lineRadial(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c(curveRadial$2(_)) : c()._curve;
  };

  return a;
};

var pointRadial = function (x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
};

var slice$6 = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x$5,
      y$$1 = y$5,
      context = null;

  function link() {
    var buffer,
        argv = slice$6.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function (_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function (_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function (_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$14(+_), link) : x$$1;
  };

  link.y = function (_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$14(+_), link) : y$$1;
  };

  link.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$3(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$3);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$4 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / pi$4);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$4);
  }
};

var cross$4 = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30$2 = Math.sqrt(1 / 3);
var tan30_2$2 = tan30$2 * 2;

var diamond$2 = {
  draw: function draw(context, size) {
    var y = Math.sqrt(size / tan30_2$2),
        x = y * tan30$2;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka$2 = 0.89081309152928522810;
var kr$2 = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);
var kx$2 = Math.sin(tau$4 / 10) * kr$2;
var ky$2 = -Math.cos(tau$4 / 10) * kr$2;

var star$2 = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size * ka$2),
            x = kx$2 * r,
            y = ky$2 * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
            var a = tau$4 * i / 5,
                c = Math.cos(a),
                s = Math.sin(a);
            context.lineTo(s * r, -c * r);
            context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
    }
};

var square$2 = {
  draw: function draw(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3$2 = Math.sqrt(3);

var triangle$2 = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3$2 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3$2 * y, -y);
    context.lineTo(sqrt3$2 * y, -y);
    context.closePath();
  }
};

var c$2 = -0.5;
var s$2 = Math.sqrt(3) / 2;
var k$2 = 1 / Math.sqrt(12);
var a$2 = (k$2 / 2 + 1) * 3;

var wye$2 = {
    draw: function draw(context, size) {
        var r = Math.sqrt(size / a$2),
            x0 = r / 2,
            y0 = r * k$2,
            x1 = x0,
            y1 = r * k$2 + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c$2 * x0 - s$2 * y0, s$2 * x0 + c$2 * y0);
        context.lineTo(c$2 * x1 - s$2 * y1, s$2 * x1 + c$2 * y1);
        context.lineTo(c$2 * x2 - s$2 * y2, s$2 * x2 + c$2 * y2);
        context.lineTo(c$2 * x0 + s$2 * y0, c$2 * y0 - s$2 * x0);
        context.lineTo(c$2 * x1 + s$2 * y1, c$2 * y1 - s$2 * x1);
        context.lineTo(c$2 * x2 + s$2 * y2, c$2 * y2 - s$2 * x2);
        context.closePath();
    }
};

var symbols$2 = [circle$4, cross$4, diamond$2, square$2, star$2, triangle$2, wye$2];

var symbol$2 = function () {
  var type = constant$14(circle$4),
      size = constant$14(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$14(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$14(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop$5 = function () {};

function _point$8(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis$2(context) {
  this._context = context;
}

Basis$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 3:
        _point$8(this, this._x1, this._y1); // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default:
        _point$8(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis$4 = function (context) {
  return new Basis$2(context);
};

function BasisClosed$2(context) {
  this._context = context;
}

BasisClosed$2.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x2 = x, this._y2 = y;break;
      case 1:
        this._point = 2;this._x3 = x, this._y3 = y;break;
      case 2:
        this._point = 3;this._x4 = x, this._y4 = y;this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);break;
      default:
        _point$8(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed$3 = function (context) {
  return new BasisClosed$2(context);
};

function BasisOpen$2(context) {
  this._context = context;
}

BasisOpen$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$8(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen$2 = function (context) {
  return new BasisOpen$2(context);
};

function Bundle$2(context, beta) {
  this._basis = new Basis$2(context);
  this._beta = beta;
}

Bundle$2.prototype = {
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle$2 = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis$2(context) : new Bundle$2(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function _point$9(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal$2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        _point$9(this, this._x1, this._y1);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;this._x1 = x, this._y1 = y;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$9(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal$2 = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal$2(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed$2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed$2.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$9(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed$2 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed$2(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen$2(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$9(this, x, y);break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen$2 = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen$2(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function _point$10(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$5) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$5) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom$2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);break;
      case 3:
        this.point(this._x2, this._y2);break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3; // proceed
      default:
        _point$10(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom$1 = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom$2(context, alpha) : new Cardinal$2(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed$2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed$2.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 2:
        {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;this._x3 = x, this._y3 = y;break;
      case 1:
        this._point = 2;this._context.moveTo(this._x4 = x, this._y4 = y);break;
      case 2:
        this._point = 3;this._x5 = x, this._y5 = y;break;
      default:
        _point$10(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed$2 = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed$2(context, alpha) : new CardinalClosed$2(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen$2(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point$$1(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);break;
      case 3:
        this._point = 4; // proceed
      default:
        _point$10(this, x, y);break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen$2 = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen$2(context, alpha) : new CardinalOpen$2(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed$2(context) {
  this._context = context;
}

LinearClosed$2.prototype = {
  areaStart: noop$5,
  areaEnd: noop$5,
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._point) this._context.closePath();
  },
  point: function point(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

var linearClosed$1 = function (context) {
  return new LinearClosed$2(context);
};

function sign$2(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3$2(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2$2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function _point$11(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX$2(context) {
  this._context = context;
}

MonotoneX$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);break;
      case 3:
        _point$11(this, this._t0, slope2$2(this, this._t0));break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2;break;
      case 2:
        this._point = 3;_point$11(this, slope2$2(this, t1 = slope3$2(this, x, y)), t1);break;
      default:
        _point$11(this, this._t0, t1 = slope3$2(this, x, y));break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY$2(context) {
  this._context = new ReflectContext$2(context);
}

(MonotoneY$2.prototype = Object.create(MonotoneX$2.prototype)).point = function (x, y) {
  MonotoneX$2.prototype.point.call(this, y, x);
};

function ReflectContext$2(context) {
  this._context = context;
}

ReflectContext$2.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX$2(context) {
  return new MonotoneX$2(context);
}

function monotoneY$2(context) {
  return new MonotoneY$2(context);
}

function Natural$2(context) {
  this._context = context;
}

Natural$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints$2(x),
            py = controlPoints$2(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function point(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints$2(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) {
    a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  }a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) {
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  }a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) {
    a[i] = (r[i] - a[i + 1]) / b[i];
  }b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) {
    b[i] = 2 * x[i + 1] - a[i + 1];
  }return [a, b];
}

var natural$2 = function (context) {
  return new Natural$2(context);
};

function Step$2(context, t) {
  this._context = context;
  this._t = t;
}

Step$2.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0:
        this._point = 1;this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);break;
      case 1:
        this._point = 2; // proceed
      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);
            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;
            this._context.lineTo(x1, this._y);
            this._context.lineTo(x1, y);
          }
          break;
        }
    }
    this._x = x, this._y = y;
  }
};

var step$2 = function (context) {
  return new Step$2(context, 0.5);
};

function stepBefore$2(context) {
  return new Step$2(context, 0);
}

function stepAfter$2(context) {
  return new Step$2(context, 1);
}

var none$5 = function (series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$6 = function (series) {
  var n = series.length,
      o = new Array(n);
  while (--n >= 0) {
    o[n] = n;
  }return o;
};

function stackValue$2(d, key) {
  return d[key];
}

var stack$2 = function () {
  var keys = constant$14([]),
      order = none$6,
      offset = none$5,
      value = stackValue$2;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$14(slice$6.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$14(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? none$6 : typeof _ === "function" ? _ : constant$14(slice$6.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? none$5 : _, stack) : offset;
  };

  return stack;
};

var expand$2 = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }if (y) for (i = 0; i < n; ++i) {
      series[i][j][1] /= y;
    }
  }
  none$5(series, order);
};

var diverging = function (series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
};

var silhouette$2 = function (series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }s0[j][1] += s0[j][0] = -y / 2;
  }
  none$5(series, order);
};

var wiggle$2 = function (series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$5(series, order);
};

var ascending$6 = function (series) {
  var sums = series.map(sum$4);
  return none$6(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
};

function sum$4(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;
  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }return s;
}

var descending$7 = function (series) {
  return ascending$6(series).reverse();
};

var insideOut$2 = function (series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$4),
      order = none$6(series).sort(function (a, b) {
    return sums[b] - sums[a];
  }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse$2 = function (series) {
  return none$6(series).reverse();
};



var d3Shape$2 = Object.freeze({
	arc: arc$2,
	area: area$3,
	line: line$2,
	pie: pie$2,
	areaRadial: areaRadial,
	radialArea: areaRadial,
	lineRadial: lineRadial$1,
	radialLine: lineRadial$1,
	pointRadial: pointRadial,
	linkHorizontal: linkHorizontal,
	linkVertical: linkVertical,
	linkRadial: linkRadial,
	symbol: symbol$2,
	symbols: symbols$2,
	symbolCircle: circle$4,
	symbolCross: cross$4,
	symbolDiamond: diamond$2,
	symbolSquare: square$2,
	symbolStar: star$2,
	symbolTriangle: triangle$2,
	symbolWye: wye$2,
	curveBasisClosed: basisClosed$3,
	curveBasisOpen: basisOpen$2,
	curveBasis: basis$4,
	curveBundle: bundle$2,
	curveCardinalClosed: cardinalClosed$2,
	curveCardinalOpen: cardinalOpen$2,
	curveCardinal: cardinal$2,
	curveCatmullRomClosed: catmullRomClosed$2,
	curveCatmullRomOpen: catmullRomOpen$2,
	curveCatmullRom: catmullRom$1,
	curveLinearClosed: linearClosed$1,
	curveLinear: curveLinear$2,
	curveMonotoneX: monotoneX$2,
	curveMonotoneY: monotoneY$2,
	curveNatural: natural$2,
	curveStep: step$2,
	curveStepAfter: stepAfter$2,
	curveStepBefore: stepBefore$2,
	stack: stack$2,
	stackOffsetExpand: expand$2,
	stackOffsetDiverging: diverging,
	stackOffsetNone: none$5,
	stackOffsetSilhouette: silhouette$2,
	stackOffsetWiggle: wiggle$2,
	stackOrderAscending: ascending$6,
	stackOrderDescending: descending$7,
	stackOrderInsideOut: insideOut$2,
	stackOrderNone: none$6,
	stackOrderReverse: reverse$2
});

var sankeyCircular = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function () {
    // Set the default values
    var x0 = 0,
        y0 = 0,
        x1 = 1,
        y1 = 1,

    // extent
    dx = 24,

    // nodeWidth
    py,

    // nodePadding, for vertical postioning
    id = defaultId,
        align$$1 = align.justify,
        nodes = defaultNodes,
        links = defaultLinks,
        iterations = 32,
        circularLinkGap = 2,
        paddingRatio;

    function sankeyCircular() {
      var graph = {
        nodes: nodes.apply(null, arguments),
        links: links.apply(null, arguments)

        // Process the graph's nodes and links, setting their positions

        // 1.  Associate the nodes with their respective links, and vice versa
      };computeNodeLinks(graph);

      // 2.  Determine which links result in a circular path in the graph
      identifyCircles(graph, id);

      // 3.  Determine how the circular links will be drawn,
      //     either travelling back above the main chart ("top")
      //     or below the main chart ("bottom")
      selectCircularLinkTypes(graph, id);

      // 4. Calculate the nodes' values, based on the values of the incoming and outgoing links
      computeNodeValues(graph);

      // 5.  Calculate the nodes' depth based on the incoming and outgoing links
      //     Sets the nodes':
      //     - depth:  the depth in the graph
      //     - column: the depth (0, 1, 2, etc), as is relates to visual position from left to right
      //     - x0, x1: the x coordinates, as is relates to visual position from left to right
      computeNodeDepths(graph);

      // 6.  Calculate the nodes' and links' vertical position within their respective column
      //     Also readjusts sankeyCircular size if circular links are needed, and node x's
      computeNodeBreadths(graph, iterations, id);
      computeLinkBreadths(graph);

      // 7.  Sort links per node, based on the links' source/target nodes' breadths
      // 8.  Adjust nodes that overlap links that span 2+ columns

      var linkSortingIterations = 4; //Possibly let user control this number, like the iterations over node placement
      for (var iteration = 0; iteration < linkSortingIterations; iteration++) {

        sortSourceLinks(graph, y1, id);
        sortTargetLinks(graph, y1, id);
        resolveNodeLinkOverlaps(graph, y0, y1, id);
        sortSourceLinks(graph, y1, id);
        sortTargetLinks(graph, y1, id);
      }

      // 9. Calculate visually appealling path for the circular paths, and create the "d" string
      addCircularPathData(graph, circularLinkGap, y1, id);

      return graph;
    } // end of sankeyCircular function

    // TODO - update this function to take into account circular changes
    /*sankeyCircular.update = function (graph) {
      computeLinkBreadths(graph)
      return graph
    }*/

    // Set the sankeyCircular parameters
    // nodeID, nodeAlign, nodeWidth, nodePadding, nodes, links, size, extent, iterations, nodePaddingRatio, circularLinkGap
    sankeyCircular.nodeId = function (_) {
      return arguments.length ? (id = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : id;
    };

    sankeyCircular.nodeAlign = function (_) {
      return arguments.length ? (align$$1 = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : align$$1;
    };

    sankeyCircular.nodeWidth = function (_) {
      return arguments.length ? (dx = +_, sankeyCircular) : dx;
    };

    sankeyCircular.nodePadding = function (_) {
      return arguments.length ? (py = +_, sankeyCircular) : py;
    };

    sankeyCircular.nodes = function (_) {
      return arguments.length ? (nodes = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : nodes;
    };

    sankeyCircular.links = function (_) {
      return arguments.length ? (links = typeof _ === 'function' ? _ : (0, _constant2.default)(_), sankeyCircular) : links;
    };

    sankeyCircular.size = function (_) {
      return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankeyCircular) : [x1 - x0, y1 - y0];
    };

    sankeyCircular.extent = function (_) {
      return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankeyCircular) : [[x0, y0], [x1, y1]];
    };

    sankeyCircular.iterations = function (_) {
      return arguments.length ? (iterations = +_, sankeyCircular) : iterations;
    };

    sankeyCircular.circularLinkGap = function (_) {
      return arguments.length ? (circularLinkGap = +_, sankeyCircular) : circularLinkGap;
    };

    sankeyCircular.nodePaddingRatio = function (_) {
      return arguments.length ? (paddingRatio = +_, sankeyCircular) : paddingRatio;
    };

    // Populate the sourceLinks and targetLinks for each node.
    // Also, if the source and target are not objects, assume they are indices.
    function computeNodeLinks(graph) {
      graph.nodes.forEach(function (node, i) {
        node.index = i;
        node.sourceLinks = [];
        node.targetLinks = [];
      });
      var nodeById = (0, d3Collection.map)(graph.nodes, id);
      graph.links.forEach(function (link, i) {
        link.index = i;
        var source = link.source;
        var target = link.target;
        if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) !== 'object') {
          source = link.source = find(nodeById, source);
        }
        if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== 'object') {
          target = link.target = find(nodeById, target);
        }
        source.sourceLinks.push(link);
        target.targetLinks.push(link);
      });
    }

    // Compute the value (size) and cycleness of each node by summing the associated links.
    function computeNodeValues(graph) {
      graph.nodes.forEach(function (node) {
        node.partOfCycle = false;
        node.value = Math.max((0, d3Array.sum)(node.sourceLinks, value), (0, d3Array.sum)(node.targetLinks, value));
        node.sourceLinks.forEach(function (link) {
          if (link.circular) {
            node.partOfCycle = true;
            node.circularLinkType = link.circularLinkType;
          }
        });
        node.targetLinks.forEach(function (link) {
          if (link.circular) {
            node.partOfCycle = true;
            node.circularLinkType = link.circularLinkType;
          }
        });
      });
    }

    function getCircleMargins(graph) {
      var totalTopLinksWidth = 0,
          totalBottomLinksWidth = 0,
          totalRightLinksWidth = 0,
          totalLeftLinksWidth = 0;

      var maxColumn = (0, d3Array.max)(graph.nodes, function (node) {
        return node.column;
      });

      graph.links.forEach(function (link) {
        if (link.circular) {
          if (link.circularLinkType == 'top') {
            totalTopLinksWidth = totalTopLinksWidth + link.width;
          } else {
            totalBottomLinksWidth = totalBottomLinksWidth + link.width;
          }

          if (link.target.column == 0) {
            totalLeftLinksWidth = totalLeftLinksWidth + link.width;
          }

          if (link.source.column == maxColumn) {
            totalRightLinksWidth = totalRightLinksWidth + link.width;
          }
        }
      });

      //account for radius of curves and padding between links
      totalTopLinksWidth = totalTopLinksWidth > 0 ? totalTopLinksWidth + verticalMargin + baseRadius : totalTopLinksWidth;
      totalBottomLinksWidth = totalBottomLinksWidth > 0 ? totalBottomLinksWidth + verticalMargin + baseRadius : totalBottomLinksWidth;
      totalRightLinksWidth = totalRightLinksWidth > 0 ? totalRightLinksWidth + verticalMargin + baseRadius : totalRightLinksWidth;
      totalLeftLinksWidth = totalLeftLinksWidth > 0 ? totalLeftLinksWidth + verticalMargin + baseRadius : totalLeftLinksWidth;

      return { "top": totalTopLinksWidth, "bottom": totalBottomLinksWidth, "left": totalLeftLinksWidth, "right": totalRightLinksWidth };
    }

    // Update the x0, y0, x1 and y1 for the sankeyCircular, to allow space for any circular links
    function scaleSankeySize(graph, margin) {

      var maxColumn = (0, d3Array.max)(graph.nodes, function (node) {
        return node.column;
      });

      var currentWidth = x1 - x0;
      var currentHeight = y1 - y0;

      var newWidth = currentWidth + margin.right + margin.left;
      var newHeight = currentHeight + margin.top + margin.bottom;

      var scaleX = currentWidth / newWidth;
      var scaleY = currentHeight / newHeight;

      x0 = x0 * scaleX + margin.left;
      x1 = margin.right == 0 ? x1 : x1 * scaleX;
      y0 = y0 * scaleY + margin.top;
      y1 = y1 * scaleY;

      graph.nodes.forEach(function (node) {
        node.x0 = x0 + node.column * ((x1 - x0 - dx) / maxColumn);
        node.x1 = node.x0 + dx;
      });

      return scaleY;
    }

    // Iteratively assign the depth for each node.
    // Nodes are assigned the maximum depth of incoming neighbors plus one;
    // nodes with no incoming links are assigned depth zero, while
    // nodes with no outgoing links are assigned the maximum depth.
    function computeNodeDepths(graph) {
      var nodes, next, x;

      for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
        nodes.forEach(function (node) {
          node.depth = x;
          node.sourceLinks.forEach(function (link) {
            if (next.indexOf(link.target) < 0 && !link.circular) {
              next.push(link.target);
            }
          });
        });
      }

      for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {
        nodes.forEach(function (node) {
          node.height = x;
          node.targetLinks.forEach(function (link) {
            if (next.indexOf(link.source) < 0 && !link.circular) {
              next.push(link.source);
            }
          });
        });
      }

      // assign column numbers, and get max value
      graph.nodes.forEach(function (node) {
        node.column = Math.floor(align$$1.call(null, node, x));
      });
    }

    // Assign nodes' breadths, and then shift nodes that overlap (resolveCollisions)
    function computeNodeBreadths(graph, iterations, id) {
      var columns = (0, d3Collection.nest)().key(function (d) {
        return d.column;
      }).sortKeys(d3Array.ascending).entries(graph.nodes).map(function (d) {
        return d.values;
      });

      initializeNodeBreadth(id);
      resolveCollisions();

      for (var alpha = 1, n = iterations; n > 0; --n) {
        relaxLeftAndRight(alpha *= 0.99, id);
        resolveCollisions();
      }

      function initializeNodeBreadth(id) {

        //override py if nodePadding has been set
        if (paddingRatio) {
          var padding = Infinity;
          columns.forEach(function (nodes) {
            var thisPadding = y1 * paddingRatio / (nodes.length + 1);
            padding = thisPadding < padding ? thisPadding : padding;
          });
          py = padding;
        }

        var ky = (0, d3Array.min)(columns, function (nodes) {
          return (y1 - y0 - (nodes.length - 1) * py) / (0, d3Array.sum)(nodes, value);
        });

        //calculate the widths of the links
        ky = ky * scale;

        graph.links.forEach(function (link) {
          link.width = link.value * ky;
        });

        //determine how much to scale down the chart, based on circular links
        var margin = getCircleMargins(graph);
        var ratio = scaleSankeySize(graph, margin);

        //re-calculate widths
        ky = ky * ratio;

        graph.links.forEach(function (link) {
          link.width = link.value * ky;
        });

        columns.forEach(function (nodes) {
          var nodesLength = nodes.length;
          nodes.forEach(function (node, i) {
            if (node.partOfCycle) {
              if (numberOfNonSelfLinkingCycles(node, id) == 0) {
                node.y0 = y1 / 2 + i;
                node.y1 = node.y0 + node.value * ky;
              } else if (node.circularLinkType == 'top') {
                node.y0 = y0 + i;
                node.y1 = node.y0 + node.value * ky;
              } else {
                node.y0 = y1 - node.value * ky - i;
                node.y1 = node.y0 + node.value * ky;
              }
            } else {
              if (margin.top == 0 || margin.bottom == 0) {
                node.y0 = (y1 - y0) / nodesLength * i;
                node.y1 = node.y0 + node.value * ky;
              } else {
                node.y0 = (y1 - y0) / 2 - nodesLength / 2 + i;
                node.y1 = node.y0 + node.value * ky;
              }
            }
          });
        });
      }

      // For each node in each column, check the node's vertical position in relation to its targets and sources vertical position
      // and shift up/down to be closer to the vertical middle of those targets and sources
      function relaxLeftAndRight(alpha, id) {
        var columnsLength = columns.length;

        columns.forEach(function (nodes, i) {
          var n = nodes.length;
          var depth = nodes[0].depth;

          nodes.forEach(function (node) {
            // check the node is not an orphan
            if (node.sourceLinks.length || node.targetLinks.length) {
              if (node.partOfCycle && numberOfNonSelfLinkingCycles(node, id) > 0) {} else if (depth == 0 && n == 1) {
                var nodeHeight = node.y1 - node.y0;

                node.y0 = y1 / 2 - nodeHeight / 2;
                node.y1 = y1 / 2 + nodeHeight / 2;
              } else if (depth == columnsLength - 1 && n == 1) {
                var nodeHeight = node.y1 - node.y0;

                node.y0 = y1 / 2 - nodeHeight / 2;
                node.y1 = y1 / 2 + nodeHeight / 2;
              } else {
                var avg = 0;

                var avgTargetY = (0, d3Array.mean)(node.sourceLinks, linkTargetCenter);
                var avgSourceY = (0, d3Array.mean)(node.targetLinks, linkSourceCenter);

                if (avgTargetY && avgSourceY) {
                  avg = (avgTargetY + avgSourceY) / 2;
                } else {
                  avg = avgTargetY || avgSourceY;
                }

                var dy = (avg - nodeCenter(node)) * alpha;
                // positive if it node needs to move down
                node.y0 += dy;
                node.y1 += dy;
              }
            }
          });
        });
      }

      // For each column, check if nodes are overlapping, and if so, shift up/down
      function resolveCollisions() {
        columns.forEach(function (nodes) {
          var node,
              dy,
              y = y0,
              n = nodes.length,
              i;

          // Push any overlapping nodes down.
          nodes.sort(ascendingBreadth);

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dy = y - node.y0;

            if (dy > 0) {
              node.y0 += dy;
              node.y1 += dy;
            }
            y = node.y1 + py;
          }

          // If the bottommost node goes outside the bounds, push it back up.
          dy = y - py - y1;
          if (dy > 0) {
            y = node.y0 -= dy, node.y1 -= dy;

            // Push any overlapping nodes back up.
            for (i = n - 2; i >= 0; --i) {
              node = nodes[i];
              dy = node.y1 + py - y;
              if (dy > 0) node.y0 -= dy, node.y1 -= dy;
              y = node.y0;
            }
          }
        });
      }
    }

    // Assign the links y0 and y1 based on source/target nodes position,
    // plus the link's relative position to other links to the same node
    function computeLinkBreadths(graph) {
      graph.nodes.forEach(function (node) {
        node.sourceLinks.sort(ascendingTargetBreadth);
        node.targetLinks.sort(ascendingSourceBreadth);
      });
      graph.nodes.forEach(function (node) {
        var y0 = node.y0;
        var y1 = y0;

        // start from the bottom of the node for cycle links
        var y0cycle = node.y1;
        var y1cycle = y0cycle;

        node.sourceLinks.forEach(function (link) {
          if (link.circular) {
            link.y0 = y0cycle - link.width / 2;
            y0cycle = y0cycle - link.width;
          } else {
            link.y0 = y0 + link.width / 2;
            y0 += link.width;
          }
        });
        node.targetLinks.forEach(function (link) {
          if (link.circular) {
            link.y1 = y1cycle - link.width / 2;
            y1cycle = y1cycle - link.width;
          } else {
            link.y1 = y1 + link.width / 2;
            y1 += link.width;
          }
        });
      });
    }

    return sankeyCircular;
  };

  var _constant2 = _interopRequireDefault(constant_1);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  // sort links' breadth (ie top to bottom in a column), based on their source nodes' breadths
  function ascendingSourceBreadth(a, b) {
    return ascendingBreadth(a.source, b.source) || a.index - b.index;
  }

  // sort links' breadth (ie top to bottom in a column), based on their target nodes' breadths
  // https://github.com/tomshanley/d3-sankeyCircular-circular
  // fork of https://github.com/d3/d3-sankeyCircular copyright Mike Bostock
  function ascendingTargetBreadth(a, b) {
    return ascendingBreadth(a.target, b.target) || a.index - b.index;
  }

  // sort nodes' breadth (ie top to bottom in a column)
  // if both nodes have circular links, or both don't have circular links, then sort by the top (y0) of the node
  // else push nodes that have top circular links to the top, and nodes that have bottom circular links to the bottom
  function ascendingBreadth(a, b) {
    if (a.partOfCycle === b.partOfCycle) {
      return a.y0 - b.y0;
    } else {
      if (a.circularLinkType === 'top' || b.circularLinkType === 'bottom') {
        return -1;
      } else {
        return 1;
      }
    }
  }

  // return the value of a node or link
  function value(d) {
    return d.value;
  }

  // return the vertical center of a node
  function nodeCenter(node) {
    return (node.y0 + node.y1) / 2;
  }

  // return the vertical center of a link's source node
  function linkSourceCenter(link) {
    return nodeCenter(link.source);
  }

  // return the vertical center of a link's target node
  function linkTargetCenter(link) {
    return nodeCenter(link.target);
  }

  /* function weightedSource (link) {
    return nodeCenter(link.source) * link.value
  } */

  /* function weightedTarget (link) {
    return nodeCenter(link.target) * link.value
  } */

  // Return the default value for ID for node, d.index
  function defaultId(d) {
    return d.index;
  }

  // Return the default object the graph's nodes, graph.nodes
  function defaultNodes(graph) {
    return graph.nodes;
  }

  // Return the default object the graph's nodes, graph.links
  function defaultLinks(graph) {
    return graph.links;
  }

  // Return the node from the collection that matches the provided ID, or throw an error if no match
  function find(nodeById, id) {
    var node = nodeById.get(id);
    if (!node) throw new Error('missing: ' + id);
    return node;
  }

  function getNodeID(node, id) {
    return id(node);
  }

  // The main sankeyCircular functions

  // Some constants for circular link calculations
  var verticalMargin = 25;
  var baseRadius = 10;
  var scale = 0.3; //Possibly let user control this, although anything over 0.5 starts to get too cramped

  /// /////////////////////////////////////////////////////////////////////////////////
  // Cycle functions
  // portion of code to detect circular links based on Colin Fergus' bl.ock https://gist.github.com/cfergus/3956043

  // Identify circles in the link objects
  function identifyCircles(graph, id) {
    var addedLinks = [];
    var circularLinkID = 0;
    graph.links.forEach(function (link) {
      if (createsCycle(link.source, link.target, addedLinks, id)) {
        link.circular = true;
        link.circularLinkID = circularLinkID;
        circularLinkID = circularLinkID + 1;
      } else {
        link.circular = false;
        addedLinks.push(link);
      }
    });
  }

  // Assign a circular link type (top or bottom), based on:
  // - if the source/target node already has circular links, then use the same type
  // - if not, choose the type with fewer links
  function selectCircularLinkTypes(graph, id) {
    var numberOfTops = 0;
    var numberOfBottoms = 0;
    graph.links.forEach(function (link) {
      if (link.circular) {
        // if either souce or target has type already use that
        if (link.source.circularLinkType || link.target.circularLinkType) {
          // default to source type if available
          link.circularLinkType = link.source.circularLinkType ? link.source.circularLinkType : link.target.circularLinkType;
        } else {
          link.circularLinkType = numberOfTops < numberOfBottoms ? 'top' : 'bottom';
        }

        if (link.circularLinkType == 'top') {
          numberOfTops = numberOfTops + 1;
        } else {
          numberOfBottoms = numberOfBottoms + 1;
        }

        graph.nodes.forEach(function (node) {
          if (getNodeID(node, id) == getNodeID(link.source, id) || getNodeID(node, id) == getNodeID(link.target, id)) {
            node.circularLinkType = link.circularLinkType;
          }
        });
      }
    });

    //correct self-linking links to be same direction as node
    graph.links.forEach(function (link) {
      if (link.circular) {
        //if both source and target node are same type, then link should have same type
        if (link.source.circularLinkType == link.target.circularLinkType) {
          link.circularLinkType = link.source.circularLinkType;
        }
        //if link is selflinking, then link should have same type as node
        if (selfLinking(link, id)) {
          link.circularLinkType = link.source.circularLinkType;
        }
      }
    });
  }

  // Checks if link creates a cycle
  function createsCycle(originalSource, nodeToCheck, graph, id) {

    // Check for self linking nodes
    if (getNodeID(originalSource, id) == getNodeID(nodeToCheck, id)) {
      return true;
    }

    if (graph.length == 0) {
      return false;
    }

    var nextLinks = findLinksOutward(nodeToCheck, graph);
    // leaf node check
    if (nextLinks.length == 0) {
      return false;
    }

    // cycle check
    for (var i = 0; i < nextLinks.length; i++) {
      var nextLink = nextLinks[i];

      if (nextLink.target === originalSource) {
        return true;
      }

      // Recurse
      if (createsCycle(originalSource, nextLink.target, graph, id)) {
        return true;
      }
    }

    // Exhausted all links
    return false;
  }

  // Given a node, find all links for which this is a source in the current 'known' graph
  function findLinksOutward(node, graph) {
    var children = [];

    for (var i = 0; i < graph.length; i++) {
      if (node == graph[i].source) {
        children.push(graph[i]);
      }
    }

    return children;
  }

  // Return the angle between a straight line between the source and target of the link, and the vertical plane of the node
  function linkAngle(link) {
    var adjacent = Math.abs(link.y1 - link.y0);
    var opposite = Math.abs(link.target.x0 - link.source.x1);

    return Math.atan(opposite / adjacent);
  }

  // Check if two circular links potentially overlap
  function circularLinksCross(link1, link2) {
    if (link1.source.column < link2.target.column) {
      return false;
    } else if (link1.target.column > link2.source.column) {
      return false;
    } else {
      return true;
    }
  }

  // Return the number of circular links for node, not including self linking links
  function numberOfNonSelfLinkingCycles(node, id) {
    var sourceCount = 0;
    node.sourceLinks.forEach(function (l) {
      sourceCount = l.circular && !selfLinking(l, id) ? sourceCount + 1 : sourceCount;
    });

    var targetCount = 0;
    node.targetLinks.forEach(function (l) {
      targetCount = l.circular && !selfLinking(l, id) ? targetCount + 1 : targetCount;
    });

    return sourceCount + targetCount;
  }

  // Check if a circular link is the only circular link for both its source and target node
  function onlyCircularLink(link) {
    var nodeSourceLinks = link.source.sourceLinks;
    var sourceCount = 0;
    nodeSourceLinks.forEach(function (l) {
      sourceCount = l.circular ? sourceCount + 1 : sourceCount;
    });

    var nodeTargetLinks = link.target.targetLinks;
    var targetCount = 0;
    nodeTargetLinks.forEach(function (l) {
      targetCount = l.circular ? targetCount + 1 : targetCount;
    });

    if (sourceCount > 1 || targetCount > 1) {
      return false;
    } else {
      return true;
    }
  }

  // creates vertical buffer values per set of top/bottom links
  function calcVerticalBuffer(links, circularLinkGap, id) {
    links.sort(sortLinkColumnAscending);
    links.forEach(function (link, i) {
      var buffer = 0;

      if (selfLinking(link, id) && onlyCircularLink(link)) {
        link.circularPathData.verticalBuffer = buffer + link.width / 2;
      } else {
        var j = 0;
        for (j; j < i; j++) {
          if (circularLinksCross(links[i], links[j])) {
            var bufferOverThisLink = links[j].circularPathData.verticalBuffer + links[j].width / 2 + circularLinkGap;
            buffer = bufferOverThisLink > buffer ? bufferOverThisLink : buffer;
          }
        }

        link.circularPathData.verticalBuffer = buffer + link.width / 2;
      }
    });

    return links;
  }

  // calculate the optimum path for a link to reduce overlaps
  function addCircularPathData(graph, circularLinkGap, y1, id) {
    //var baseRadius = 10
    var buffer = 5;
    //var verticalMargin = 25

    var minY = (0, d3Array.min)(graph.links, function (link) {
      return link.source.y0;
    });

    // create object for circular Path Data
    graph.links.forEach(function (link) {
      if (link.circular) {
        link.circularPathData = {};
      }
    });

    // calc vertical offsets per top/bottom links
    var topLinks = graph.links.filter(function (l) {
      return l.circularLinkType == 'top';
    });
    topLinks = calcVerticalBuffer(topLinks, circularLinkGap, id);

    var bottomLinks = graph.links.filter(function (l) {
      return l.circularLinkType == 'bottom';
    });
    bottomLinks = calcVerticalBuffer(bottomLinks, circularLinkGap, id);

    // add the base data for each link
    graph.links.forEach(function (link) {
      if (link.circular) {
        link.circularPathData.arcRadius = link.width + baseRadius;
        link.circularPathData.leftNodeBuffer = buffer;
        link.circularPathData.rightNodeBuffer = buffer;
        link.circularPathData.sourceWidth = link.source.x1 - link.source.x0;
        link.circularPathData.sourceX = link.source.x0 + link.circularPathData.sourceWidth;
        link.circularPathData.targetX = link.target.x0;
        link.circularPathData.sourceY = link.y0;
        link.circularPathData.targetY = link.y1;

        // for self linking paths, and that the only circular link in/out of that node
        if (selfLinking(link, id) && onlyCircularLink(link)) {
          link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2;
          link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2;
          link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2;
          link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2;

          if (link.circularLinkType == 'bottom') {
            link.circularPathData.verticalFullExtent = link.source.y1 + verticalMargin + link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
          } else {
            // top links
            link.circularPathData.verticalFullExtent = link.source.y0 - verticalMargin - link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
          }
        } else {
          // else calculate normally
          // add left extent coordinates, based on links with same source column and circularLink type
          var thisColumn = link.source.column;
          var thisCircularLinkType = link.circularLinkType;
          var sameColumnLinks = graph.links.filter(function (l) {
            return l.source.column == thisColumn && l.circularLinkType == thisCircularLinkType;
          });

          if (link.circularLinkType == 'bottom') {
            sameColumnLinks.sort(sortLinkSourceYDescending);
          } else {
            sameColumnLinks.sort(sortLinkSourceYAscending);
          }

          var radiusOffset = 0;
          sameColumnLinks.forEach(function (l, i) {
            if (l.circularLinkID == link.circularLinkID) {
              link.circularPathData.leftSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
              link.circularPathData.leftLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
            }
            radiusOffset = radiusOffset + l.width;
          });

          // add right extent coordinates, based on links with same target column and circularLink type
          thisColumn = link.target.column;
          sameColumnLinks = graph.links.filter(function (l) {
            return l.target.column == thisColumn && l.circularLinkType == thisCircularLinkType;
          });
          if (link.circularLinkType == 'bottom') {
            sameColumnLinks.sort(sortLinkTargetYDescending);
          } else {
            sameColumnLinks.sort(sortLinkTargetYAscending);
          }

          radiusOffset = 0;
          sameColumnLinks.forEach(function (l, i) {
            if (l.circularLinkID == link.circularLinkID) {
              link.circularPathData.rightSmallArcRadius = baseRadius + link.width / 2 + radiusOffset;
              link.circularPathData.rightLargeArcRadius = baseRadius + link.width / 2 + i * circularLinkGap + radiusOffset;
            }
            radiusOffset = radiusOffset + l.width;
          });

          // bottom links
          if (link.circularLinkType == 'bottom') {
            link.circularPathData.verticalFullExtent = y1 + verticalMargin + link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent - link.circularPathData.rightLargeArcRadius;
          } else {
            // top links
            link.circularPathData.verticalFullExtent = minY - verticalMargin - link.circularPathData.verticalBuffer;
            link.circularPathData.verticalLeftInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.leftLargeArcRadius;
            link.circularPathData.verticalRightInnerExtent = link.circularPathData.verticalFullExtent + link.circularPathData.rightLargeArcRadius;
          }
        }

        // all links
        link.circularPathData.leftInnerExtent = link.circularPathData.sourceX + link.circularPathData.leftNodeBuffer;
        link.circularPathData.rightInnerExtent = link.circularPathData.targetX - link.circularPathData.rightNodeBuffer;
        link.circularPathData.leftFullExtent = link.circularPathData.sourceX + link.circularPathData.leftLargeArcRadius + link.circularPathData.leftNodeBuffer;
        link.circularPathData.rightFullExtent = link.circularPathData.targetX - link.circularPathData.rightLargeArcRadius - link.circularPathData.rightNodeBuffer;
      }

      if (link.circular) {
        link.path = createCircularPathString(link);
      } else {
        var normalPath = (0, d3Shape$2.linkHorizontal)().source(function (d) {
          var x = d.source.x0 + (d.source.x1 - d.source.x0);
          var y = d.y0;
          return [x, y];
        }).target(function (d) {
          var x = d.target.x0;
          var y = d.y1;
          return [x, y];
        });
        link.path = normalPath(link);
      }
    });
  }

  // create a d path using the addCircularPathData
  function createCircularPathString(link) {
    var pathString = '';
    if (link.circularLinkType == 'top') {
      pathString =
      // start at the right of the source node
      'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
      // line right to buffer point
      'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 0 ' +
      // End of arc X //End of arc Y
      link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY - link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
      // line up to buffer point
      'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 0 ' +
      // End of arc X //End of arc Y
      link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
      // line left to buffer point
      'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 0 ' +
      // End of arc X //End of arc Y
      link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
      // line down
      'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY - link.circularPathData.rightSmallArcRadius) + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 0 ' +
      // End of arc X //End of arc Y
      link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
      // line to end
      'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
    } else {
      // bottom path
      pathString =
      // start at the right of the source node
      'M' + link.circularPathData.sourceX + ' ' + link.circularPathData.sourceY + ' ' +
      // line right to buffer point
      'L' + link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.sourceY + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftSmallArcRadius + ' 0 0 1 ' +
      // End of arc X //End of arc Y
      link.circularPathData.leftFullExtent + ' ' + (link.circularPathData.sourceY + link.circularPathData.leftSmallArcRadius) + ' ' + // End of arc X
      // line down to buffer point
      'L' + link.circularPathData.leftFullExtent + ' ' + link.circularPathData.verticalLeftInnerExtent + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.leftLargeArcRadius + ' ' + link.circularPathData.leftLargeArcRadius + ' 0 0 1 ' +
      // End of arc X //End of arc Y
      link.circularPathData.leftInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' + // End of arc X
      // line left to buffer point
      'L' + link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.verticalFullExtent + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightLargeArcRadius + ' 0 0 1 ' +
      // End of arc X //End of arc Y
      link.circularPathData.rightFullExtent + ' ' + link.circularPathData.verticalRightInnerExtent + ' ' + // End of arc X
      // line up
      'L' + link.circularPathData.rightFullExtent + ' ' + (link.circularPathData.targetY + link.circularPathData.rightSmallArcRadius) + ' ' +
      // Arc around: Centre of arc X and  //Centre of arc Y
      'A' + link.circularPathData.rightLargeArcRadius + ' ' + link.circularPathData.rightSmallArcRadius + ' 0 0 1 ' +
      // End of arc X //End of arc Y
      link.circularPathData.rightInnerExtent + ' ' + link.circularPathData.targetY + ' ' + // End of arc X
      // line to end
      'L' + link.circularPathData.targetX + ' ' + link.circularPathData.targetY;
    }

    return pathString;
  }

  // sort links based on the distance between the source and tartget node columns
  // if the same, then use Y position of the source node
  function sortLinkColumnAscending(link1, link2) {
    if (linkColumnDistance(link1) == linkColumnDistance(link2)) {
      return link1.circularLinkType == 'bottom' ? sortLinkSourceYDescending(link1, link2) : sortLinkSourceYAscending(link1, link2);
    } else {
      return linkColumnDistance(link2) - linkColumnDistance(link1);
    }
  }

  // sort ascending links by their source vertical position, y0
  function sortLinkSourceYAscending(link1, link2) {
    return link1.y0 - link2.y0;
  }

  // sort descending links by their source vertical position, y0
  function sortLinkSourceYDescending(link1, link2) {
    return link2.y0 - link1.y0;
  }

  // sort ascending links by their target vertical position, y1
  function sortLinkTargetYAscending(link1, link2) {
    return link1.y1 - link2.y1;
  }

  // sort descending links by their target vertical position, y1
  function sortLinkTargetYDescending(link1, link2) {
    return link2.y1 - link1.y1;
  }

  // return the distance between the link's target and source node, in terms of the nodes' column
  function linkColumnDistance(link) {
    return link.target.column - link.source.column;
  }

  // return the distance between the link's target and source node, in terms of the nodes' X coordinate
  function linkXLength(link) {
    return link.target.x0 - link.source.x1;
  }

  // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
  // * approx, based on a straight line from target to source, when in fact the path is a bezier
  function linkPerpendicularYToLinkSource(longerLink, shorterLink) {
    // get the angle for the longer link
    var angle = linkAngle(longerLink);

    // get the adjacent length to the other link's x position
    var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

    // add or subtract from longer link1's original y1, depending on the slope
    var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 + heightFromY1ToPependicular : longerLink.y1 - heightFromY1ToPependicular;

    return yPerpendicular;
  }

  // Return the Y coordinate on the longerLink path * which is perpendicular shorterLink's source.
  // * approx, based on a straight line from target to source, when in fact the path is a bezier
  function linkPerpendicularYToLinkTarget(longerLink, shorterLink) {
    // get the angle for the longer link
    var angle = linkAngle(longerLink);

    // get the adjacent length to the other link's x position
    var heightFromY1ToPependicular = linkXLength(shorterLink) / Math.tan(angle);

    // add or subtract from longer link's original y1, depending on the slope
    var yPerpendicular = incline(longerLink) == 'up' ? longerLink.y1 - heightFromY1ToPependicular : longerLink.y1 + heightFromY1ToPependicular;

    return yPerpendicular;
  }

  // Move any nodes that overlap links which span 2+ columns
  function resolveNodeLinkOverlaps(graph, y0, y1, id) {

    graph.links.forEach(function (link) {
      if (link.circular) {
        return;
      }

      if (link.target.column - link.source.column > 1) {
        var columnToTest = link.source.column + 1;
        var maxColumnToTest = link.target.column - 1;

        var i = 1;
        var numberOfColumnsToTest = maxColumnToTest - columnToTest + 1;

        for (i = 1; columnToTest <= maxColumnToTest; columnToTest++, i++) {
          graph.nodes.forEach(function (node) {
            if (node.column == columnToTest) {
              var t = i / (numberOfColumnsToTest + 1);

              // Find all the points of a cubic bezier curve in javascript
              // https://stackoverflow.com/questions/15397596/find-all-the-points-of-a-cubic-bezier-curve-in-javascript

              var B0_t = Math.pow(1 - t, 3);
              var B1_t = 3 * t * Math.pow(1 - t, 2);
              var B2_t = 3 * Math.pow(t, 2) * (1 - t);
              var B3_t = Math.pow(t, 3);

              var py_t = B0_t * link.y0 + B1_t * link.y0 + B2_t * link.y1 + B3_t * link.y1;

              var linkY0AtColumn = py_t - link.width / 2;
              var linkY1AtColumn = py_t + link.width / 2;

              // If top of link overlaps node, push node up
              if (linkY0AtColumn > node.y0 && linkY0AtColumn < node.y1) {

                var dy = node.y1 - linkY0AtColumn + 10;
                dy = node.circularLinkType == 'bottom' ? dy : -dy;

                node = adjustNodeHeight(node, dy, y0, y1);

                // check if other nodes need to move up too
                graph.nodes.forEach(function (otherNode) {
                  // don't need to check itself or nodes at different columns
                  if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                    return;
                  }
                  if (nodesOverlap(node, otherNode)) {
                    adjustNodeHeight(otherNode, dy, y0, y1);
                  }
                });
              } else if (linkY1AtColumn > node.y0 && linkY1AtColumn < node.y1) {
                // If bottom of link overlaps node, push node down
                var dy = linkY1AtColumn - node.y0 + 10;

                node = adjustNodeHeight(node, dy, y0, y1);

                // check if other nodes need to move down too
                graph.nodes.forEach(function (otherNode) {
                  // don't need to check itself or nodes at different columns
                  if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                    return;
                  }
                  if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                    adjustNodeHeight(otherNode, dy, y0, y1);
                  }
                });
              } else if (linkY0AtColumn < node.y0 && linkY1AtColumn > node.y1) {
                // if link completely overlaps node
                var dy = linkY1AtColumn - node.y0 + 10;

                node = adjustNodeHeight(node, dy, y0, y1);

                graph.nodes.forEach(function (otherNode) {
                  // don't need to check itself or nodes at different columns
                  if (getNodeID(otherNode, id) == getNodeID(node, id) || otherNode.column != node.column) {
                    return;
                  }
                  if (otherNode.y0 < node.y1 && otherNode.y1 > node.y1) {
                    adjustNodeHeight(otherNode, dy, y0, y1);
                  }
                });
              }
            }
          });
        }
      }
    });
  }

  // check if two nodes overlap
  function nodesOverlap(nodeA, nodeB) {
    // test if nodeA top partially overlaps nodeB
    if (nodeA.y0 > nodeB.y0 && nodeA.y0 < nodeB.y1) {
      return true;
    } else if (nodeA.y1 > nodeB.y0 && nodeA.y1 < nodeB.y1) {
      // test if nodeA bottom partially overlaps nodeB
      return true;
    } else if (nodeA.y0 < nodeB.y0 && nodeA.y1 > nodeB.y1) {
      // test if nodeA covers nodeB
      return true;
    } else {
      return false;
    }
  }

  // update a node, and its associated links, vertical positions (y0, y1)
  function adjustNodeHeight(node, dy, sankeyY0, sankeyY1) {
    if (node.y0 + dy >= sankeyY0 && node.y1 + dy <= sankeyY1) {
      node.y0 = node.y0 + dy;
      node.y1 = node.y1 + dy;

      node.targetLinks.forEach(function (l) {
        l.y1 = l.y1 + dy;
      });

      node.sourceLinks.forEach(function (l) {
        l.y0 = l.y0 + dy;
      });
    }
    return node;
  }

  // sort and set the links' y0 for each node
  function sortSourceLinks(graph, y1, id) {
    graph.nodes.forEach(function (node) {
      // move any nodes up which are off the bottom
      if (node.y + (node.y1 - node.y0) > y1) {
        node.y = node.y - (node.y + (node.y1 - node.y0) - y1);
      }

      var nodesSourceLinks = graph.links.filter(function (l) {
        return getNodeID(l.source, id) == getNodeID(node, id);
      });

      var nodeSourceLinksLength = nodesSourceLinks.length;

      // if more than 1 link then sort
      if (nodeSourceLinksLength > 1) {
        nodesSourceLinks.sort(function (link1, link2) {
          // if both are not circular...
          if (!link1.circular && !link2.circular) {
            // if the target nodes are the same column, then sort by the link's target y
            if (link1.target.column == link2.target.column) {
              return link1.y1 - link2.y1;
            } else if (!sameInclines(link1, link2)) {
              // if the links slope in different directions, then sort by the link's target y
              return link1.y1 - link2.y1;

              // if the links slope in same directions, then sort by any overlap
            } else {
              if (link1.target.column > link2.target.column) {
                var link2Adj = linkPerpendicularYToLinkTarget(link2, link1);
                return link1.y1 - link2Adj;
              }
              if (link2.target.column > link1.target.column) {
                var link1Adj = linkPerpendicularYToLinkTarget(link1, link2);
                return link1Adj - link2.y1;
              }
            }
          }

          // if only one is circular, the move top links up, or bottom links down
          if (link1.circular && !link2.circular) {
            return link1.circularLinkType == 'top' ? -1 : 1;
          } else if (link2.circular && !link1.circular) {
            return link2.circularLinkType == 'top' ? 1 : -1;
          }

          // if both links are circular...
          if (link1.circular && link2.circular) {
            // ...and they both loop the same way (both top)
            if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
              // ...and they both connect to a target with same column, then sort by the target's y
              if (link1.target.column === link2.target.column) {
                return link1.target.y1 - link2.target.y1;
              } else {
                // ...and they connect to different column targets, then sort by how far back they
                return link2.target.column - link1.target.column;
              }
            } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
              // ...and they both loop the same way (both bottom)
              // ...and they both connect to a target with same column, then sort by the target's y
              if (link1.target.column === link2.target.column) {
                return link2.target.y1 - link1.target.y1;
              } else {
                // ...and they connect to different column targets, then sort by how far back they
                return link1.target.column - link2.target.column;
              }
            } else {
              // ...and they loop around different ways, the move top up and bottom down
              return link1.circularLinkType == 'top' ? -1 : 1;
            }
          }
        });
      }

      // update y0 for links
      var ySourceOffset = node.y0;

      nodesSourceLinks.forEach(function (link) {
        link.y0 = ySourceOffset + link.width / 2;
        ySourceOffset = ySourceOffset + link.width;
      });

      // correct any circular bottom links so they are at the bottom of the node
      nodesSourceLinks.forEach(function (link, i) {
        if (link.circularLinkType == 'bottom') {
          var j = i + 1;
          var offsetFromBottom = 0;
          // sum the widths of any links that are below this link
          for (j; j < nodeSourceLinksLength; j++) {
            offsetFromBottom = offsetFromBottom + nodesSourceLinks[j].width;
          }
          link.y0 = node.y1 - offsetFromBottom - link.width / 2;
        }
      });
    });
  }

  // sort and set the links' y1 for each node
  function sortTargetLinks(graph, y1, id) {
    graph.nodes.forEach(function (node) {
      var nodesTargetLinks = graph.links.filter(function (l) {
        return getNodeID(l.target, id) == getNodeID(node, id);
      });

      var nodesTargetLinksLength = nodesTargetLinks.length;

      if (nodesTargetLinksLength > 1) {
        nodesTargetLinks.sort(function (link1, link2) {
          // if both are not circular, the base on the source y position
          if (!link1.circular && !link2.circular) {
            if (link1.source.column == link2.source.column) {
              return link1.y0 - link2.y0;
            } else if (!sameInclines(link1, link2)) {
              return link1.y0 - link2.y0;
            } else {
              // get the angle of the link to the further source node (ie the smaller column)
              if (link2.source.column < link1.source.column) {
                var link2Adj = linkPerpendicularYToLinkSource(link2, link1);

                return link1.y0 - link2Adj;
              }
              if (link1.source.column < link2.source.column) {
                var link1Adj = linkPerpendicularYToLinkSource(link1, link2);

                return link1Adj - link2.y0;
              }
            }
          }

          // if only one is circular, the move top links up, or bottom links down
          if (link1.circular && !link2.circular) {
            return link1.circularLinkType == 'top' ? -1 : 1;
          } else if (link2.circular && !link1.circular) {
            return link2.circularLinkType == 'top' ? 1 : -1;
          }

          // if both links are circular...
          if (link1.circular && link2.circular) {
            // ...and they both loop the same way (both top)
            if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'top') {
              // ...and they both connect to a target with same column, then sort by the target's y
              if (link1.source.column === link2.source.column) {
                return link1.source.y1 - link2.source.y1;
              } else {
                // ...and they connect to different column targets, then sort by how far back they
                return link1.source.column - link2.source.column;
              }
            } else if (link1.circularLinkType === link2.circularLinkType && link1.circularLinkType == 'bottom') {
              // ...and they both loop the same way (both bottom)
              // ...and they both connect to a target with same column, then sort by the target's y
              if (link1.source.column === link2.source.column) {
                return link1.source.y1 - link2.source.y1;
              } else {
                // ...and they connect to different column targets, then sort by how far back they
                return link2.source.column - link1.source.column;
              }
            } else {
              // ...and they loop around different ways, the move top up and bottom down
              return link1.circularLinkType == 'top' ? -1 : 1;
            }
          }
        });
      }

      // update y1 for links
      var yTargetOffset = node.y0;

      nodesTargetLinks.forEach(function (link) {
        link.y1 = yTargetOffset + link.width / 2;
        yTargetOffset = yTargetOffset + link.width;
      });

      // correct any circular bottom links so they are at the bottom of the node
      nodesTargetLinks.forEach(function (link, i) {
        if (link.circularLinkType == 'bottom') {
          var j = i + 1;
          var offsetFromBottom = 0;
          // sum the widths of any links that are below this link
          for (j; j < nodesTargetLinksLength; j++) {
            offsetFromBottom = offsetFromBottom + nodesTargetLinks[j].width;
          }
          link.y1 = node.y1 - offsetFromBottom - link.width / 2;
        }
      });
    });
  }

  // test if links both slope up, or both slope down
  function sameInclines(link1, link2) {
    return incline(link1) == incline(link2);
  }

  // returns the slope of a link, from source to target
  // up => slopes up from source to target
  // down => slopes down from source to target
  function incline(link) {
    return link.y0 - link.y1 > 0 ? 'up' : 'down';
  }

  // check if link is self linking, ie links a node to the same node
  function selfLinking(link, id) {
    return getNodeID(link.source, id) == getNodeID(link.target, id);
  }

  /// ////////////////////////////////////////////////////////////////////////////

  /*exports.sankeyCircular = sankeyCircular
  exports.sankeyCenter = center
  exports.sankeyLeft = left
  exports.sankeyRight = right
  exports.sankeyJustify = justify
    Object.defineProperty(exports, '__esModule', { value: true })*/
});

unwrapExports(sankeyCircular);

var dist = createCommonjsModule(function (module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  Object.defineProperty(exports, "sankeyCircular", {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(sankeyCircular).default;
    }
  });

  Object.defineProperty(exports, "sankeyCenter", {
    enumerable: true,
    get: function get() {
      return align.center;
    }
  });
  Object.defineProperty(exports, "sankeyLeft", {
    enumerable: true,
    get: function get() {
      return align.left;
    }
  });
  Object.defineProperty(exports, "sankeyRight", {
    enumerable: true,
    get: function get() {
      return align.right;
    }
  });
  Object.defineProperty(exports, "sankeyJustify", {
    enumerable: true,
    get: function get() {
      return align.justify;
    }
  });

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
});

unwrapExports(dist);
var dist_1 = dist.sankeyCircular;
var dist_2 = dist.sankeyLeft;
var dist_3 = dist.sankeyCenter;
var dist_4 = dist.sankeyRight;
var dist_5 = dist.sankeyJustify;

var cos$1 = Math.cos;
var sin$1 = Math.sin;
var pi$5 = Math.PI;
var halfPi$4 = pi$5 / 2;
var tau$5 = pi$5 * 2;
var max$3 = Math.max;

function compareValue(compare) {
  return function (a, b) {
    return compare(a.source.value + a.target.value, b.source.value + b.target.value);
  };
}

var chord = function () {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1;while (++i < n) {
      x = 0, j = -1;while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function (a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
      d.sort(function (a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max$3(0, tau$5 - padAngle * n) / k;
    dx = k ? padAngle : tau$5 / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1;while (++i < n) {
      x0 = x, j = -1;while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1;while (++i < n) {
      j = i - 1;while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value ? { source: target, target: source } : { source: source, target: target });
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function (_) {
    return arguments.length ? (padAngle = max$3(0, _), chord) : padAngle;
  };

  chord.sortGroups = function (_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function (_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function (_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
};

var slice$7 = Array.prototype.slice;

var constant$15 = function (x) {
  return function () {
    return x;
  };
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius$1(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

var ribbon$1 = function () {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius$1,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$7.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$4,
        sa1 = endAngle.apply(this, argv) - halfPi$4,
        sx0 = sr * cos$1(sa0),
        sy0 = sr * sin$1(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$4,
        ta1 = endAngle.apply(this, argv) - halfPi$4;

    if (!context) context = buffer = path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos$1(ta0), tr * sin$1(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$15(+_), ribbon) : radius;
  };

  ribbon.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$15(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$15(+_), ribbon) : endAngle;
  };

  ribbon.source = function (_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function (_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
  };

  return ribbon;
};

var htmlFrameHoverRule$1 = function htmlFrameHoverRule(_ref) {
  var d = _ref.d,
      i = _ref.i,
      tooltipContent = _ref.tooltipContent;

  var content = d.edge ? React.createElement(
    "div",
    { className: "tooltip-content" },
    React.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.edge.source.id,
      " to ",
      d.edge.target.id
    )
  ) : React.createElement(
    "div",
    { className: "tooltip-content" },
    React.createElement(
      "p",
      { key: "html-annotation-content-1" },
      d.id
    ),
    React.createElement(
      "p",
      { key: "html-annotation-content-2" },
      "Degree: ",
      d.degree
    )
  );

  if (d.type === "frame-hover" && tooltipContent) {
    content = tooltipContent(d);
  }

  return React.createElement(
    "div",
    {
      key: "xylabel" + i,
      className: "annotation annotation-network-label " + (d.className || ""),
      style: {
        position: "absolute",
        top: d.y + "px",
        left: d.x + "px"
      }
    },
    content
  );
};

var svgNodeRule = function svgNodeRule(_ref2) {
  var d = _ref2.d,
      i = _ref2.i,
      projectedNodes = _ref2.projectedNodes,
      nodeIDAccessor = _ref2.nodeIDAccessor,
      nodeSizeAccessor = _ref2.nodeSizeAccessor;

  var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) {
    return nodeIDAccessor(p) === d.id;
  });
  if (!selectedNode) {
    return null;
  }
  var noteData = Object.assign({
    dx: d.dx || -25,
    dy: d.dy || -25,
    x: selectedNode.x,
    y: selectedNode.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, {
    type: lib_8,
    subject: {
      radius: d.radius || selectedNode.radius || nodeSizeAccessor(d)
    }
  });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgReactAnnotationRule = function svgReactAnnotationRule(_ref3) {
  var d = _ref3.d,
      i = _ref3.i,
      projectedNodes = _ref3.projectedNodes,
      nodeIDAccessor = _ref3.nodeIDAccessor;

  var selectedNode = d.x && d.y ? d : projectedNodes.find(function (p) {
    return nodeIDAccessor(p) === d.id;
  });
  if (!selectedNode) {
    return null;
  }
  var noteData = Object.assign({
    dx: 0,
    dy: 0,
    x: selectedNode.x,
    y: selectedNode.y,
    note: { label: d.label },
    connector: { end: "arrow" }
  }, d, { type: typeof d.type === "function" ? d.type : undefined });
  return React.createElement(SemioticAnnotation, { key: d.key || "annotation-" + i, noteData: noteData });
};

var svgEncloseRule$1 = function svgEncloseRule(_ref4) {
  var d = _ref4.d,
      projectedNodes = _ref4.projectedNodes,
      nodeIDAccessor = _ref4.nodeIDAccessor,
      nodeSizeAccessor = _ref4.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }
  var circle = packEnclose$1(selectedNodes.map(function (p) {
    return { x: p.x, y: p.y, r: nodeSizeAccessor(p) };
  }));
  return circleEnclosure({ circle: circle, d: d });
};

var svgRectEncloseRule$2 = function svgRectEncloseRule(_ref5) {
  var d = _ref5.d,
      i = _ref5.i,
      projectedNodes = _ref5.projectedNodes,
      nodeIDAccessor = _ref5.nodeIDAccessor,
      nodeSizeAccessor = _ref5.nodeSizeAccessor;

  var selectedNodes = projectedNodes.filter(function (p) {
    return d.ids.indexOf(nodeIDAccessor(p)) !== -1;
  });
  if (selectedNodes.length === 0) {
    return null;
  }

  var bboxNodes = selectedNodes.map(function (p) {
    var nodeSize = nodeSizeAccessor(p);
    return {
      x0: p.x0 === undefined ? p.x - nodeSize : p.x0,
      x1: p.x1 === undefined ? p.x + nodeSize : p.x1,
      y0: p.y0 === undefined ? p.y - nodeSize : p.y0,
      y1: p.y1 === undefined ? p.y + nodeSize : p.y1
    };
  });
  return rectangleEnclosure({ bboxNodes: bboxNodes, d: d, i: i });
};

var basicMiddle = function basicMiddle(d) {
  return {
    edge: d,
    x: (d.source.x + d.target.x) / 2,
    y: (d.source.y + d.target.y) / 2
  };
};

var edgePointHash = {
  sankey: function sankey(d) {
    return {
      edge: d,
      x: (d.source.x1 + d.target.x0) / 2,
      y: d.circularPathData ? d.circularPathData.verticalFullExtent : ((d.y0 + d.y1) / 2 + (d.y0 + d.y1) / 2) / 2
    };
  },
  force: basicMiddle,
  tree: basicMiddle,
  cluster: basicMiddle
};

var hierarchicalTypeHash = {
  dendrogram: tree,
  tree: tree,
  circlepack: pack$1,
  cluster: cluster,
  treemap: treemap,
  partition: partition
};

var hierarchicalCustomNodeHash = {
  partition: hierarchicalRectNodeGenerator,
  treemap: hierarchicalRectNodeGenerator,
  circlepack: circleNodeGenerator
};

var hierarchicalProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true
};

var radialProjectable = {
  partition: true,
  cluster: true,
  tree: true,
  dendrogram: true

  /*
  const customEdgeHashProject = {
    offset: glyphProject.offset,
    parallel: glyphProject.parallel
  }
  
  const customEdgeHashMutate = {
    particle: glyphMutate.particle
  }
  */

};function breadthFirstCompontents(baseNodes, hash) {
  var componentHash = {
    "0": { componentNodes: [], componentEdges: [] }
  };
  var components = [componentHash["0"]];

  var componentID = 0;

  traverseNodesBF(baseNodes, true);

  function traverseNodesBF(nodes, top) {
    nodes.forEach(function (node) {
      var hashNode = hash.get(node);
      if (!hashNode) {
        componentHash["0"].componentNodes.push(node);
      } else if (hashNode.component === null) {
        var _componentHash$compon;

        if (top === true) {
          componentID++;
          componentHash[componentID] = {
            componentNodes: [],
            componentEdges: []
          };
          components.push(componentHash[componentID]);
        }

        hashNode.component = componentID;
        componentHash[componentID].componentNodes.push(node);
        (_componentHash$compon = componentHash[componentID].componentEdges).push.apply(_componentHash$compon, toConsumableArray(hashNode.edges));
        var traversibleNodes = [].concat(toConsumableArray(hashNode.connectedNodes));
        traverseNodesBF(traversibleNodes);
      }
    });
  }

  return components.sort(function (a, b) {
    return b.componentNodes.length - a.componentNodes.length;
  });
}

var projectedCoordinateNames$1 = { y: "y", x: "x" };

function recursiveIDAccessor(idAccessor, node, accessorString) {
  if (node.parent) {
    accessorString = accessorString + "-" + recursiveIDAccessor(idAccessor, node.parent, accessorString);
  }
  return accessorString + "-" + idAccessor(node.data);
}

var sankeyOrientHash = {
  left: dist_2,
  right: dist_4,
  center: dist_3,
  justify: dist_5
};

var xScale$1 = identity$4();
var yScale$1 = identity$4();

var curvature = 0.5;

var areaLink = function areaLink(d) {
  var x0 = d.source.x1,
      x1 = d.target.x0,
      xi = interpolateNumber(x0, x1),
      x2 = xi(curvature),
      x3 = xi(1 - curvature),
      y0 = d.y0 - d.sankeyWidth / 2,
      y1 = d.y1 - d.sankeyWidth / 2,
      y2 = d.y1 + d.sankeyWidth / 2,
      y3 = d.y0 + d.sankeyWidth / 2;

  return "M" + x0 + "," + y0 + "C" + x2 + "," + y0 + " " + x3 + "," + y1 + " " + x1 + "," + y1 + "L" + x1 + "," + y2 + "C" + x3 + "," + y2 + " " + x2 + "," + y3 + " " + x0 + "," + y3 + "Z";
};

function circularAreaLink(link) {
  var linkGenerator = linearRibbon().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  })
  //    .interpolate(curveBasisClosed)
  .r(function () {
    return link.sankeyWidth / 2;
  });

  var xyForLink = [{
    x: link.circularPathData.sourceX,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.sourceY
  }, {
    x: link.circularPathData.leftFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.verticalFullExtent
  }, {
    x: link.circularPathData.rightFullExtent,
    y: link.circularPathData.targetY
  }, {
    x: link.circularPathData.targetX,
    y: link.circularPathData.targetY
  }];

  return linkGenerator(xyForLink);
}

var matrixify = function matrixify(_ref) {
  var edgeHash = _ref.edgeHash,
      nodes = _ref.nodes,
      edgeWidthAccessor = _ref.edgeWidthAccessor,
      nodeIDAccessor = _ref.nodeIDAccessor;

  var matrix = [];
  nodes.forEach(function (nodeSource) {
    var nodeSourceID = nodeIDAccessor(nodeSource);
    var sourceRow = [];
    matrix.push(sourceRow);
    nodes.forEach(function (nodeTarget) {
      var nodeTargetID = nodeIDAccessor(nodeTarget);
      var theEdge = edgeHash.get(nodeSourceID + "|" + nodeTargetID);
      if (theEdge) {
        sourceRow.push(edgeWidthAccessor(theEdge));
      } else {
        sourceRow.push(0);
      }
    });
  });
  return matrix;
};

var NetworkFrame = function (_React$Component) {
  inherits(NetworkFrame, _React$Component);

  function NetworkFrame(props) {
    classCallCheck(this, NetworkFrame);

    var _this = possibleConstructorReturn(this, (NetworkFrame.__proto__ || Object.getPrototypeOf(NetworkFrame)).call(this, props));

    _this.calculateNetworkFrame = _this.calculateNetworkFrame.bind(_this);
    _this.defaultNetworkHTMLRule = _this.defaultNetworkHTMLRule.bind(_this);
    _this.defaultNetworkSVGRule = _this.defaultNetworkSVGRule.bind(_this);

    _this.renderBody = _this.renderBody.bind(_this);

    _this.graphSettings = {
      numberOfNodes: 0,
      numberOfEdges: 0,
      type: "empty-start"
    };
    _this.state = {
      nodeData: null,
      edgeData: null,
      adjustedPosition: null,
      adjustedSize: null,
      backgroundGraphics: null,
      foregroundGraphics: null,
      projectedNodes: undefined,
      projectedEdges: undefined,
      renderNumber: 0,
      voronoiHover: null,
      nodeLabelAnnotations: []
    };

    _this.oAccessor = null;
    _this.rAccessor = null;
    _this.oScale = null;
    _this.rScale = null;
    return _this;
  }

  createClass(NetworkFrame, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      this.calculateNetworkFrame(this.props);
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      if (this.state.dataVersion && this.state.dataVersion !== nextProps.dataVersion || !this.state.projectedNodes && !this.state.projectedEdges) {
        this.calculateNetworkFrame(nextProps);
      } else if (this.props.size[0] !== nextProps.size[0] || this.props.size[1] !== nextProps.size[1] || !this.state.dataVersion && networkFrameChangeProps.find(function (d) {
        return _this2.props[d] !== nextProps[d];
      })) {
        this.calculateNetworkFrame(nextProps);
      }
    }
  }, {
    key: "onNodeClick",
    value: function onNodeClick(d, i) {
      if (this.props.onNodeClick) {
        this.props.onNodeClick(d, i);
      }
    }
  }, {
    key: "onNodeEnter",
    value: function onNodeEnter(d, i) {
      if (this.props.onNodeEnter) {
        this.props.onNodeEnter(d, i);
      }
    }
  }, {
    key: "onNodeOut",
    value: function onNodeOut(d, i) {
      if (this.props.onNodeOut) {
        this.props.onNodeOut(d, i);
      }
    }
  }, {
    key: "calculateNetworkFrame",
    value: function calculateNetworkFrame(currentProps) {
      var _this3 = this;

      var nodes = currentProps.nodes,
          edges = currentProps.edges,
          networkType = currentProps.networkType,
          size = currentProps.size,
          nodeStyle = currentProps.nodeStyle,
          nodeClass = currentProps.nodeClass,
          canvasNodes = currentProps.canvasNodes,
          edgeStyle = currentProps.edgeStyle,
          edgeClass = currentProps.edgeClass,
          canvasEdges = currentProps.canvasEdges,
          nodeRenderMode = currentProps.nodeRenderMode,
          edgeRenderMode = currentProps.edgeRenderMode,
          nodeLabels = currentProps.nodeLabels;
      //    const eventListenersGenerator = generatenetworkFrameEventListeners(customHoverBehavior, customClickBehavior)

      var edgeType = currentProps.edgeType,
          customNodeIcon = currentProps.customNodeIcon,
          customEdgeIcon = currentProps.customEdgeIcon;
      var hoverAnnotation = currentProps.hoverAnnotation;


      var networkSettings = void 0;

      if (typeof networkType === "string") {
        networkSettings = { type: networkType, iterations: 500 };
      } else {
        networkSettings = networkType;
      }

      var nodeIDAccessor = stringToFn(currentProps.nodeIDAccessor, function (d) {
        return d.id;
      });
      var sourceAccessor = stringToFn(currentProps.sourceAccessor, function (d) {
        return d.source;
      });
      var targetAccessor = stringToFn(currentProps.targetAccessor, function (d) {
        return d.target;
      });
      var nodeSizeAccessor = typeof currentProps.nodeSizeAccessor === "number" ? function () {
        return currentProps.nodeSizeAccessor;
      } : stringToFn(currentProps.nodeSizeAccessor, function (d) {
        return d.r || 5;
      });
      var edgeWidthAccessor = stringToFn(currentProps.edgeWidthAccessor, function (d) {
        return d.weight || 1;
      });
      var nodeStyleFn = stringToFn(nodeStyle, function () {
        return {};
      }, true);
      var nodeClassFn = stringToFn(nodeClass, function () {
        return "";
      }, true);
      var nodeRenderModeFn = stringToFn(nodeRenderMode, undefined, true);
      var nodeCanvasRenderFn = stringToFn(canvasNodes, undefined, true);

      var margin = calculateMargin(currentProps);

      var _adjustedPositionSize = adjustedPositionSize(currentProps),
          adjustedPosition = _adjustedPositionSize.adjustedPosition,
          adjustedSize = _adjustedPositionSize.adjustedSize;

      var title = generateFrameTitle(currentProps);

      var _state = this.state,
          projectedNodes = _state.projectedNodes,
          projectedEdges = _state.projectedEdges;


      var changedData = !this.state.projectedNodes || !this.state.projectedEdges || this.graphSettings.nodes !== currentProps.nodes || this.graphSettings.edges !== currentProps.edges || hierarchicalTypeHash[networkSettings.type];

      if (changedData) {
        this.edgeHash = new Map();
        this.nodeHash = new Map();
        projectedNodes = [];
        projectedEdges = [];
        nodes.forEach(function (node) {
          var id = nodeIDAccessor(node);
          _this3.nodeHash.set(id, node);
          _this3.nodeHash.set(node, node);
          projectedNodes.push(node);
          node.id = id;
          node.inDegree = 0;
          node.outDegree = 0;
          node.degree = 0;
        });

        var operationalEdges = edges;

        if (!Array.isArray(edges)) {
          this.hierarchicalNetwork = true;
          var rootNode = hierarchy(edges, networkSettings.hierarchyChildren);

          rootNode.sum(networkSettings.hierarchySum || function (d) {
            return d.value;
          });

          if (hierarchicalTypeHash[networkSettings.type]) {
            var layout = networkSettings.layout || hierarchicalTypeHash[networkSettings.type];
            var hierarchicalLayout = layout();
            var networkSettingKeys = Object.keys(networkSettings);

            networkSettingKeys.forEach(function (key) {
              if (hierarchicalLayout[key]) {
                hierarchicalLayout[key](networkSettings[key]);
              }
            });
            var layoutSize = networkSettings.projection === "horizontal" && hierarchicalProjectable[networkSettings.type] ? [adjustedSize[1], adjustedSize[0]] : adjustedSize;
            if (!networkSettings.nodeSize) {
              hierarchicalLayout.size(layoutSize);
            }
            hierarchicalLayout(rootNode);
          }

          operationalEdges = rootNode.descendants().filter(function (d) {
            return d.parent !== null;
          }).map(function (d) {
            return {
              source: Object.assign(d.parent, d.parent.data),
              target: Object.assign(d, d.data),
              depth: d.depth,
              weight: 1,
              value: 1,
              _NWFEdgeKey: nodeIDAccessor(d.data) + "-" + recursiveIDAccessor(nodeIDAccessor, d.parent, "")
            };
          });
        }
        operationalEdges.forEach(function (edge) {
          var source = sourceAccessor(edge);
          var target = targetAccessor(edge);
          var sourceTarget = [source, target];
          sourceTarget.forEach(function (nodeDirection) {
            if (!_this3.nodeHash.get(nodeDirection)) {
              var nodeObject = (typeof nodeDirection === "undefined" ? "undefined" : _typeof(nodeDirection)) === "object" ? Object.assign(nodeDirection, {
                degree: 0,
                inDegree: 0,
                outDegree: 0
              }) : {
                id: nodeDirection,
                inDegree: 0,
                outDegree: 0,
                degree: 0,
                createdByFrame: true
              };
              _this3.nodeHash.set(nodeDirection, nodeObject);
              projectedNodes.push(nodeObject);
            }
          });
          var edgeWeight = edge.weight || 1;
          _this3.nodeHash.get(target).inDegree += edgeWeight;
          _this3.nodeHash.get(source).outDegree += edgeWeight;
          _this3.nodeHash.get(target).degree += edgeWeight;
          _this3.nodeHash.get(source).degree += edgeWeight;

          var edgeKey = (nodeIDAccessor(source) || source) + "|" + (nodeIDAccessor(target) || target);
          var newEdge = Object.assign({}, edge, {
            source: _this3.nodeHash.get(source),
            target: _this3.nodeHash.get(target)
          });
          _this3.edgeHash.set(edgeKey, newEdge);
          projectedEdges.push(newEdge);
        });
      } else {
        this.edgeHash = new Map();
        projectedEdges.forEach(function (edge) {
          var edgeKey = (nodeIDAccessor(edge.source) || edge.source) + "|" + (nodeIDAccessor(edge.target) || edge.target);
          _this3.edgeHash.set(edgeKey, edge);
        });
      }

      if ((networkSettings.type === "sankey" || networkSettings.type === "flowchart") && topologicalSort(projectedNodes, projectedEdges) === null) {
        networkSettings.customSankey = dist_1;
      }
      networkSettings.width = size[0];
      networkSettings.height = size[1];

      var networkSettingsKeys = Object.keys(networkSettings);
      var networkSettingsChanged = false;

      networkSettingsKeys.forEach(function (key) {
        if (key !== "edgeType" && networkSettings[key] !== _this3.graphSettings[key]) {
          networkSettingsChanged = true;
        }
      });

      //Support bubble chart with circle pack and with force
      if (networkSettings.type === "sankey") {
        edgeType = function edgeType(d) {
          return d.circular ? circularAreaLink(d) : areaLink(d);
        };

        customNodeIcon = customNodeIcon ? customNodeIcon : sankeyNodeGenerator;
      } else if (networkSettings.type === "chord") {
        customNodeIcon = chordNodeGenerator(size);
        customEdgeIcon = chordEdgeGenerator(size);
      } else if (networkSettings.type === "wordcloud") {
        customNodeIcon = customNodeIcon ? customNodeIcon : wordcloudNodeGenerator;
      } else if (hierarchicalTypeHash[networkSettings.type]) {
        if (hierarchicalCustomNodeHash[networkSettings.type]) {
          customNodeIcon = hierarchicalCustomNodeHash[networkSettings.type];
          customEdgeIcon = function customEdgeIcon() {
            return null;
          };
        }
        var radialSize = adjustedSize;
        var radialCenter = [radialSize[0] / 2, radialSize[1] / 2];
        if ((networkSettings.type === "partition" || networkSettings.type === "treemap") && networkSettings.projection === "radial") {
          customNodeIcon = radialRectNodeGenerator(radialSize, radialCenter);
        }

        projectedNodes.forEach(function (node) {
          if (node.x0 !== undefined) {
            node.x = (node.x0 + node.x1) / 2;
            node.y = (node.y0 + node.y1) / 2;
          }
          if (hierarchicalProjectable[networkSettings.type] && networkSettings.projection === "horizontal") {
            var ox = node.x;
            node.x = node.y;
            node.y = ox;

            if (node.x0 !== undefined) {
              var ox0 = node.x0;
              var ox1 = node.x1;
              node.x0 = node.y0;
              node.x1 = node.y1;
              node.y0 = ox0;
              node.y1 = ox1;
            }
          } else if (radialProjectable[networkSettings.type] && networkSettings.projection === "radial") {
            var radialPoint = pointOnArcAtAngle(radialCenter, node.x / radialSize[0], node.y / 2);
            node.x = radialPoint[0];
            node.y = radialPoint[1];
          } else {
            node.x = node.x;
            node.y = node.y;
            if (node.x0 !== undefined) {
              node.x0 = node.x0;
              node.x1 = node.x1;
              node.y0 = node.y0;
              node.y1 = node.y1;
            }
          }
        });
      }

      if (changedData || networkSettingsChanged) {
        var components = [{
          componentNodes: projectedNodes,
          componentEdges: projectedEdges
        }];

        if (networkSettings.type === "chord") {
          var radius = size[1] / 2;
          var _networkSettings = networkSettings,
              _networkSettings$grou = _networkSettings.groupWidth,
              groupWidth = _networkSettings$grou === undefined ? 20 : _networkSettings$grou,
              _networkSettings$padA = _networkSettings.padAngle,
              padAngle = _networkSettings$padA === undefined ? 0.01 : _networkSettings$padA;

          var arcGenerator = arc().innerRadius(radius - groupWidth).outerRadius(radius);

          var ribbonGenerator = ribbon$1().radius(radius - groupWidth);

          var matrixifiedNetwork = matrixify({
            edgeHash: this.edgeHash,
            nodes: projectedNodes,
            edges: projectedEdges,
            edgeWidthAccessor: edgeWidthAccessor,
            nodeIDAccessor: nodeIDAccessor
          });

          var chordLayout = chord().padAngle(padAngle);

          var chords = chordLayout(matrixifiedNetwork);
          var groups = chords.groups;

          groups.forEach(function (group) {
            var groupCentroid = arcGenerator.centroid(group);
            var groupD = arcGenerator(group);
            var groupNode = projectedNodes[group.index];
            groupNode.d = groupD;
            groupNode.index = group.index;
            groupNode.x = groupCentroid[0] + size[0] / 2;
            groupNode.y = groupCentroid[1] + size[1] / 2;
          });

          chords.forEach(function (generatedChord) {
            var chordD = ribbonGenerator(generatedChord);
            //this is incorrect should use edgeHash
            var nodeSourceID = nodeIDAccessor(projectedNodes[generatedChord.source.index]);
            var nodeTargetID = nodeIDAccessor(projectedNodes[generatedChord.target.index]);
            var chordEdge = _this3.edgeHash.get(nodeSourceID + "|" + nodeTargetID);
            chordEdge.d = chordD;
          });
        } else if (networkSettings.type === "sankey" || networkSettings.type === "flowchart") {
          var _networkSettings2 = networkSettings,
              _networkSettings2$ori = _networkSettings2.orient,
              orient = _networkSettings2$ori === undefined ? "center" : _networkSettings2$ori,
              _networkSettings2$ite = _networkSettings2.iterations,
              iterations = _networkSettings2$ite === undefined ? 100 : _networkSettings2$ite,
              _networkSettings2$nod = _networkSettings2.nodePadding,
              nodePadding = _networkSettings2$nod === undefined ? 8 : _networkSettings2$nod,
              _networkSettings2$nod2 = _networkSettings2.nodeWidth,
              nodeWidth = _networkSettings2$nod2 === undefined ? networkSettings.type === "flowchart" ? 2 : 24 : _networkSettings2$nod2,
              customSankey = _networkSettings2.customSankey;

          var sankeyOrient = sankeyOrientHash[orient];

          var actualSankey = customSankey || dist_1;

          var frameExtent = [[0, 0], adjustedSize];

          if (networkSettings.direction === "up" || networkSettings.direction === "down") {
            frameExtent = [[0, 0], [adjustedSize[1], adjustedSize[0]]];
          }

          //Temporary fix for when sankey-circular sets the size incorrectly
          var initialSettings = actualSankey().extent(frameExtent).links(projectedEdges).nodes(projectedNodes).nodeAlign(sankeyOrient).nodeId(nodeIDAccessor).nodePadding(nodePadding).nodeWidth(nodeWidth).iterations(1);

          initialSettings();

          var circularEdges = projectedEdges.filter(function (d) {
            return d.circular === true;
          });

          if (circularEdges.length === 0) {
            frameExtent = [[0, -frameExtent[1][1]], [frameExtent[1][0], frameExtent[1][1]]];
          } else if (!circularEdges.find(function (d) {
            return d.circularLinkType === "top";
          })) {
            var bottomEdges = circularEdges.filter(function (d) {
              return d.circularLinkType === "bottom";
            });

            var offset = bottomEdges.map(function (d) {
              return d.circularPathData.leftLargeArcRadius;
            }).reduce(function (p, c) {
              return p + c;
            });
            frameExtent = [[0, -frameExtent[1][1]], [frameExtent[1][0], frameExtent[1][1] - offset]];
          }
          //End temporary

          var frameSankey = actualSankey().extent(frameExtent).links(projectedEdges).nodes(projectedNodes).nodeAlign(sankeyOrient).nodeId(nodeIDAccessor).nodePadding(nodePadding).nodeWidth(nodeWidth).iterations(iterations);

          frameSankey();

          projectedNodes.forEach(function (d) {
            d.height = d.y1 - d.y0;
            d.width = d.x1 - d.x0;
            d.x = d.x0 + d.width / 2;
            d.y = d.y0 + d.height / 2;
            d.radius = d.height / 2;
          });

          projectedEdges.forEach(function (d) {
            d.sankeyWidth = d.width;
            d.width = undefined;
          });
        } else if (networkSettings.type === "wordcloud") {
          var _networkSettings3 = networkSettings,
              _networkSettings3$ite = _networkSettings3.iterations,
              _iterations = _networkSettings3$ite === undefined ? 500 : _networkSettings3$ite,
              _networkSettings3$fon = _networkSettings3.fontSize,
              fontSize = _networkSettings3$fon === undefined ? 18 : _networkSettings3$fon,
              rotate = _networkSettings3.rotate,
              _networkSettings3$fon2 = _networkSettings3.fontWeight,
              fontWeight = _networkSettings3$fon2 === undefined ? 300 : _networkSettings3$fon2,
              _networkSettings3$tex = _networkSettings3.textAccessor,
              textAccessor = _networkSettings3$tex === undefined ? function (d) {
            return d.text;
          } : _networkSettings3$tex;

          var fontWeightMod = (fontWeight / 300 - 1) / 5 + 1;
          var fontWidth = fontSize / 1.5 * fontWeightMod;

          nodes.forEach(function (d, i) {
            var calcualatedNodeSize = nodeSizeAccessor(d);
            d._NWFText = textAccessor(d);
            var textWidth = fontWidth * d._NWFText.length * calcualatedNodeSize * 1.4;
            var textHeight = fontSize * calcualatedNodeSize;

            d.textHeight = textHeight + 4;
            d.textWidth = textWidth + 4;
            d.rotate = rotate ? rotate(d, i) : 0;
            d.fontSize = fontSize * calcualatedNodeSize;
            d.fontWeight = fontWeight;
            d.radius = d.r = textWidth / 2;
          });

          nodes.sort(function (a, b) {
            return b.textWidth - a.textWidth;
          });

          //bubblepack for initial position
          packSiblings(nodes);

          //        if (rotate) {
          var collide = bboxCollide(function (d) {
            if (d.rotate) {
              return [[-d.textHeight / 2, -d.textWidth / 2], [d.textHeight / 2, d.textWidth / 2]];
            }
            return [[-d.textWidth / 2, -d.textHeight / 2], [d.textWidth / 2, d.textHeight / 2]];
          }).iterations(1);

          var xCenter = size[0] / 2;
          var yCenter = size[1] / 2;

          var simulation = _default(nodes).velocityDecay(0.6).force("x", forceX(xCenter).strength(1.2)).force("y", forceY(yCenter).strength(1.2)).force("collide", collide);

          simulation.stop();

          for (var i = 0; i < _iterations; ++i) {
            simulation.tick();
          } //      }

          var xMin = min(projectedNodes.map(function (p) {
            return p.x - (p.rotate ? p.textHeight / 2 : p.textWidth / 2);
          }));
          var xMax = max(projectedNodes.map(function (p) {
            return p.x + (p.rotate ? p.textHeight / 2 : p.textWidth / 2);
          }));
          var yMin = min(projectedNodes.map(function (p) {
            return p.y - (p.rotate ? p.textWidth / 2 : p.textHeight / 2);
          }));
          var yMax = max(projectedNodes.map(function (p) {
            return p.y + (p.rotate ? p.textWidth / 2 : p.textHeight / 2);
          }));
          var projectionScaleX = linear$2().domain([xMin, xMax]).range([0, adjustedSize[0]]);
          var projectionScaleY = linear$2().domain([yMin, yMax]).range([0, adjustedSize[1]]);
          var xMod = adjustedSize[0] / xMax;
          var yMod = adjustedSize[1] / yMax;

          var sizeMod = Math.min(xMod, yMod) * 1.2;
          projectedNodes.forEach(function (node) {
            node.x = projectionScaleX(node.x);
            node.y = projectionScaleY(node.y);
            node.fontSize = node.fontSize * sizeMod;
            node.scale = 1;
            node.radius = node.r = Math.max(node.textHeight / 4 * yMod, node.textWidth / 4 * xMod);
            //      node.textHeight = projectionScaleY(node.textHeight)
            //      node.textWidth = projectionScaleY(node.textWidth)
          });
        } else if (networkSettings.type === "force") {
          var _networkSettings4 = networkSettings,
              _networkSettings4$ite = _networkSettings4.iterations,
              _iterations2 = _networkSettings4$ite === undefined ? 500 : _networkSettings4$ite,
              _networkSettings4$edg = _networkSettings4.edgeStrength,
              edgeStrength = _networkSettings4$edg === undefined ? 0.1 : _networkSettings4$edg,
              _networkSettings4$dis = _networkSettings4.distanceMax,
              distanceMax = _networkSettings4$dis === undefined ? Infinity : _networkSettings4$dis,
              edgeDistance = _networkSettings4.edgeDistance;

          var linkForce = forceLink().strength(function (d) {
            return d.weight ? d.weight * edgeStrength : edgeStrength;
          });

          if (edgeDistance) {
            linkForce.distance(edgeDistance);
          }

          var _simulation = networkSettings.simulation || _default().force("charge", forceManyBody().distanceMax(distanceMax).strength(networkSettings.forceManyBody || function (d) {
            return -25 * nodeSizeAccessor(d);
          }));

          //        simulation.force("link", linkForce).nodes(projectedNodes)

          _simulation.nodes(projectedNodes);

          if (!_simulation.force("x")) {
            _simulation.force("x", forceX(size[0] / 2));
          }
          if (!_simulation.force("y")) {
            _simulation.force("y", forceY(size[1] / 2));
          }

          if (projectedEdges.length !== 0 && !_simulation.force("link")) {
            _simulation.force("link", linkForce);
            _simulation.force("link").links(projectedEdges);
          }

          //reset alpha if it's too cold
          if (_simulation.alpha() < 0.1) {
            _simulation.alpha(1);
          }

          _simulation.stop();

          for (var _i = 0; _i < _iterations2; ++_i) {
            _simulation.tick();
          }
        } else if (networkSettings.type === "motifs") {
          var componentHash = new Map();
          projectedEdges.forEach(function (edge) {
            [edge.source, edge.target].forEach(function (node) {
              if (!componentHash.get(node)) {
                componentHash.set(node, {
                  node: node,
                  component: null,
                  connectedNodes: [],
                  edges: []
                });
              }
            });
            componentHash.get(edge.source).connectedNodes.push(edge.target);
            componentHash.get(edge.target).connectedNodes.push(edge.source);
            componentHash.get(edge.source).edges.push(edge);
          });

          components = breadthFirstCompontents(projectedNodes, componentHash);

          var largestComponent = Math.max(projectedNodes.length / 3, components[0].componentNodes.length);

          var _layoutSize = size[0] > size[1] ? size[1] : size[0];
          var layoutDirection = size[0] > size[1] ? "horizontal" : "vertical";

          //        louvain.assign(graph)

          var _networkSettings5 = networkSettings,
              _networkSettings5$ite = _networkSettings5.iterations,
              _iterations3 = _networkSettings5$ite === undefined ? 500 : _networkSettings5$ite,
              _networkSettings5$edg = _networkSettings5.edgeStrength,
              _edgeStrength = _networkSettings5$edg === undefined ? 0.1 : _networkSettings5$edg,
              _edgeDistance = _networkSettings5.edgeDistance;

          var currentX = 0;
          var currentY = 0;

          components.forEach(function (_ref2) {
            var componentNodes = _ref2.componentNodes,
                componentEdges = _ref2.componentEdges;

            var linkForce = forceLink().strength(function (d) {
              return d.weight ? d.weight * _edgeStrength : _edgeStrength;
            });

            if (_edgeDistance) {
              linkForce.distance(_edgeDistance);
            }

            var componentLayoutSize = Math.max(componentNodes.length / largestComponent, 0.2) * _layoutSize;

            var xBound = componentLayoutSize + currentX;
            var yBound = componentLayoutSize + currentY;

            if (layoutDirection === "horizontal") {
              if (yBound > size[1]) {
                currentX = componentLayoutSize + currentX;
                currentY = componentLayoutSize;
              } else {
                currentY = componentLayoutSize + currentY;
              }
            } else {
              if (xBound > size[0]) {
                currentY = componentLayoutSize + currentY;
                currentX = componentLayoutSize;
              } else {
                currentX = componentLayoutSize + currentX;
              }
            }

            var xCenter = currentX - componentLayoutSize / 2;
            var yCenter = currentY - componentLayoutSize / 2;

            var simulation = _default().force("charge", forceManyBody().strength(networkSettings.forceManyBody || function (d) {
              return -25 * nodeSizeAccessor(d);
            })).force("link", linkForce);

            simulation.force("x", forceX(xCenter)).force("y", forceY(yCenter)).nodes(componentNodes);

            simulation.force("link").links(componentEdges);

            simulation.stop();

            for (var _i2 = 0; _i2 < _iterations3; ++_i2) {
              simulation.tick();
            }var maxX = max(componentNodes.map(function (d) {
              return d.x;
            }));
            var maxY = max(componentNodes.map(function (d) {
              return d.y;
            }));
            var minX = min(componentNodes.map(function (d) {
              return d.x;
            }));
            var minY = min(componentNodes.map(function (d) {
              return d.y;
            }));

            var resetX = linear$2().domain([minX, maxX]).range([currentX - componentLayoutSize, currentX - 20]);
            var resetY = linear$2().domain([minY, maxY]).range([currentY - componentLayoutSize, currentY - 20]);

            componentNodes.forEach(function (node) {
              node.x = resetX(node.x);
              node.y = resetY(node.y);
            });
          });
        } else if (typeof networkSettings.type === "function") {
          networkSettings.type({
            nodes: projectedNodes,
            edges: projectedEdges
          });
        } else {
          projectedNodes.forEach(function (node) {
            node.x = node.x === undefined ? (node.x0 + node.x1) / 2 : node.x;
            node.y = node.y === undefined ? node.y0 : node.y;
          });
        }

        this.graphSettings = networkSettings;
        this.graphSettings.nodes = currentProps.nodes;
        this.graphSettings.edges = currentProps.edges;
      }

      if (networkSettings.type === "flowchart") {
        if (networkSettings.direction === "up") {
          projectedNodes.forEach(function (node) {
            var ox = node.x;
            node.x = node.y;
            node.y = adjustedSize[1] - ox;
          });
        } else if (networkSettings.direction === "down") {
          projectedNodes.forEach(function (node) {
            var ox = node.x;
            node.x = node.y;
            node.y = ox;
          });
        } else if (networkSettings.direction === "left") {
          projectedNodes.forEach(function (node) {
            node.x = adjustedSize[0] - node.x;
          });
        }
      }
      if (networkSettings.zoom !== false && networkSettings.type !== "wordcloud" && networkSettings.type !== "chord" && networkSettings.type !== "sankey" && (hierarchicalTypeHash[networkSettings.type] === undefined || networkSettings.nodeSize)) {
        var _xMin = min(projectedNodes.map(function (p) {
          return p.x - nodeSizeAccessor(p);
        }));
        var _xMax = max(projectedNodes.map(function (p) {
          return p.x + nodeSizeAccessor(p);
        }));
        var _yMin = min(projectedNodes.map(function (p) {
          return p.y - nodeSizeAccessor(p);
        }));
        var _yMax = max(projectedNodes.map(function (p) {
          return p.y + nodeSizeAccessor(p);
        }));

        var _projectionScaleX = linear$2().domain([_xMin, _xMax]).range([0, adjustedSize[0]]);
        var _projectionScaleY = linear$2().domain([_yMin, _yMax]).range([0, adjustedSize[1]]);
        projectedNodes.forEach(function (node) {
          node.x = _projectionScaleX(node.x);
          node.y = _projectionScaleY(node.y);
        });
      }

      projectedNodes.forEach(function (node) {
        node.nodeSize = nodeSizeAccessor(node);
      });

      projectedEdges.forEach(function (edge) {
        edge.width = edgeWidthAccessor(edge);
      });

      var legendSettings = void 0;

      if (currentProps.legend) {
        legendSettings = currentProps.legend === true ? {} : currentProps.legend;
        if (!legendSettings.legendGroups) {
          ///Something auto for networks
          var legendGroups = [{
            styleFn: currentProps.nodeStyle,
            type: "fill",
            items: []
          }];
          legendSettings.legendGroups = legendGroups;
        }
      }

      var networkFrameRender = {
        edges: {
          data: projectedEdges,
          styleFn: stringToFn(edgeStyle, function () {
            return {};
          }, true),
          classFn: stringToFn(edgeClass, function () {
            return "";
          }, true),
          renderMode: stringToFn(edgeRenderMode, undefined, true),
          canvasRenderFn: stringToFn(canvasEdges, undefined, true),
          renderKeyFn: currentProps.edgeRenderKey ? currentProps.edgeRenderKey : function (d) {
            return d._NWFEdgeKey || d.source.id + "-" + d.target.id;
          },
          behavior: drawEdges,
          type: edgeType,
          customMark: customEdgeIcon
        },
        nodes: {
          data: projectedNodes,
          styleFn: nodeStyleFn,
          classFn: nodeClassFn,
          renderMode: nodeRenderModeFn,
          canvasRenderFn: nodeCanvasRenderFn,
          customMark: customNodeIcon,
          behavior: drawNodes,
          renderKeyFn: currentProps.nodeRenderKey
        }
      };

      var nodeLabelAnnotations = [];
      if (this.props.nodeLabels && projectedNodes) {
        projectedNodes.forEach(function (node, nodei) {
          if (nodeLabels === true || nodeLabels && nodeLabels(node, nodei)) {
            var actualLabel = nodeLabels === true ? nodeIDAccessor(node, nodei) : nodeLabels(node, nodei);

            var nodeLabel = void 0;

            if (React.isValidElement(actualLabel)) {
              nodeLabel = {
                type: "basic-node-label",
                x: node.x,
                y: node.y,
                element: actualLabel
              };
            } else {
              nodeLabel = {
                className: "node-label",
                dx: 0,
                dy: 0,
                x: node.x,
                y: node.y,
                note: { label: actualLabel },
                connector: { end: "none" },
                type: lib_10,
                subject: { radius: nodeSizeAccessor(node) + 2 }
              };
            }

            nodeLabelAnnotations.push(nodeLabel);
          }
        });
      }

      var projectedXYPoints = void 0;

      if (hoverAnnotation === "edge" && edgePointHash[networkSettings.type]) {
        projectedXYPoints = projectedEdges.map(edgePointHash[networkSettings.type]);
      } else if (hoverAnnotation === true || hoverAnnotation === "node") {
        projectedXYPoints = projectedNodes;
      } else if (hoverAnnotation === "all") {
        projectedXYPoints = [].concat(toConsumableArray(projectedEdges.map(edgePointHash[networkSettings.type])), toConsumableArray(projectedNodes));
      }

      this.setState({
        voronoiHover: null,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        backgroundGraphics: currentProps.backgroundGraphics,
        foregroundGraphics: currentProps.foregroundGraphics,
        title: title,
        renderNumber: this.state.renderNumber + 1,
        nodeData: null,
        edgeData: null,
        projectedNodes: projectedNodes,
        projectedEdges: projectedEdges,
        projectedXYPoints: projectedXYPoints,
        nodeIDAccessor: nodeIDAccessor,
        sourceAccessor: sourceAccessor,
        targetAccessor: targetAccessor,
        nodeSizeAccessor: nodeSizeAccessor,
        edgeWidthAccessor: edgeWidthAccessor,
        margin: margin,
        legendSettings: legendSettings,
        networkFrameRender: networkFrameRender,
        nodeLabelAnnotations: nodeLabelAnnotations
      });
    }
  }, {
    key: "defaultNetworkSVGRule",
    value: function defaultNetworkSVGRule(_ref3) {
      var d = _ref3.d,
          i = _ref3.i;
      var _state2 = this.state,
          projectedNodes = _state2.projectedNodes,
          nodeIDAccessor = _state2.nodeIDAccessor,
          nodeSizeAccessor = _state2.nodeSizeAccessor;
      var svgAnnotationRules = this.props.svgAnnotationRules;


      if (svgAnnotationRules) {
        var customAnnotation = svgAnnotationRules({
          d: d,
          i: i,
          networkFrameProps: this.props,
          networkFrameState: this.state,
          nodes: this.state.projectedNodes,
          edges: this.state.projectedEdges
        });
        if (customAnnotation !== null) {
          return customAnnotation;
        }
      }
      if (d.type === "node") {
        return svgNodeRule({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "basic-node-label") {
        return React.createElement(
          "g",
          { transform: "translate(" + d.x + "," + d.y + ")" },
          d.element
        );
      } else if (d.type === "react-annotation" || typeof d.type === "function") {
        return svgReactAnnotationRule({
          d: d,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor
        });
      } else if (d.type === "enclose") {
        return svgEncloseRule$1({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      } else if (d.type === "enclose-rect") {
        return svgRectEncloseRule$2({
          d: d,
          i: i,
          projectedNodes: projectedNodes,
          nodeIDAccessor: nodeIDAccessor,
          nodeSizeAccessor: nodeSizeAccessor
        });
      }
      return null;
    }
  }, {
    key: "defaultNetworkHTMLRule",
    value: function defaultNetworkHTMLRule(_ref4) {
      var d = _ref4.d,
          i = _ref4.i;
      var _props = this.props,
          tooltipContent = _props.tooltipContent,
          size = _props.size;

      if (this.props.htmlAnnotationRules) {
        var customAnnotation = this.props.htmlAnnotationRules({
          d: d,
          i: i,
          networkFrameProps: this.props,
          networkFrameState: this.state,
          nodes: this.state.projectedNodes,
          edges: this.state.projectedEdges
        });
        if (customAnnotation !== null) {
          return customAnnotation;
        }
      }
      if (d.type === "frame-hover") {
        return htmlFrameHoverRule$1({ d: d, i: i, tooltipContent: tooltipContent, size: size });
      }
      return null;
    }
  }, {
    key: "render",
    value: function render() {
      return this.renderBody({});
    }
  }, {
    key: "renderBody",
    value: function renderBody(_ref5) {
      var afterElements = _ref5.afterElements;
      var _props2 = this.props,
          annotations = _props2.annotations,
          annotationSettings = _props2.annotationSettings,
          className = _props2.className,
          customClickBehavior = _props2.customClickBehavior,
          customDoubleClickBehavior = _props2.customDoubleClickBehavior,
          customHoverBehavior = _props2.customHoverBehavior,
          size = _props2.size,
          matte = _props2.matte,
          renderKey = _props2.renderKey,
          hoverAnnotation = _props2.hoverAnnotation,
          beforeElements = _props2.beforeElements,
          interaction = _props2.interaction,
          title = _props2.title,
          disableContext = _props2.disableContext,
          canvasPostProcess = _props2.canvasPostProcess,
          baseMarkProps = _props2.baseMarkProps,
          useSpans = _props2.useSpans;
      var _state3 = this.state,
          backgroundGraphics = _state3.backgroundGraphics,
          foregroundGraphics = _state3.foregroundGraphics,
          projectedXYPoints = _state3.projectedXYPoints,
          margin = _state3.margin,
          legendSettings = _state3.legendSettings,
          adjustedPosition = _state3.adjustedPosition,
          adjustedSize = _state3.adjustedSize,
          networkFrameRender = _state3.networkFrameRender,
          nodeLabelAnnotations = _state3.nodeLabelAnnotations;


      var downloadButton = [];

      if (this.props.download && this.state.projectedNodes.length > 0) {
        downloadButton.push(React.createElement(DownloadButton, {
          key: "network-download-nodes",
          csvName: (this.props.name || "networkframe") + "-" + new Date().toJSON(),
          width: this.props.size[0],
          label: "Download Node List",
          data: networkNodeDownloadMapping({
            data: this.state.projectedNodes,
            fields: this.props.downloadFields
          })
        }));
      }
      if (this.props.download && this.state.projectedEdges.length > 0) {
        downloadButton.push(React.createElement(DownloadButton, {
          key: "network-download-edges",
          csvName: (this.props.name || "networkframe") + "-" + new Date().toJSON(),
          width: this.props.size[0],
          label: "Download Edge List",
          data: networkEdgeDownloadMapping({
            data: this.state.projectedEdges,
            fields: this.props.downloadFields
          })
        }));
      }

      var finalFilterDefs = filterDefs({
        key: "networkFrame",
        additionalDefs: this.props.additionalDefs
      });

      return React.createElement(Frame, {
        name: "networkframe",
        renderPipeline: networkFrameRender,
        adjustedPosition: adjustedPosition,
        adjustedSize: adjustedSize,
        size: size,
        xScale: xScale$1,
        yScale: yScale$1,
        title: title,
        matte: matte,
        className: className,
        finalFilterDefs: finalFilterDefs,
        frameKey: "none",
        renderKeyFn: renderKey,
        projectedCoordinateNames: projectedCoordinateNames$1,
        defaultSVGRule: this.defaultNetworkSVGRule.bind(this),
        defaultHTMLRule: this.defaultNetworkHTMLRule.bind(this),
        hoverAnnotation: !!hoverAnnotation,
        annotations: [].concat(toConsumableArray(annotations), toConsumableArray(nodeLabelAnnotations)),
        annotationSettings: annotationSettings,
        legendSettings: legendSettings,
        interaction: interaction,
        customClickBehavior: customClickBehavior,
        customHoverBehavior: customHoverBehavior,
        customDoubleClickBehavior: customDoubleClickBehavior,
        points: projectedXYPoints,
        margin: margin,
        backgroundGraphics: backgroundGraphics,
        foregroundGraphics: foregroundGraphics,
        beforeElements: beforeElements,
        afterElements: afterElements,
        downloadButton: downloadButton,
        disableContext: disableContext,
        canvasPostProcess: canvasPostProcess,
        baseMarkProps: baseMarkProps,
        useSpans: useSpans
      });
    }
  }]);
  return NetworkFrame;
}(React.Component);

NetworkFrame.defaultProps = {
  annotations: [],
  foregroundGraphics: [],
  annotationSettings: {},
  size: [500, 500],
  className: "",
  name: "networkframe",
  edges: [],
  nodes: [],
  networkType: { type: "force", iterations: 500 }
};


NetworkFrame.propTypes = {
  name: propTypes.string,
  nodes: propTypes.array,
  edges: propTypes.oneOfType([propTypes.array, propTypes.object]),
  title: propTypes.oneOfType([propTypes.string, propTypes.object]),
  margin: propTypes.oneOfType([propTypes.number, propTypes.object]),
  size: propTypes.array,
  position: propTypes.array,
  nodeIDAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  sourceAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  targetAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  nodeSizeAccessor: propTypes.oneOfType([propTypes.string, propTypes.number, propTypes.func]),
  nodeLabels: propTypes.oneOfType([propTypes.bool, propTypes.func]),
  edgeWidthAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  annotations: propTypes.array,
  customHoverBehavior: propTypes.func,
  customClickBehavior: propTypes.func,
  customDoubleClickBehavior: propTypes.func,
  htmlAnnotationRules: propTypes.func,
  networkType: propTypes.oneOfType([propTypes.string, propTypes.object]),
  tooltipContent: propTypes.func,
  className: propTypes.string,
  additionalDefs: propTypes.oneOfType([propTypes.array, propTypes.object]),
  interaction: propTypes.object,
  baseMarkProps: propTypes.object,
  renderFn: propTypes.oneOfType([propTypes.string, propTypes.func]),
  nodeStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  edgeStyle: propTypes.oneOfType([propTypes.object, propTypes.func]),
  hoverAnnotation: propTypes.oneOfType([propTypes.object, propTypes.array, propTypes.func, propTypes.bool, propTypes.string]),
  canvasPostProcess: propTypes.oneOfType([propTypes.func, propTypes.string]),
  backgroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array]),
  foregroundGraphics: propTypes.oneOfType([propTypes.object, propTypes.array]),
  customNodeIcon: propTypes.func,
  edgeType: propTypes.oneOfType([propTypes.string, propTypes.func])
};

// components
var MinimapNetworkFrame = function (_NetworkFrame) {
  inherits(MinimapNetworkFrame, _NetworkFrame);

  function MinimapNetworkFrame(props) {
    classCallCheck(this, MinimapNetworkFrame);

    var _this = possibleConstructorReturn(this, (MinimapNetworkFrame.__proto__ || Object.getPrototypeOf(MinimapNetworkFrame)).call(this, props));

    _this.generateMinimap = _this.generateMinimap.bind(_this);
    return _this;
  }

  createClass(MinimapNetworkFrame, [{
    key: "generateMinimap",
    value: function generateMinimap() {
      var miniDefaults = {
        title: "",
        position: [0, 0],
        size: [this.props.size[0] * 5, this.props.size[1] * 5],
        edges: this.props.edges,
        nodes: this.props.nodes,
        xBrushable: true,
        yBrushable: true,
        brushStart: function brushStart() {},
        brush: function brush() {},
        brushEnd: function brushEnd() {}
      };

      var combinedOptions = Object.assign(miniDefaults, this.props.minimap);

      combinedOptions.hoverAnnotation = false;

      return React.createElement(MiniMap, combinedOptions);
    }
  }, {
    key: "render",
    value: function render() {
      var miniMap = this.generateMinimap();
      var options = {};
      if (this.props.renderBefore) {
        options.beforeElements = miniMap;
      } else {
        options.afterElements = miniMap;
      }

      return this.renderBody(options);
    }
  }]);
  return MinimapNetworkFrame;
}(NetworkFrame);

MinimapNetworkFrame.propTypes = {
  size: propTypes.array,
  xAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  yAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  points: propTypes.array,
  lines: propTypes.array,
  areas: propTypes.array,
  lineDataAccessor: propTypes.oneOfType([propTypes.string, propTypes.func]),
  lineType: propTypes.oneOfType([propTypes.string, propTypes.object]),
  minimap: propTypes.object,
  renderBefore: propTypes.oneOfType([propTypes.array, propTypes.object])
};

var exports$1 = function exports(element, fn) {
  var window = this;
  var document = window.document;
  var isIE;
  var requestFrame;

  var attachEvent = document.attachEvent;
  if (typeof navigator !== 'undefined') {
    isIE = navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/Edge/);
  }

  requestFrame = function () {
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function fallbackRAF(func) {
      return window.setTimeout(func, 20);
    };
    return function requestFrameFunction(func) {
      return raf(func);
    };
  }();

  var cancelFrame = function () {
    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
    return function cancelFrameFunction(id) {
      return cancel(id);
    };
  }();

  function resizeListener(e) {
    var win = e.target || e.srcElement;
    if (win.__resizeRAF__) {
      cancelFrame(win.__resizeRAF__);
    }
    win.__resizeRAF__ = requestFrame(function () {
      var trigger = win.__resizeTrigger__;
      if (trigger !== undefined) {
        trigger.__resizeListeners__.forEach(function (fn) {
          fn.call(trigger, e);
        });
      }
    });
  }

  function objectLoad() {
    this.contentDocument.defaultView.__resizeTrigger__ = this.__resizeElement__;
    this.contentDocument.defaultView.addEventListener('resize', resizeListener);
  }

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    if (attachEvent) {
      element.__resizeTrigger__ = element;
      element.attachEvent('onresize', resizeListener);
    } else {
      if (getComputedStyle(element).position === 'static') {
        element.style.position = 'relative';
      }
      var obj = element.__resizeTrigger__ = document.createElement('object');
      obj.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1; opacity: 0;');
      obj.setAttribute('class', 'resize-sensor');
      obj.__resizeElement__ = element;
      obj.onload = objectLoad;
      obj.type = 'text/html';
      if (isIE) {
        element.appendChild(obj);
      }
      obj.data = 'about:blank';
      if (!isIE) {
        element.appendChild(obj);
      }
    }
  }
  element.__resizeListeners__.push(fn);
};

var unbind = function unbind(element, fn) {
  var attachEvent = document.attachEvent;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
  if (!element.__resizeListeners__.length) {
    if (attachEvent) {
      element.detachEvent('onresize', resizeListener);
    } else {
      element.__resizeTrigger__.contentDocument.defaultView.removeEventListener('resize', resizeListener);
      element.__resizeTrigger__ = !element.removeChild(element.__resizeTrigger__);
    }
  }
};

var elementResizeEvent = typeof window === 'undefined' ? exports$1 : exports$1.bind(window);

elementResizeEvent.unbind = unbind;

var createResponsiveFrame = function createResponsiveFrame(Frame) {
  var _class, _temp;

  return _temp = _class = function (_React$Component) {
    inherits(ResponsiveFrame, _React$Component);

    function ResponsiveFrame(props) {
      classCallCheck(this, ResponsiveFrame);

      var _this = possibleConstructorReturn(this, (ResponsiveFrame.__proto__ || Object.getPrototypeOf(ResponsiveFrame)).call(this, props));

      _this._onResize = function (width, height) {
        _this.setState({ containerHeight: height, containerWidth: width });
      };

      _this.state = {
        containerHeight: undefined,
        containerWidth: undefined
      };
      return _this;
    }

    createClass(ResponsiveFrame, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        var element = this.node;
        elementResizeEvent(element, function () {
          _this2.setState({
            containerHeight: element.offsetHeight,
            containerWidth: element.offsetWidth
          });
        });
        this.setState({
          containerHeight: element.offsetHeight,
          containerWidth: element.offsetWidth
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var _props = this.props,
            responsiveWidth = _props.responsiveWidth,
            responsiveHeight = _props.responsiveHeight,
            size = _props.size,
            dataVersion = _props.dataVersion,
            _props$style = _props.style,
            style = _props$style === undefined ? {} : _props$style;
        var _state = this.state,
            containerHeight = _state.containerHeight,
            containerWidth = _state.containerWidth;


        var actualSize = [].concat(toConsumableArray(size));

        var returnEmpty = false;

        if (responsiveWidth) {
          if (!containerWidth) returnEmpty = true;
          actualSize[0] = containerWidth;
        }

        if (responsiveHeight) {
          if (!containerHeight) returnEmpty = true;
          actualSize[1] = containerHeight;
        }

        var dataVersionWithSize = dataVersion + actualSize.toString();

        return React.createElement(
          "div",
          {
            className: "responsive-container",
            style: Object.assign({ height: "100%", width: "100%" }, style),
            ref: function ref(node) {
              return _this3.node = node;
            }
          },
          !returnEmpty && React.createElement(Frame, _extends({}, this.props, {
            size: actualSize,
            dataVersion: dataVersion ? dataVersionWithSize : undefined
          }))
        );
      }
    }]);
    return ResponsiveFrame;
  }(React.Component), _class.propTypes = {
    size: propTypes.array
  }, _class.defaultProps = {
    size: [500, 500]
  }, _temp;
};

var ResponsiveXYFrame = createResponsiveFrame(XYFrame);
var ResponsiveOrdinalFrame = createResponsiveFrame(OrdinalFrame);
var ResponsiveORFrame = createResponsiveFrame(OrdinalFrame);
var ResponsiveNetworkFrame = createResponsiveFrame(NetworkFrame);
var ResponsiveMinimapXYFrame = createResponsiveFrame(MinimapXYFrame);

var SmartFrame = (function (props) {
  if (props.frameType === "orFrame") {
    return React.createElement(OrdinalFrame, _extends({}, props, {
      oAccessor: props.xAccessor,
      rAccessor: props.yAccessor,
      data: props.pieceData,
      groupData: props.aggData,
      groupDataAccessor: props.aggDataAccessor,
      dataAccessor: props.pieceDataAccessor,
      groupType: props.customAggType,
      groupStyle: props.aggStyle,
      style: props.pieceStyle,
      type: props.customPieceType
    }));
  }
  return React.createElement(XYFrame, _extends({}, props, {
    points: props.pieceData,
    lines: props.aggData,
    lineDataAccessor: props.aggDataAccessor,
    pointDataAccessor: props.pieceDataAccessor,
    lineType: props.customAggType,
    lineStyle: props.aggStyle,
    pointStyle: props.pieceStyle
  }));
});

function sparkNetworkSettings() {
  var originalSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'force';

  var finalSettings = {};
  if (originalSettings) {
    finalSettings = originalSettings;
    if (originalSettings === 'force') finalSettings = { type: 'force' };

    return _extends({
      edgeStrength: 2,
      edgeDistance: 5,
      nodePadding: 1,
      nodeWidth: 5,
      groupWidth: 4
    }, finalSettings);
  }
  return originalSettings;
}

var axisDefaults = {
  tickFormat: function tickFormat() {
    return '';
  },
  baseline: false
};

var allFrameDefaults = {
  margin: 0
};

function simpleValueAccessor(props, d) {
  var value = d.y;
  if (props.yAccessor) value = typeof props.yAccessor === 'string' ? d[props.yAccessor] : props.yAccessor(d);

  return value.toString ? value.toString() : value;
}

var xyFrameDefaults = function xyFrameDefaults(props) {
  return _extends({}, allFrameDefaults, props, {
    hoverAnnotation: props.hoverAnnotation === true ? [function (d) {
      return {
        type: 'react-annotation',
        label: simpleValueAccessor(props, d),
        dx: 50,
        dy: -50
      };
    }] : props.hoverAnnotation,
    axes: props.axes ? props.axes.map(function (a) {
      return _extends({}, axisDefaults, a);
    }) : props.axes
  });
};

var ordinalFrameDefaults = function ordinalFrameDefaults(props) {
  return _extends({}, allFrameDefaults, props, {
    //  hoverAnnotation: props.hoverAnnotation === true ? [{ type: "react-annotation"}] : props.hoverAnnotation,
    axis: props.axis ? _extends({ axisDefaults: axisDefaults }, props.axis) : props.axis
  });
};

var networkFrameDefaults = function networkFrameDefaults(props) {
  return _extends({}, allFrameDefaults, {
    nodeSizeAccessor: 2
  }, props, {
    networkType: sparkNetworkSettings(props.networkType)
    //  hoverAnnotation: props.hoverAnnotation === true ? [{ type: "react-annotation"}] : props.hoverAnnotation,
  });
};

var createSparkFrame = function createSparkFrame(Frame, defaults$$1) {
  var _class, _temp;

  return _temp = _class = function (_React$Component) {
    inherits(SparkFrame, _React$Component);

    function SparkFrame(props) {
      classCallCheck(this, SparkFrame);

      var _this = possibleConstructorReturn(this, (SparkFrame.__proto__ || Object.getPrototypeOf(SparkFrame)).call(this, props));

      _this._onResize = function (width, height) {
        _this.setState({ containerHeight: height, containerWidth: width });
      };

      _this.state = {
        containerHeight: props.size[1],
        containerWidth: props.size[0]
      };
      return _this;
    }

    createClass(SparkFrame, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var element = this.node;
        var lineHeight = +window.getComputedStyle(element).lineHeight.split('px')[0] - 5;

        this.setState({
          containerHeight: isNaN(lineHeight) ? element.offsetHeight : lineHeight,
          containerWidth: element.offsetWidth
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            size = _props.size,
            _props$style = _props.style,
            style = _props$style === undefined ? {} : _props$style;
        var _state$containerHeigh = this.state.containerHeight,
            containerHeight = _state$containerHeigh === undefined ? 30 : _state$containerHeigh;


        var actualSize = [];

        actualSize[0] = typeof size === 'number' ? size : size[0] ? size[0] : containerHeight;
        actualSize[1] = containerHeight;

        return React.createElement(
          'span',
          {
            style: Object.assign({
              width: actualSize[0] + 'px',
              height: actualSize[1] + 'px',
              display: 'inline-block',
              marginLeft: '5px',
              marginRight: '5px'
            }, style),
            ref: function ref(node) {
              return _this2.node = node;
            }
          },
          React.createElement(Frame, _extends({}, defaults$$1(this.props), { size: actualSize, useSpans: true }))
        );
      }
    }]);
    return SparkFrame;
  }(React.Component), _class.propTypes = {
    size: propTypes.array
  }, _class.defaultProps = {
    size: []
  }, _temp;
};

var SparkXYFrame = createSparkFrame(XYFrame, xyFrameDefaults);
var SparkOrdinalFrame = createSparkFrame(OrdinalFrame, ordinalFrameDefaults);
var SparkNetworkFrame = createSparkFrame(NetworkFrame, networkFrameDefaults);
var SparkSmartFrame = createSparkFrame(SmartFrame, {});

var ORFrame = OrdinalFrame;

var index = {
  AnnotationLayer: AnnotationLayer,
  DividedLine: DividedLine,
  XYFrame: XYFrame,
  MinimapXYFrame: MinimapXYFrame,
  MinimapNetworkFrame: MinimapNetworkFrame,
  MiniMap: MiniMap,
  Brush: Brush,
  Axis: Axis,
  InteractionLayer: InteractionLayer,
  VisualizationLayer: VisualizationLayer,
  OrdinalFrame: OrdinalFrame,
  ORFrame: ORFrame,
  funnelize: funnelize,
  calculateDataExtent: calculateDataExtent,
  Annotation: SemioticAnnotation,
  NetworkFrame: NetworkFrame,
  ResponsiveMinimapXYFrame: ResponsiveMinimapXYFrame,
  ResponsiveOrdinalFrame: ResponsiveOrdinalFrame,
  ResponsiveORFrame: ResponsiveORFrame,
  ResponsiveNetworkFrame: ResponsiveNetworkFrame,
  ResponsiveXYFrame: ResponsiveXYFrame,
  SparkOrdinalFrame: SparkOrdinalFrame,
  SparkNetworkFrame: SparkNetworkFrame,
  SparkXYFrame: SparkXYFrame,
  Legend: Legend,
  chuckCloseCanvasTransform: chuckCloseCanvasTransform,
  Mark: lib_2$1
};

exports['default'] = index;
exports.AnnotationLayer = AnnotationLayer;
exports.DividedLine = DividedLine;
exports.XYFrame = XYFrame;
exports.MinimapXYFrame = MinimapXYFrame;
exports.MinimapNetworkFrame = MinimapNetworkFrame;
exports.MiniMap = MiniMap;
exports.Brush = Brush;
exports.Axis = Axis;
exports.InteractionLayer = InteractionLayer;
exports.VisualizationLayer = VisualizationLayer;
exports.OrdinalFrame = OrdinalFrame;
exports.ORFrame = ORFrame;
exports.funnelize = funnelize;
exports.calculateDataExtent = calculateDataExtent;
exports.Annotation = SemioticAnnotation;
exports.NetworkFrame = NetworkFrame;
exports.ResponsiveMinimapXYFrame = ResponsiveMinimapXYFrame;
exports.ResponsiveOrdinalFrame = ResponsiveOrdinalFrame;
exports.ResponsiveORFrame = ResponsiveORFrame;
exports.ResponsiveNetworkFrame = ResponsiveNetworkFrame;
exports.ResponsiveXYFrame = ResponsiveXYFrame;
exports.SparkOrdinalFrame = SparkOrdinalFrame;
exports.SparkNetworkFrame = SparkNetworkFrame;
exports.SparkXYFrame = SparkXYFrame;
exports.Legend = Legend;
exports.chuckCloseCanvasTransform = chuckCloseCanvasTransform;
exports.Mark = lib_2$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));
